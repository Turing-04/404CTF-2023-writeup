void _init()
{
    if (__gmon_start__ != 0)
    {
        __gmon_start__();
    }
}

int64_t sub_2020()
{
    int64_t var_8 = data_37ff0;
    /* jump -> data_37ff8 */
}

int64_t ftell(FILE* fp)
{
    /* tailcall */
    return ftell(fp);
}

int64_t sub_2036()
{
    int64_t var_8 = 0;
    /* tailcall */
    return sub_2020();
}

int32_t ungetc(int32_t c, FILE* fp)
{
    /* tailcall */
    return ungetc(c, fp);
}

int64_t sub_2046()
{
    int64_t var_8 = 1;
    /* tailcall */
    return sub_2020();
}

int64_t glfwGetKey()
{
    /* tailcall */
    return glfwGetKey();
}

int64_t sub_2056()
{
    int64_t var_8 = 2;
    /* tailcall */
    return sub_2020();
}

char* strstr(char const* arg1, char const* arg2)
{
    /* tailcall */
    return strstr(arg1, arg2);
}

int64_t sub_2066()
{
    int64_t var_8 = 3;
    /* tailcall */
    return sub_2020();
}

uint64_t strlen(char const* arg1)
{
    /* tailcall */
    return strlen(arg1);
}

int64_t sub_2076()
{
    int64_t var_8 = 4;
    /* tailcall */
    return sub_2020();
}

int32_t strncmp(char const* arg1, char const* arg2, uint64_t arg3)
{
    /* tailcall */
    return strncmp(arg1, arg2, arg3);
}

int64_t sub_2086()
{
    int64_t var_8 = 5;
    /* tailcall */
    return sub_2020();
}

int64_t memset(void* arg1, int32_t arg2, uint64_t arg3)
{
    /* tailcall */
    return memset(arg1, arg2, arg3);
}

int64_t sub_2096()
{
    int64_t var_8 = 6;
    /* tailcall */
    return sub_2020();
}

int64_t glfwMakeContextCurrent()
{
    /* tailcall */
    return glfwMakeContextCurrent();
}

int64_t sub_20a6()
{
    int64_t var_8 = 7;
    /* tailcall */
    return sub_2020();
}

void __assert_fail(char const* assertion, char const* file, uint32_t line, 
    char const* function) __noreturn
{
    /* tailcall */
    return __assert_fail(assertion, file, line, function);
}

int64_t sub_20b6()
{
    int64_t var_8 = 8;
    /* tailcall */
    return sub_2020();
}

int64_t dlclose()
{
    /* tailcall */
    return dlclose();
}

int64_t sub_20c6()
{
    int64_t var_8 = 9;
    /* tailcall */
    return sub_2020();
}

int64_t memcpy(void* arg1, void const* arg2, uint64_t arg3)
{
    /* tailcall */
    return memcpy(arg1, arg2, arg3);
}

int64_t sub_20d6()
{
    int64_t var_8 = 0xa;
    /* tailcall */
    return sub_2020();
}

int64_t glfwWindowHint()
{
    /* tailcall */
    return glfwWindowHint();
}

int64_t sub_20e6()
{
    int64_t var_8 = 0xb;
    /* tailcall */
    return sub_2020();
}

int64_t dlsym()
{
    /* tailcall */
    return dlsym();
}

int64_t sub_20f6()
{
    int64_t var_8 = 0xc;
    /* tailcall */
    return sub_2020();
}

int64_t glfwPollEvents()
{
    /* tailcall */
    return glfwPollEvents();
}

int64_t sub_2106()
{
    int64_t var_8 = 0xd;
    /* tailcall */
    return sub_2020();
}

int32_t __isoc99_sscanf(char const* s, char const* format, ...)
{
    /* tailcall */
    return __isoc99_sscanf();
}

int64_t sub_2116()
{
    int64_t var_8 = 0xe;
    /* tailcall */
    return sub_2020();
}

class std::ostream& std::operator<<<std::char_traits<char> >(
    class std::ostream& __out, char const* __s)
{
    /* tailcall */
    return std::operator<<<std::char_traits<char> >(__out, __s);
}

int64_t sub_2126()
{
    int64_t var_8 = 0xf;
    /* tailcall */
    return sub_2020();
}

int32_t fclose(FILE* fp)
{
    /* tailcall */
    return fclose(fp);
}

int64_t sub_2136()
{
    int64_t var_8 = 0x10;
    /* tailcall */
    return sub_2020();
}

int64_t glfwTerminate()
{
    /* tailcall */
    return glfwTerminate();
}

int64_t sub_2146()
{
    int64_t var_8 = 0x11;
    /* tailcall */
    return sub_2020();
}

std::ostream::__ostream_type* std::ostream::operator<<(
    class std::ostream* const this, 
    std::ostream::__ostream_type& (* __pf)(std::ostream::__ostream_type&))
{
    /* tailcall */
    return std::ostream::operator<<(this, __pf);
}

int64_t sub_2156()
{
    int64_t var_8 = 0x12;
    /* tailcall */
    return sub_2020();
}

int32_t fseek(FILE* fp, int64_t offset, int32_t whence)
{
    /* tailcall */
    return fseek(fp, offset, whence);
}

int64_t sub_2166()
{
    int64_t var_8 = 0x13;
    /* tailcall */
    return sub_2020();
}

void __stack_chk_fail() __noreturn
{
    /* tailcall */
    return __stack_chk_fail();
}

int64_t sub_2176()
{
    int64_t var_8 = 0x14;
    /* tailcall */
    return sub_2020();
}

int64_t glfwInit()
{
    /* tailcall */
    return glfwInit();
}

int64_t sub_2186()
{
    int64_t var_8 = 0x15;
    /* tailcall */
    return sub_2020();
}

FILE* fopen(char const* filename, char const* mode)
{
    /* tailcall */
    return fopen(filename, mode);
}

int64_t sub_2196()
{
    int64_t var_8 = 0x16;
    /* tailcall */
    return sub_2020();
}

void free(void* mem)
{
    /* tailcall */
    return free(mem);
}

int64_t sub_21a6()
{
    int64_t var_8 = 0x17;
    /* tailcall */
    return sub_2020();
}

int64_t glfwSetWindowShouldClose()
{
    /* tailcall */
    return glfwSetWindowShouldClose();
}

int64_t sub_21b6()
{
    int64_t var_8 = 0x18;
    /* tailcall */
    return sub_2020();
}

int64_t malloc(uint64_t bytes)
{
    /* tailcall */
    return malloc(bytes);
}

int64_t sub_21c6()
{
    int64_t var_8 = 0x19;
    /* tailcall */
    return sub_2020();
}

int64_t glfwSwapBuffers()
{
    /* tailcall */
    return glfwSwapBuffers();
}

int64_t sub_21d6()
{
    int64_t var_8 = 0x1a;
    /* tailcall */
    return sub_2020();
}

void ldexpf(int32_t exp, float value)
{
    /* tailcall */
    return ldexpf(exp, value);
}

int64_t sub_21e6()
{
    int64_t var_8 = 0x1b;
    /* tailcall */
    return sub_2020();
}

int64_t dlopen()
{
    /* tailcall */
    return dlopen();
}

int64_t sub_21f6()
{
    int64_t var_8 = 0x1c;
    /* tailcall */
    return sub_2020();
}

int32_t strcmp(char const* arg1, char const* arg2)
{
    /* tailcall */
    return strcmp(arg1, arg2);
}

int64_t sub_2206()
{
    int64_t var_8 = 0x1d;
    /* tailcall */
    return sub_2020();
}

int64_t strtol(char const* nptr, char** endptr, int32_t base)
{
    /* tailcall */
    return strtol(nptr, endptr, base);
}

int64_t sub_2216()
{
    int64_t var_8 = 0x1e;
    /* tailcall */
    return sub_2020();
}

int64_t glfwSetFramebufferSizeCallback()
{
    /* tailcall */
    return glfwSetFramebufferSizeCallback();
}

int64_t sub_2226()
{
    int64_t var_8 = 0x1f;
    /* tailcall */
    return sub_2020();
}

uint64_t fread(void* buf, uint64_t size, uint64_t count, FILE* fp)
{
    /* tailcall */
    return fread(buf, size, count, fp);
}

int64_t sub_2236()
{
    int64_t var_8 = 0x20;
    /* tailcall */
    return sub_2020();
}

int32_t feof(FILE* fp)
{
    /* tailcall */
    return feof(fp);
}

int64_t sub_2246()
{
    int64_t var_8 = 0x21;
    /* tailcall */
    return sub_2020();
}

int64_t glfwCreateWindow()
{
    /* tailcall */
    return glfwCreateWindow();
}

int64_t sub_2256()
{
    int64_t var_8 = 0x22;
    /* tailcall */
    return sub_2020();
}

float powf(float x, float y)
{
    /* tailcall */
    return powf(x, y);
}

int64_t sub_2266()
{
    int64_t var_8 = 0x23;
    /* tailcall */
    return sub_2020();
}

int32_t fgetc(FILE* fp)
{
    /* tailcall */
    return fgetc(fp);
}

int64_t sub_2276()
{
    int64_t var_8 = 0x24;
    /* tailcall */
    return sub_2020();
}

int64_t glfwGetFramebufferSize()
{
    /* tailcall */
    return glfwGetFramebufferSize();
}

int64_t sub_2286()
{
    int64_t var_8 = 0x25;
    /* tailcall */
    return sub_2020();
}

int64_t realloc(void* oldmem, uint64_t bytes)
{
    /* tailcall */
    return realloc(oldmem, bytes);
}

int64_t sub_2296()
{
    int64_t var_8 = 0x26;
    /* tailcall */
    return sub_2020();
}

int64_t glfwWindowShouldClose()
{
    /* tailcall */
    return glfwWindowShouldClose();
}

int64_t sub_22a6()
{
    int64_t var_8 = 0x27;
    /* tailcall */
    return sub_2020();
}

int32_t ferror(FILE* fp)
{
    /* tailcall */
    return ferror(fp);
}

int64_t sub_22b6()
{
    int64_t var_8 = 0x28;
    /* tailcall */
    return sub_2020();
}

int64_t glfwGetCursorPos()
{
    /* tailcall */
    return glfwGetCursorPos();
}

int64_t sub_22c6()
{
    int64_t var_8 = 0x29;
    /* tailcall */
    return sub_2020();
}

int64_t _start(int64_t arg1, int64_t arg2, void (* arg3)()) __noreturn
{
    int64_t rax;
    int64_t var_8 = rax;
    __libc_start_main(main, __return_addr, &arg_8, nullptr, nullptr, arg3, &var_8);
    /* no return */
}

void deregister_tm_clones()
{
    return;
}

void sub_2330()
{
    return;
}

void sub_2370()
{
    if (data_38390 != 0)
    {
        return;
    }
    if (__cxa_finalize != 0)
    {
        __cxa_finalize(__dso_handle);
    }
    deregister_tm_clones();
    data_38390 = 1;
}

void sub_23c0()
{
    /* tailcall */
    return sub_2330();
}

int64_t stbi__sse2_available()
{
    return 1;
}

void* stbi__start_mem(void* arg1, int64_t arg2, int32_t arg3)
{
    *(arg1 + 0x10) = 0;
    *(arg1 + 0x30) = 0;
    *(arg1 + 0xb8) = 0;
    *(arg1 + 0xd0) = arg2;
    *(arg1 + 0xc0) = *(arg1 + 0xd0);
    *(arg1 + 0xd8) = (arg3 + arg2);
    *(arg1 + 0xc8) = *(arg1 + 0xd8);
    return arg1;
}

char* stbi__start_callbacks(char* arg1, int64_t* arg2, int64_t arg3)
{
    int64_t rdx = arg2[1];
    *(arg1 + 0x10) = *arg2;
    *(arg1 + 0x18) = rdx;
    *(arg1 + 0x20) = arg2[2];
    *(arg1 + 0x28) = arg3;
    *(arg1 + 0x34) = 0x80;
    *(arg1 + 0x30) = 1;
    *(arg1 + 0xb8) = 0;
    *(arg1 + 0xd0) = &arg1[0x38];
    *(arg1 + 0xc0) = *(arg1 + 0xd0);
    stbi__refill_buffer(arg1);
    *(arg1 + 0xd8) = *(arg1 + 0xc8);
    return arg1;
}

uint64_t stbi__stdio_read(FILE* arg1, int64_t arg2, int32_t arg3)
{
    return fread(arg2, 1, arg3, arg1);
}

int64_t stbi__stdio_skip(FILE* arg1, int32_t arg2)
{
    fseek(arg1, arg2, 1);
    int64_t rax_3 = fgetc(arg1);
    int32_t var_c = rax_3;
    if (var_c != 0xffffffff)
    {
        rax_3 = ungetc(var_c, arg1);
    }
    return rax_3;
}

uint64_t stbi__stdio_eof(FILE* arg1)
{
    int32_t rax_1 = feof(arg1);
    int32_t rax_3;
    char rax_4;
    if (rax_1 == 0)
    {
        rax_3 = ferror(arg1);
        if (rax_3 == 0)
        {
            rax_4 = 0;
        }
    }
    if ((rax_1 != 0 || (rax_1 == 0 && rax_3 != 0)))
    {
        rax_4 = 1;
    }
    return rax_4;
}

char* stbi__start_file(char* arg1, int64_t arg2)
{
    return stbi__start_callbacks(arg1, &stbi__stdio_callbacks, arg2);
}

void* stbi__rewind(void* arg1)
{
    *(arg1 + 0xc0) = *(arg1 + 0xd0);
    *(arg1 + 0xc8) = *(arg1 + 0xd8);
    return arg1;
}

int64_t stbi_failure_reason()
{
    void* fsbase;
    return *(fsbase - 0x20);
}

int64_t stbi__err(int64_t arg1)
{
    void* fsbase;
    *(fsbase - 0x20) = arg1;
    return 0;
}

int64_t stbi__malloc(uint64_t arg1)
{
    return malloc(arg1);
}

uint64_t stbi__addsizes_valid(int32_t arg1, int32_t arg2)
{
    uint64_t rax;
    if (arg2 >= 0)
    {
        int32_t rax_1;
        rax_1 = arg1 <= (0x7fffffff - arg2);
        rax = rax_1;
    }
    else
    {
        rax = 0;
    }
    return rax;
}

uint64_t stbi__mul2sizes_valid(int32_t arg1, int32_t arg2)
{
    uint64_t rax;
    if ((arg1 < 0 || (arg1 >= 0 && arg2 < 0)))
    {
        rax = 0;
    }
    if ((arg1 >= 0 && arg2 >= 0))
    {
        if (arg2 != 0)
        {
            int32_t temp2_1;
            int32_t temp3_1;
            temp2_1 = HIGHD(0x7fffffff);
            temp3_1 = LOWD(0x7fffffff);
            int32_t rax_1;
            rax_1 = arg1 <= (COMBINE(0, 0x7fffffff) / arg2);
            rax = rax_1;
        }
        else
        {
            rax = 1;
        }
    }
    return rax;
}

uint64_t stbi__mad2sizes_valid(int32_t arg1, int32_t arg2, int32_t arg3)
{
    int32_t rax_1 = stbi__mul2sizes_valid(arg1, arg2);
    int32_t rax_4;
    char rax_5;
    if (rax_1 != 0)
    {
        rax_4 = stbi__addsizes_valid((arg1 * arg2), arg3);
        if (rax_4 != 0)
        {
            rax_5 = 1;
        }
    }
    if ((rax_1 == 0 || (rax_1 != 0 && rax_4 == 0)))
    {
        rax_5 = 0;
    }
    return rax_5;
}

uint64_t stbi__mad3sizes_valid(int32_t arg1, int32_t arg2, int32_t arg3, 
    int32_t arg4)
{
    int32_t rax_1 = stbi__mul2sizes_valid(arg1, arg2);
    int32_t rax_4;
    int32_t rax_8;
    char rax_9;
    if (rax_1 != 0)
    {
        rax_4 = stbi__mul2sizes_valid((arg1 * arg2), arg3);
        if (rax_4 != 0)
        {
            rax_8 = stbi__addsizes_valid(((arg1 * arg2) * arg3), arg4);
            if (rax_8 != 0)
            {
                rax_9 = 1;
            }
        }
    }
    if (((rax_1 == 0 || (rax_1 != 0 && rax_4 == 0)) || ((rax_1 != 0 && rax_4 != 0) && rax_8 == 
0)))
    {
        rax_9 = 0;
    }
    return rax_9;
}

uint64_t stbi__mad4sizes_valid(int32_t arg1, int32_t arg2, int32_t arg3, 
    int32_t arg4, int32_t arg5)
{
    char rax_14;
    if (stbi__mul2sizes_valid(arg1, arg2) == 0)
    {
    label_2818:
        rax_14 = 0;
    }
    else
    {
        if (stbi__mul2sizes_valid((arg1 * arg2), arg3) == 0)
        {
            goto label_2818;
        }
        if (stbi__mul2sizes_valid(((arg1 * arg2) * arg3), arg4) == 0)
        {
            goto label_2818;
        }
        if (stbi__addsizes_valid((((arg1 * arg2) * arg3) * arg4), arg5) == 0)
        {
            goto label_2818;
        }
        rax_14 = 1;
    }
    return rax_14;
}

int64_t stbi__malloc_mad2(int32_t arg1, int32_t arg2, int32_t arg3)
{
    int32_t rax_1;
    rax_1 = stbi__mad2sizes_valid(arg1, arg2, arg3) == 0;
    int64_t rax_2;
    if (rax_1 == 0)
    {
        rax_2 = stbi__malloc((arg3 + (arg1 * arg2)));
    }
    else
    {
        rax_2 = 0;
    }
    return rax_2;
}

int64_t stbi__malloc_mad3(int32_t arg1, int32_t arg2, int32_t arg3, 
    int32_t arg4)
{
    int32_t rax_1;
    rax_1 = stbi__mad3sizes_valid(arg1, arg2, arg3, arg4) == 0;
    int64_t rax_2;
    if (rax_1 == 0)
    {
        rax_2 = stbi__malloc((arg4 + ((arg1 * arg2) * arg3)));
    }
    else
    {
        rax_2 = 0;
    }
    return rax_2;
}

int64_t stbi__malloc_mad4(int32_t arg1, int32_t arg2, int32_t arg3, 
    int32_t arg4, int32_t arg5)
{
    int32_t rax_1;
    rax_1 = stbi__mad4sizes_valid(arg1, arg2, arg3, arg4, arg5) == 0;
    int64_t rax_2;
    if (rax_1 == 0)
    {
        rax_2 = stbi__malloc((arg5 + (((arg1 * arg2) * arg3) * arg4)));
    }
    else
    {
        rax_2 = 0;
    }
    return rax_2;
}

uint64_t stbi__addints_valid(int32_t arg1, int32_t arg2)
{
    uint64_t rax_2;
    if ((arg1 ^ arg2) < 0)
    {
        rax_2 = 1;
    }
    else
    {
        if ((arg1 >= 0 || (arg1 < 0 && arg2 >= 0)))
        {
            int32_t rax_4;
            rax_4 = arg1 <= (0x7fffffff - arg2);
            rax_2 = rax_4;
        }
        if ((arg1 < 0 && arg2 < 0))
        {
            int32_t rax_3;
            rax_3 = arg1 >= (0x80000000 - arg2);
            rax_2 = rax_3;
        }
    }
    return rax_2;
}

uint64_t stbi__mul2shorts_valid(int16_t arg1, int16_t arg2)
{
    uint64_t rax_1;
    if ((arg2 == 0 || arg2 == 0xffff))
    {
        rax_1 = 1;
    }
    if ((arg2 != 0 && arg2 != 0xffff))
    {
        if ((arg1 ^ arg2) >= 0)
        {
            int32_t temp2_1;
            int32_t temp3_1;
            temp2_1 = HIGHD(0x7fff);
            temp3_1 = LOWD(0x7fff);
            int32_t rax_3;
            rax_3 = arg1 <= (COMBINE(0, 0x7fff) / arg2);
            rax_1 = rax_3;
        }
        else if (arg2 >= 0)
        {
            int32_t temp8_1;
            int32_t temp9_1;
            temp8_1 = HIGHD(-0x8000);
            temp9_1 = LOWD(-0x8000);
            int32_t rax_5;
            rax_5 = arg1 >= (COMBINE(0xffffffff, 0xffff8000) / arg2);
            rax_1 = rax_5;
        }
        else
        {
            int32_t temp14_1;
            int32_t temp15_1;
            temp14_1 = HIGHD(-0x8000);
            temp15_1 = LOWD(-0x8000);
            int32_t rax_4;
            rax_4 = arg1 <= (COMBINE(0xffffffff, 0xffff8000) / arg2);
            rax_1 = rax_4;
        }
    }
    return rax_1;
}

int64_t stbi_image_free(int64_t arg1)
{
    return free(arg1);
}

uint64_t stbi_set_flip_vertically_on_load(int32_t arg1)
{
    uint64_t rax = arg1;
    stbi__vertically_flip_on_load_global = rax;
    return rax;
}

uint64_t stbi_set_flip_vertically_on_load_thread(int32_t arg1)
{
    uint64_t rax = arg1;
    void* fsbase;
    *(fsbase - 0x18) = rax;
    *(fsbase - 0x14) = 1;
    return rax;
}

char* stbi__load_main(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, 
    int32_t arg5, int32_t* arg6, int32_t arg7)
{
    memset(arg6, 0, 0xc);
    *arg6 = 8;
    arg6[2] = 0;
    arg6[1] = 0;
    int32_t rax_5;
    rax_5 = stbi__png_test(arg1) != 0;
    char* rax_7;
    if (rax_5 != 0)
    {
        rax_7 = stbi__png_load(arg1, arg2, arg3, arg4, arg5, arg6);
    }
    else
    {
        int32_t rax_9;
        rax_9 = stbi__bmp_test(arg1) != 0;
        if (rax_9 != 0)
        {
            rax_7 = stbi__bmp_load(arg1, arg2, arg3, arg4, arg5);
        }
        else
        {
            int32_t rax_12;
            rax_12 = stbi__gif_test(arg1) != 0;
            if (rax_12 != 0)
            {
                rax_7 = stbi__gif_load(arg1, arg2, arg3, arg4, arg5);
            }
            else
            {
                int32_t rax_15;
                rax_15 = stbi__psd_test(arg1) != 0;
                if (rax_15 != 0)
                {
                    rax_7 = stbi__psd_load(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                }
                else
                {
                    int32_t rax_18;
                    rax_18 = stbi__pic_test(arg1) != 0;
                    if (rax_18 != 0)
                    {
                        rax_7 = stbi__pic_load(arg1, arg2, arg3, arg4, arg5);
                    }
                    else
                    {
                        int32_t rax_21;
                        rax_21 = stbi__jpeg_test(arg1) != 0;
                        if (rax_21 != 0)
                        {
                            rax_7 = stbi__jpeg_load(arg1, arg2, arg3, arg4, arg5);
                        }
                        else
                        {
                            int32_t rax_24;
                            rax_24 = stbi__pnm_test(arg1) != 0;
                            if (rax_24 != 0)
                            {
                                rax_7 = stbi__pnm_load(arg1, arg2, arg3, arg4, arg5, arg6);
                            }
                            else
                            {
                                int32_t rax_27;
                                rax_27 = stbi__hdr_test(arg1) != 0;
                                if (rax_27 == 0)
                                {
                                    int32_t rax_33;
                                    rax_33 = stbi__tga_test(arg1) != 0;
                                    if (rax_33 == 0)
                                    {
                                        stbi__err("unknown image type");
                                        rax_7 = nullptr;
                                    }
                                    else
                                    {
                                        rax_7 = stbi__tga_load(arg1, arg2, arg3, arg4, arg5);
                                    }
                                }
                                else
                                {
                                    uint64_t rax_29 = stbi__hdr_load(arg1, arg2, arg3, arg4, 
arg5);
                                    int32_t rax_31;
                                    if (arg5 != 0)
                                    {
                                        rax_31 = arg5;
                                    }
                                    else
                                    {
                                        rax_31 = *arg4;
                                    }
                                    rax_7 = stbi__hdr_to_ldr(rax_29, *arg2, *arg3, rax_31);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return rax_7;
}

void* stbi__convert_16_to_8(void* arg1, int32_t arg2, int32_t arg3, 
    int32_t arg4)
{
    int32_t rax_2 = ((arg2 * arg3) * arg4);
    void* rax_5 = stbi__malloc(rax_2);
    void* rax_6;
    if (rax_5 == 0)
    {
        stbi__err("outofmem");
        rax_6 = nullptr;
    }
    else
    {
        for (int32_t var_18_1 = 0; var_18_1 < rax_2; var_18_1 = (var_18_1 + 1))
        {
            int64_t rax_8 = var_18_1;
            *(rax_5 + var_18_1) = (*(arg1 + (rax_8 + rax_8)) >> 8);
        }
        free(arg1);
        rax_6 = rax_5;
    }
    return rax_6;
}

void* stbi__convert_8_to_16(void* arg1, int32_t arg2, int32_t arg3, 
    int32_t arg4)
{
    int32_t rax_2 = ((arg2 * arg3) * arg4);
    void* rax_6 = stbi__malloc((rax_2 + rax_2));
    void* rax_7;
    if (rax_6 == 0)
    {
        stbi__err("outofmem");
        rax_7 = nullptr;
    }
    else
    {
        for (int32_t var_18_1 = 0; var_18_1 < rax_2; var_18_1 = (var_18_1 + 1))
        {
            int64_t rax_19 = var_18_1;
            *(rax_6 + (rax_19 + rax_19)) = ((*(arg1 + var_18_1) << 8) + *(arg1 + var_18_1));
        }
        free(arg1);
        rax_7 = rax_6;
    }
    return rax_7;
}

int64_t stbi__vertical_flip(int64_t arg1, int32_t arg2, int32_t arg3, 
    int32_t arg4)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    uint64_t rax_4 = (arg4 * arg2);
    for (int32_t var_84c = 0; var_84c < (arg3 >> 1); var_84c = (var_84c + 1))
    {
        int64_t var_848_1 = (arg1 + (var_84c * rax_4));
        int64_t var_840_1 = (arg1 + (((arg3 - var_84c) - 1) * rax_4));
        uint64_t rax_19;
        for (uint64_t var_838_1 = rax_4; var_838_1 != 0; var_838_1 = (var_838_1 - rax_19))
        {
            rax_19 = var_838_1;
            if (rax_19 > 0x800)
            {
                rax_19 = 0x800;
            }
            void var_818;
            memcpy(&var_818, var_848_1, rax_19);
            memcpy(var_848_1, var_840_1, rax_19);
            memcpy(var_840_1, &var_818, rax_19);
            var_848_1 = (var_848_1 + rax_19);
            var_840_1 = (var_840_1 + rax_19);
        }
    }
    if (rax == *(fsbase + 0x28))
    {
        return (rax - *(fsbase + 0x28));
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi__vertical_flip_slices(int64_t arg1, int32_t arg2, int32_t arg3, 
    int32_t arg4, int32_t arg5)
{
    int64_t var_10 = arg1;
    int32_t var_18 = 0;
    uint64_t rax_7;
    while (true)
    {
        rax_7 = var_18;
        if (rax_7 >= arg4)
        {
            break;
        }
        stbi__vertical_flip(var_10, arg2, arg3, arg5);
        var_10 = (var_10 + ((arg2 * arg3) * arg5));
        var_18 = (var_18 + 1);
    }
    return rax_7;
}

char* stbi__load_and_postprocess_8bit(char* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t var_1c;
    char* var_28 = stbi__load_main(arg1, arg2, arg3, arg4, arg5, &var_1c, 8);
    char* rax_3;
    if (var_28 == 0)
    {
        rax_3 = nullptr;
    }
    else
    {
        if ((var_1c != 8 && var_1c != 0x10))
        {
            __assert_fail("ri.bits_per_channel == 8 || ri.b…", "stb_image.h", 0x4f3, "unsigned 
char* stbi__load_and_po…");
            /* no return */
        }
        if (var_1c != 8)
        {
            int32_t rax_8;
            if (arg5 != 0)
            {
                rax_8 = arg5;
            }
            else
            {
                rax_8 = *arg4;
            }
            var_28 = stbi__convert_16_to_8(var_28, *arg2, *arg3, rax_8);
            var_1c = 8;
        }
        uint32_t rax_11;
        if (*(fsbase - 0x14) == 0)
        {
            rax_11 = stbi__vertically_flip_on_load_global;
        }
        else
        {
            rax_11 = *(fsbase - 0x18);
        }
        if (rax_11 != 0)
        {
            int32_t rax_13;
            if (arg5 != 0)
            {
                rax_13 = arg5;
            }
            else
            {
                rax_13 = *arg4;
            }
            stbi__vertical_flip(var_28, *arg2, *arg3, rax_13);
        }
        rax_3 = var_28;
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_3;
    }
    __stack_chk_fail();
    /* no return */
}

char* stbi__load_and_postprocess_16bit(char* arg1, int32_t* arg2, 
    int32_t* arg3, int32_t* arg4, int32_t arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t var_1c;
    char* var_28 = stbi__load_main(arg1, arg2, arg3, arg4, arg5, &var_1c, 0x10);
    char* rax_3;
    if (var_28 == 0)
    {
        rax_3 = nullptr;
    }
    else
    {
        if ((var_1c != 8 && var_1c != 0x10))
        {
            __assert_fail("ri.bits_per_channel == 8 || ri.b…", "stb_image.h", 0x50d, 
"stbi__uint16* stbi__load_and_pos…");
            /* no return */
        }
        if (var_1c != 0x10)
        {
            int32_t rax_8;
            if (arg5 != 0)
            {
                rax_8 = arg5;
            }
            else
            {
                rax_8 = *arg4;
            }
            var_28 = stbi__convert_8_to_16(var_28, *arg2, *arg3, rax_8);
            var_1c = 0x10;
        }
        uint32_t rax_11;
        if (*(fsbase - 0x14) == 0)
        {
            rax_11 = stbi__vertically_flip_on_load_global;
        }
        else
        {
            rax_11 = *(fsbase - 0x18);
        }
        if (rax_11 != 0)
        {
            int32_t rax_13;
            if (arg5 != 0)
            {
                rax_13 = arg5;
            }
            else
            {
                rax_13 = *arg4;
            }
            stbi__vertical_flip(var_28, *arg2, *arg3, (rax_13 + rax_13));
        }
        rax_3 = var_28;
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_3;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi__float_postprocess(int64_t arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5)
{
    uint64_t rax_1;
    void* fsbase;
    if (*(fsbase - 0x14) == 0)
    {
        rax_1 = stbi__vertically_flip_on_load_global;
    }
    else
    {
        rax_1 = *(fsbase - 0x18);
    }
    if ((rax_1 != 0 && arg1 != 0))
    {
        int32_t rax_3;
        if (arg5 != 0)
        {
            rax_3 = arg5;
        }
        else
        {
            rax_3 = *arg4;
        }
        rax_1 = stbi__vertical_flip(arg1, *arg2, *arg3, (rax_3 << 2));
    }
    return rax_1;
}

FILE* stbi__fopen(char* arg1, char* arg2)
{
    return fopen(arg1, arg2);
}

char* stbi_load(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, 
    int32_t arg5)
{
    FILE* rax_1 = stbi__fopen(arg1, &data_22136);
    char* rax_2;
    if (rax_1 != 0)
    {
        char* rax_4 = stbi_load_from_file(rax_1, arg2, arg3, arg4, arg5);
        fclose(rax_1);
        rax_2 = rax_4;
    }
    else
    {
        stbi__err("can't fopen");
        rax_2 = nullptr;
    }
    return rax_2;
}

char* stbi_load_from_file(FILE* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_file(&var_f8, arg1);
    char* rax_1 = stbi__load_and_postprocess_8bit(&var_f8, arg2, arg3, arg4, arg5);
    int32_t var_38;
    int32_t var_30;
    if (rax_1 != 0)
    {
        fseek(arg1, (-(var_30 - var_38)), 1);
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

char* stbi_load_from_file_16(FILE* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_file(&var_f8, arg1);
    char* rax_1 = stbi__load_and_postprocess_16bit(&var_f8, arg2, arg3, arg4, arg5);
    int32_t var_38;
    int32_t var_30;
    if (rax_1 != 0)
    {
        fseek(arg1, (-(var_30 - var_38)), 1);
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

char* stbi_load_16(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, 
    int32_t arg5)
{
    FILE* rax_1 = stbi__fopen(arg1, &data_22136);
    char* rax_2;
    if (rax_1 != 0)
    {
        char* rax_4 = stbi_load_from_file_16(rax_1, arg2, arg3, arg4, arg5);
        fclose(rax_1);
        rax_2 = rax_4;
    }
    else
    {
        stbi__err("can't fopen");
        rax_2 = nullptr;
    }
    return rax_2;
}

char* stbi_load_16_from_memory(int64_t arg1, int32_t arg2, int32_t* arg3, 
    int32_t* arg4, int32_t* arg5, int32_t arg6)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_mem(&var_f8, arg1, arg2);
    char* rax_1 = stbi__load_and_postprocess_16bit(&var_f8, arg3, arg4, arg5, arg6);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

char* stbi_load_16_from_callbacks(int64_t* arg1, int64_t arg2, int32_t* arg3, 
    int32_t* arg4, int32_t* arg5, int32_t arg6)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_callbacks(&var_f8, arg1, arg2);
    char* rax_1 = stbi__load_and_postprocess_16bit(&var_f8, arg3, arg4, arg5, arg6);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

char* stbi_load_from_memory(int64_t arg1, int32_t arg2, int32_t* arg3, 
    int32_t* arg4, int32_t* arg5, int32_t arg6)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_mem(&var_f8, arg1, arg2);
    char* rax_1 = stbi__load_and_postprocess_8bit(&var_f8, arg3, arg4, arg5, arg6);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

char* stbi_load_from_callbacks(int64_t* arg1, int64_t arg2, int32_t* arg3, 
    int32_t* arg4, int32_t* arg5, int32_t arg6)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_callbacks(&var_f8, arg1, arg2);
    char* rax_1 = stbi__load_and_postprocess_8bit(&var_f8, arg3, arg4, arg5, arg6);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi_load_gif_from_memory(int64_t arg1, int32_t arg2, int64_t* arg3, 
    int32_t* arg4, int32_t* arg5, int32_t* arg6, int32_t* arg7, int32_t arg8)
{
    void* fsbase;
    int64_t rax_1 = *(fsbase + 0x28);
    void var_f8;
    stbi__start_mem(&var_f8, arg1, arg2);
    int64_t rax_2 = stbi__load_gif_main(&var_f8, arg3, arg4, arg5, arg6, arg7, arg8);
    uint32_t rax_4;
    if (*(fsbase - 0x14) == 0)
    {
        rax_4 = stbi__vertically_flip_on_load_global;
    }
    else
    {
        rax_4 = *(fsbase - 0x18);
    }
    if (rax_4 != 0)
    {
        stbi__vertical_flip_slices(rax_2, *arg4, *arg5, *arg6, *arg7);
    }
    *(fsbase + 0x28);
    if (rax_1 == *(fsbase + 0x28))
    {
        return rax_2;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi__loadf_main(char* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t rax_2;
    rax_2 = stbi__hdr_test(arg1) != 0;
    uint64_t rax_10;
    if (rax_2 == 0)
    {
        char* rax_7 = stbi__load_and_postprocess_8bit(arg1, arg2, arg3, arg4, arg5);
        if (rax_7 == 0)
        {
            stbi__err("unknown image type");
            rax_10 = 0;
        }
        else
        {
            int32_t rax_9;
            if (arg5 != 0)
            {
                rax_9 = arg5;
            }
            else
            {
                rax_9 = *arg4;
            }
            rax_10 = stbi__ldr_to_hdr(rax_7, *arg2, *arg3, rax_9);
        }
    }
    else
    {
        uint64_t rax_4 = stbi__hdr_load(arg1, arg2, arg3, arg4, arg5);
        if (rax_4 != 0)
        {
            stbi__float_postprocess(rax_4, arg2, arg3, arg4, arg5);
        }
        rax_10 = rax_4;
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_10;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi_loadf_from_memory(int64_t arg1, int32_t arg2, int32_t* arg3, 
    int32_t* arg4, int32_t* arg5, int32_t arg6)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_mem(&var_f8, arg1, arg2);
    uint64_t rax_1 = stbi__loadf_main(&var_f8, arg3, arg4, arg5, arg6);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi_loadf_from_callbacks(int64_t* arg1, int64_t arg2, int32_t* arg3, 
    int32_t* arg4, int32_t* arg5, int32_t arg6)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_callbacks(&var_f8, arg1, arg2);
    uint64_t rax_1 = stbi__loadf_main(&var_f8, arg3, arg4, arg5, arg6);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi_loadf(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, 
    int32_t arg5)
{
    FILE* rax_1 = stbi__fopen(arg1, &data_22136);
    uint64_t rax_2;
    if (rax_1 != 0)
    {
        uint64_t rax_4 = stbi_loadf_from_file(rax_1, arg2, arg3, arg4, arg5);
        fclose(rax_1);
        rax_2 = rax_4;
    }
    else
    {
        stbi__err("can't fopen");
        rax_2 = 0;
    }
    return rax_2;
}

uint64_t stbi_loadf_from_file(int64_t arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_file(&var_f8, arg1);
    uint64_t rax_1 = stbi__loadf_main(&var_f8, arg2, arg3, arg4, arg5);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi_is_hdr_from_memory(int64_t arg1, int32_t arg2)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_mem(&var_f8, arg1, arg2);
    uint64_t rax_1 = stbi__hdr_test(&var_f8);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi_is_hdr(char* arg1)
{
    FILE* rax_1 = stbi__fopen(arg1, &data_22136);
    int32_t var_14 = 0;
    if (rax_1 != 0)
    {
        var_14 = stbi_is_hdr_from_file(rax_1);
        fclose(rax_1);
    }
    return var_14;
}

uint64_t stbi_is_hdr_from_file(FILE* arg1)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t rax_2 = ftell(arg1);
    void var_f8;
    stbi__start_file(&var_f8, arg1);
    int32_t rax_3 = stbi__hdr_test(&var_f8);
    fseek(arg1, rax_2, 0);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_3;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi_is_hdr_from_callbacks(int64_t* arg1, int64_t arg2)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_callbacks(&var_f8, arg1, arg2);
    uint64_t rax_1 = stbi__hdr_test(&var_f8);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi_ldr_to_hdr_gamma(uint32_t arg1 @ zmm0)
{
    stbi__l2h_gamma = arg1;
}

int64_t stbi_ldr_to_hdr_scale(uint32_t arg1 @ zmm0)
{
    stbi__l2h_scale = arg1;
}

int64_t stbi_hdr_to_ldr_gamma(float arg1 @ zmm0)
{
    stbi__h2l_gamma_i = (1f / arg1);
}

int64_t stbi_hdr_to_ldr_scale(float arg1 @ zmm0)
{
    stbi__h2l_scale_i = (1f / arg1);
}

char* stbi__refill_buffer(char* arg1)
{
    int32_t rax_5 = *(arg1 + 0x10)(*(arg1 + 0x28), &arg1[0x38], *(arg1 + 0x34));
    *(arg1 + 0xb8) = (*(arg1 + 0xb8) + (*(arg1 + 0xc0) - *(arg1 + 0xd0)));
    char* rax_19;
    if (rax_5 != 0)
    {
        *(arg1 + 0xc0) = &arg1[0x38];
        rax_19 = arg1;
        *(rax_19 + 0xc8) = &arg1[(0x38 + rax_5)];
    }
    else
    {
        *(arg1 + 0x30) = 0;
        *(arg1 + 0xc0) = &arg1[0x38];
        *(arg1 + 0xc8) = &arg1[0x39];
        rax_19 = *(arg1 + 0xc0);
        *rax_19 = 0;
    }
    return rax_19;
}

uint64_t stbi__get8(char* arg1)
{
    uint64_t rax_5;
    if (*(arg1 + 0xc0) < *(arg1 + 0xc8))
    {
        char* rax_4 = *(arg1 + 0xc0);
        *(arg1 + 0xc0) = &rax_4[1];
        rax_5 = *rax_4;
    }
    else if (*(arg1 + 0x30) == 0)
    {
        rax_5 = 0;
    }
    else
    {
        stbi__refill_buffer(arg1);
        char* rax_10 = *(arg1 + 0xc0);
        *(arg1 + 0xc0) = &rax_10[1];
        rax_5 = *rax_10;
    }
    return rax_5;
}

uint64_t stbi__at_eof(void* arg1)
{
    int32_t rax_5;
    uint64_t rax_6;
    if (*(arg1 + 0x10) != 0)
    {
        rax_5 = *(arg1 + 0x20)(*(arg1 + 0x28)) == 0;
        if (rax_5 != 0)
        {
            rax_6 = 0;
        }
        if ((rax_5 == 0 && *(arg1 + 0x30) == 0))
        {
            rax_6 = 1;
        }
    }
    if ((*(arg1 + 0x10) == 0 || ((*(arg1 + 0x10) != 0 && rax_5 == 0) && *(arg1 + 0x30) != 0)))
    {
        int64_t rax_11;
        rax_11 = *(arg1 + 0xc0) >= *(arg1 + 0xc8);
        rax_6 = rax_11;
    }
    return rax_6;
}

void stbi__skip(void* arg1, int32_t arg2)
{
    if (arg2 != 0)
    {
        if (arg2 < 0)
        {
            *(arg1 + 0xc0) = *(arg1 + 0xc8);
        }
        else
        {
            int32_t rdx_3;
            if (*(arg1 + 0x10) != 0)
            {
                rdx_3 = (*(arg1 + 0xc8) - *(arg1 + 0xc0));
                if (rdx_3 < arg2)
                {
                    *(arg1 + 0xc0) = *(arg1 + 0xc8);
                    *(arg1 + 0x18)(*(arg1 + 0x28), (arg2 - rdx_3));
                }
            }
            if ((*(arg1 + 0x10) == 0 || (*(arg1 + 0x10) != 0 && rdx_3 >= arg2)))
            {
                *(arg1 + 0xc0) = (*(arg1 + 0xc0) + arg2);
            }
        }
    }
}

uint64_t stbi__getn(void* arg1, int64_t arg2, int32_t arg3)
{
    uint64_t rax_22;
    int32_t rdx_1;
    if (*(arg1 + 0x10) != 0)
    {
        rdx_1 = (*(arg1 + 0xc8) - *(arg1 + 0xc0));
        if (rdx_1 < arg3)
        {
            memcpy(arg2, *(arg1 + 0xc0), rdx_1);
            int32_t rax_18;
            rax_18 = *(arg1 + 0x10)(*(arg1 + 0x28), (rdx_1 + arg2), (arg3 - rdx_1)) == (arg3 - 
rdx_1);
            *(arg1 + 0xc0) = *(arg1 + 0xc8);
            rax_22 = rax_18;
        }
    }
    if ((*(arg1 + 0x10) == 0 || (*(arg1 + 0x10) != 0 && rdx_1 >= arg3)))
    {
        if (*(arg1 + 0xc8) < (*(arg1 + 0xc0) + arg3))
        {
            rax_22 = 0;
        }
        else
        {
            memcpy(arg2, *(arg1 + 0xc0), arg3);
            *(arg1 + 0xc0) = (*(arg1 + 0xc0) + arg3);
            rax_22 = 1;
        }
    }
    return rax_22;
}

uint64_t stbi__get16be(char* arg1)
{
    uint32_t rax_4 = (stbi__get8(arg1) << 8);
    return (stbi__get8(arg1) + rax_4);
}

uint64_t stbi__get32be(char* arg1)
{
    int32_t rax_3 = (stbi__get16be(arg1) << 0x10);
    return (stbi__get16be(arg1) + rax_3);
}

uint64_t stbi__get16le(char* arg1)
{
    return (stbi__get8(arg1) + (stbi__get8(arg1) << 8));
}

uint64_t stbi__get32le(char* arg1)
{
    return (stbi__get16le(arg1) + (stbi__get16le(arg1) << 0x10));
}

uint64_t stbi__compute_y(int32_t arg1, int32_t arg2, int32_t arg3)
{
    return (((arg3 * 0x1d) + ((arg1 * 0x4d) + (arg2 * 0x96))) >> 8);
}

int64_t stbi__convert_format(int64_t arg1, int32_t arg2, int32_t arg3, 
    int32_t arg4, int32_t arg5)
{
    int64_t rax_1;
    if (arg3 == arg2)
    {
        rax_1 = arg1;
    }
    else
    {
        if ((arg3 <= 0 || (arg3 > 0 && arg3 > 4)))
        {
            __assert_fail("req_comp >= 1 && req_comp <= 4", "stb_image.h", 0x6df, "unsigned 
char* stbi__convert_for…");
            /* no return */
        }
        if ((arg3 > 0 && arg3 <= 4))
        {
            int64_t rax_3 = stbi__malloc_mad3(arg3, arg4, arg5, 0);
            if (rax_3 == 0)
            {
                free(arg1);
                stbi__err("outofmem");
                rax_1 = 0;
            }
            else
            {
                int32_t var_24_1 = 0;
                while (var_24_1 < arg5)
                {
                    char* var_20_1 = (arg1 + (arg2 * (var_24_1 * arg4)));
                    char* var_18_1 = (rax_3 + (arg3 * (var_24_1 * arg4)));
                    if (((arg3 + (arg2 << 3)) - 0xa) <= 0x19)
                    {
                        switch ((arg3 + (arg2 << 3)))
                        {
                            case 0xa:
                            {
                                int32_t var_28_1 = (arg4 - 1);
                                while (var_28_1 >= 0)
                                {
                                    *var_18_1 = *var_20_1;
                                    var_18_1[1] = 0xff;
                                    var_28_1 = (var_28_1 - 1);
                                    var_20_1 = &var_20_1[1];
                                    var_18_1 = &var_18_1[2];
                                }
                                break;
                            }
                            case 0xb:
                            {
                                int32_t var_28_2 = (arg4 - 1);
                                while (var_28_2 >= 0)
                                {
                                    var_18_1[2] = *var_20_1;
                                    var_18_1[1] = var_18_1[2];
                                    *var_18_1 = var_18_1[1];
                                    var_28_2 = (var_28_2 - 1);
                                    var_20_1 = &var_20_1[1];
                                    var_18_1 = &var_18_1[3];
                                }
                                break;
                            }
                            case 0xc:
                            {
                                int32_t var_28_3 = (arg4 - 1);
                                while (var_28_3 >= 0)
                                {
                                    var_18_1[2] = *var_20_1;
                                    var_18_1[1] = var_18_1[2];
                                    *var_18_1 = var_18_1[1];
                                    var_18_1[3] = 0xff;
                                    var_28_3 = (var_28_3 - 1);
                                    var_20_1 = &var_20_1[1];
                                    var_18_1 = &var_18_1[4];
                                }
                                break;
                            }
                            case 0x11:
                            {
                                int32_t var_28_4 = (arg4 - 1);
                                while (var_28_4 >= 0)
                                {
                                    *var_18_1 = *var_20_1;
                                    var_28_4 = (var_28_4 - 1);
                                    var_20_1 = &var_20_1[2];
                                    var_18_1 = &var_18_1[1];
                                }
                                break;
                            }
                            case 0x13:
                            {
                                int32_t var_28_5 = (arg4 - 1);
                                while (var_28_5 >= 0)
                                {
                                    var_18_1[2] = *var_20_1;
                                    var_18_1[1] = var_18_1[2];
                                    *var_18_1 = var_18_1[1];
                                    var_28_5 = (var_28_5 - 1);
                                    var_20_1 = &var_20_1[2];
                                    var_18_1 = &var_18_1[3];
                                }
                                break;
                            }
                            case 0x14:
                            {
                                int32_t var_28_6 = (arg4 - 1);
                                while (var_28_6 >= 0)
                                {
                                    var_18_1[2] = *var_20_1;
                                    var_18_1[1] = var_18_1[2];
                                    *var_18_1 = var_18_1[1];
                                    var_18_1[3] = var_20_1[1];
                                    var_28_6 = (var_28_6 - 1);
                                    var_20_1 = &var_20_1[2];
                                    var_18_1 = &var_18_1[4];
                                }
                                break;
                            }
                            case 0x19:
                            {
                                int32_t var_28_8 = (arg4 - 1);
                                while (var_28_8 >= 0)
                                {
                                    *var_18_1 = stbi__compute_y(*var_20_1, var_20_1[1], 
var_20_1[2]);
                                    var_28_8 = (var_28_8 - 1);
                                    var_20_1 = &var_20_1[3];
                                    var_18_1 = &var_18_1[1];
                                }
                                break;
                            }
                            case 0x1a:
                            {
                                int32_t var_28_9 = (arg4 - 1);
                                while (var_28_9 >= 0)
                                {
                                    *var_18_1 = stbi__compute_y(*var_20_1, var_20_1[1], 
var_20_1[2]);
                                    var_18_1[1] = 0xff;
                                    var_28_9 = (var_28_9 - 1);
                                    var_20_1 = &var_20_1[3];
                                    var_18_1 = &var_18_1[2];
                                }
                                break;
                            }
                            case 0x1c:
                            {
                                int32_t var_28_7 = (arg4 - 1);
                                while (var_28_7 >= 0)
                                {
                                    *var_18_1 = *var_20_1;
                                    var_18_1[1] = var_20_1[1];
                                    var_18_1[2] = var_20_1[2];
                                    var_18_1[3] = 0xff;
                                    var_28_7 = (var_28_7 - 1);
                                    var_20_1 = &var_20_1[3];
                                    var_18_1 = &var_18_1[4];
                                }
                                break;
                            }
                            case 0x21:
                            {
                                int32_t var_28_10 = (arg4 - 1);
                                while (var_28_10 >= 0)
                                {
                                    *var_18_1 = stbi__compute_y(*var_20_1, var_20_1[1], 
var_20_1[2]);
                                    var_28_10 = (var_28_10 - 1);
                                    var_20_1 = &var_20_1[4];
                                    var_18_1 = &var_18_1[1];
                                }
                                break;
                            }
                            case 0x22:
                            {
                                int32_t var_28_11 = (arg4 - 1);
                                while (var_28_11 >= 0)
                                {
                                    *var_18_1 = stbi__compute_y(*var_20_1, var_20_1[1], 
var_20_1[2]);
                                    var_18_1[1] = var_20_1[3];
                                    var_28_11 = (var_28_11 - 1);
                                    var_20_1 = &var_20_1[4];
                                    var_18_1 = &var_18_1[2];
                                }
                                break;
                            }
                            case 0x23:
                            {
                                int32_t var_28_12 = (arg4 - 1);
                                while (var_28_12 >= 0)
                                {
                                    *var_18_1 = *var_20_1;
                                    var_18_1[1] = var_20_1[1];
                                    var_18_1[2] = var_20_1[2];
                                    var_28_12 = (var_28_12 - 1);
                                    var_20_1 = &var_20_1[4];
                                    var_18_1 = &var_18_1[3];
                                }
                                break;
                            }
                        }
                        if (((((((((((((arg3 + (arg2 << 3)) == 0xa || (arg3 + (arg2 << 3)) == 
0xb) || (arg3 + (arg2 << 3)) == 0xc) || (arg3 + (arg2 << 3)) == 0x11) || (arg3 + (arg2 << 3)) 
== 0x13) || (arg3 + (arg2 << 3)) == 0x14) || (arg3 + (arg2 << 3)) == 0x19) || (arg3 + (arg2 << 
3)) == 0x1a) || (arg3 + (arg2 << 3)) == 0x1c) || (arg3 + (arg2 << 3)) == 0x21) || (arg3 + 
(arg2 << 3)) == 0x22) || (arg3 + (arg2 << 3)) == 0x23))
                        {
                            var_24_1 = (var_24_1 + 1);
                            continue;
                        }
                    }
                    __assert_fail(&data_221c7, "stb_image.h", 0x6fc, "unsigned char* 
stbi__convert_for…");
                    /* no return */
                }
                free(arg1);
                rax_1 = rax_3;
            }
        }
    }
    return rax_1;
}

uint64_t stbi__compute_y_16(int32_t arg1, int32_t arg2, int32_t arg3)
{
    return (((arg3 * 0x1d) + ((arg1 * 0x4d) + (arg2 * 0x96))) >> 8);
}

int64_t stbi__convert_format16(int64_t arg1, int32_t arg2, int32_t arg3, 
    int32_t arg4, int32_t arg5)
{
    int64_t rax_1;
    if (arg3 == arg2)
    {
        rax_1 = arg1;
    }
    else
    {
        if ((arg3 <= 0 || (arg3 > 0 && arg3 > 4)))
        {
            __assert_fail("req_comp >= 1 && req_comp <= 4", "stb_image.h", 0x718, 
"stbi__uint16* stbi__convert_form…");
            /* no return */
        }
        if ((arg3 > 0 && arg3 <= 4))
        {
            int32_t rax_4 = ((arg3 * arg4) * arg5);
            int64_t rax_7 = stbi__malloc((rax_4 + rax_4));
            if (rax_7 == 0)
            {
                free(arg1);
                stbi__err("outofmem");
                rax_1 = 0;
            }
            else
            {
                int32_t var_24_1 = 0;
                while (var_24_1 < arg5)
                {
                    uint64_t rax_13 = (arg2 * (var_24_1 * arg4));
                    int16_t* var_20_1 = (arg1 + (rax_13 + rax_13));
                    uint64_t rax_20 = (arg3 * (var_24_1 * arg4));
                    int16_t* var_18_1 = (rax_7 + (rax_20 + rax_20));
                    if (((arg3 + (arg2 << 3)) - 0xa) <= 0x19)
                    {
                        switch ((arg3 + (arg2 << 3)))
                        {
                            case 0xa:
                            {
                                int32_t var_28_1 = (arg4 - 1);
                                while (var_28_1 >= 0)
                                {
                                    *var_18_1 = *var_20_1;
                                    var_18_1[1] = 0xffff;
                                    var_28_1 = (var_28_1 - 1);
                                    var_20_1 = &var_20_1[1];
                                    var_18_1 = &var_18_1[2];
                                }
                                break;
                            }
                            case 0xb:
                            {
                                int32_t var_28_2 = (arg4 - 1);
                                while (var_28_2 >= 0)
                                {
                                    var_18_1[2] = *var_20_1;
                                    var_18_1[1] = var_18_1[2];
                                    *var_18_1 = var_18_1[1];
                                    var_28_2 = (var_28_2 - 1);
                                    var_20_1 = &var_20_1[1];
                                    var_18_1 = &var_18_1[3];
                                }
                                break;
                            }
                            case 0xc:
                            {
                                int32_t var_28_3 = (arg4 - 1);
                                while (var_28_3 >= 0)
                                {
                                    var_18_1[2] = *var_20_1;
                                    var_18_1[1] = var_18_1[2];
                                    *var_18_1 = var_18_1[1];
                                    var_18_1[3] = 0xffff;
                                    var_28_3 = (var_28_3 - 1);
                                    var_20_1 = &var_20_1[1];
                                    var_18_1 = &var_18_1[4];
                                }
                                break;
                            }
                            case 0x11:
                            {
                                int32_t var_28_4 = (arg4 - 1);
                                while (var_28_4 >= 0)
                                {
                                    *var_18_1 = *var_20_1;
                                    var_28_4 = (var_28_4 - 1);
                                    var_20_1 = &var_20_1[2];
                                    var_18_1 = &var_18_1[1];
                                }
                                break;
                            }
                            case 0x13:
                            {
                                int32_t var_28_5 = (arg4 - 1);
                                while (var_28_5 >= 0)
                                {
                                    var_18_1[2] = *var_20_1;
                                    var_18_1[1] = var_18_1[2];
                                    *var_18_1 = var_18_1[1];
                                    var_28_5 = (var_28_5 - 1);
                                    var_20_1 = &var_20_1[2];
                                    var_18_1 = &var_18_1[3];
                                }
                                break;
                            }
                            case 0x14:
                            {
                                int32_t var_28_6 = (arg4 - 1);
                                while (var_28_6 >= 0)
                                {
                                    var_18_1[2] = *var_20_1;
                                    var_18_1[1] = var_18_1[2];
                                    *var_18_1 = var_18_1[1];
                                    var_18_1[3] = var_20_1[1];
                                    var_28_6 = (var_28_6 - 1);
                                    var_20_1 = &var_20_1[2];
                                    var_18_1 = &var_18_1[4];
                                }
                                break;
                            }
                            case 0x19:
                            {
                                int32_t var_28_8 = (arg4 - 1);
                                while (var_28_8 >= 0)
                                {
                                    *var_18_1 = stbi__compute_y_16(*var_20_1, var_20_1[1], 
var_20_1[2]);
                                    var_28_8 = (var_28_8 - 1);
                                    var_20_1 = &var_20_1[3];
                                    var_18_1 = &var_18_1[1];
                                }
                                break;
                            }
                            case 0x1a:
                            {
                                int32_t var_28_9 = (arg4 - 1);
                                while (var_28_9 >= 0)
                                {
                                    *var_18_1 = stbi__compute_y_16(*var_20_1, var_20_1[1], 
var_20_1[2]);
                                    var_18_1[1] = 0xffff;
                                    var_28_9 = (var_28_9 - 1);
                                    var_20_1 = &var_20_1[3];
                                    var_18_1 = &var_18_1[2];
                                }
                                break;
                            }
                            case 0x1c:
                            {
                                int32_t var_28_7 = (arg4 - 1);
                                while (var_28_7 >= 0)
                                {
                                    *var_18_1 = *var_20_1;
                                    var_18_1[1] = var_20_1[1];
                                    var_18_1[2] = var_20_1[2];
                                    var_18_1[3] = 0xffff;
                                    var_28_7 = (var_28_7 - 1);
                                    var_20_1 = &var_20_1[3];
                                    var_18_1 = &var_18_1[4];
                                }
                                break;
                            }
                            case 0x21:
                            {
                                int32_t var_28_10 = (arg4 - 1);
                                while (var_28_10 >= 0)
                                {
                                    *var_18_1 = stbi__compute_y_16(*var_20_1, var_20_1[1], 
var_20_1[2]);
                                    var_28_10 = (var_28_10 - 1);
                                    var_20_1 = &var_20_1[4];
                                    var_18_1 = &var_18_1[1];
                                }
                                break;
                            }
                            case 0x22:
                            {
                                int32_t var_28_11 = (arg4 - 1);
                                while (var_28_11 >= 0)
                                {
                                    *var_18_1 = stbi__compute_y_16(*var_20_1, var_20_1[1], 
var_20_1[2]);
                                    var_18_1[1] = var_20_1[3];
                                    var_28_11 = (var_28_11 - 1);
                                    var_20_1 = &var_20_1[4];
                                    var_18_1 = &var_18_1[2];
                                }
                                break;
                            }
                            case 0x23:
                            {
                                int32_t var_28_12 = (arg4 - 1);
                                while (var_28_12 >= 0)
                                {
                                    *var_18_1 = *var_20_1;
                                    var_18_1[1] = var_20_1[1];
                                    var_18_1[2] = var_20_1[2];
                                    var_28_12 = (var_28_12 - 1);
                                    var_20_1 = &var_20_1[4];
                                    var_18_1 = &var_18_1[3];
                                }
                                break;
                            }
                        }
                        if (((((((((((((arg3 + (arg2 << 3)) == 0xa || (arg3 + (arg2 << 3)) == 
0xb) || (arg3 + (arg2 << 3)) == 0xc) || (arg3 + (arg2 << 3)) == 0x11) || (arg3 + (arg2 << 3)) 
== 0x13) || (arg3 + (arg2 << 3)) == 0x14) || (arg3 + (arg2 << 3)) == 0x19) || (arg3 + (arg2 << 
3)) == 0x1a) || (arg3 + (arg2 << 3)) == 0x1c) || (arg3 + (arg2 << 3)) == 0x21) || (arg3 + 
(arg2 << 3)) == 0x22) || (arg3 + (arg2 << 3)) == 0x23))
                        {
                            var_24_1 = (var_24_1 + 1);
                            continue;
                        }
                    }
                    __assert_fail(&data_221c7, "stb_image.h", 0x735, "stbi__uint16* 
stbi__convert_form…");
                    /* no return */
                }
                free(arg1);
                rax_1 = rax_7;
            }
        }
    }
    return rax_1;
}

void* stbi__ldr_to_hdr(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    void* rax;
    if (arg1 == 0)
    {
        rax = nullptr;
    }
    else
    {
        void* rax_2;
        float rsi_1;
        float rdi_1;
        rax_2 = stbi__malloc_mad4(arg2, arg3, arg4, 4, 0);
        if (rax_2 == 0)
        {
            free(arg1);
            stbi__err("outofmem");
            rax = nullptr;
        }
        else
        {
            int32_t var_14_1;
            if ((arg4 & 1) == 0)
            {
                var_14_1 = (arg4 - 1);
            }
            else
            {
                var_14_1 = arg4;
            }
            for (int32_t var_1c_1 = 0; var_1c_1 < (arg2 * arg3); var_1c_1 = (var_1c_1 + 1))
            {
                for (int32_t var_18_1 = 0; var_18_1 < var_14_1; var_18_1 = (var_18_1 + 1))
                {
                    stbi__l2h_gamma;
                    *(arg1 + (var_18_1 + (var_1c_1 * arg4)));
                    float zmm0;
                    rsi_1 = std::pow(rdi_1, rsi_1);
                    *(rax_2 + ((var_18_1 + (var_1c_1 * arg4)) << 2)) = (zmm0 * 
stbi__l2h_scale);
                }
            }
            if (var_14_1 < arg4)
            {
                for (int32_t var_1c_2 = 0; var_1c_2 < (arg2 * arg3); var_1c_2 = (var_1c_2 + 
1))
                {
                    *(rax_2 + ((var_14_1 + (var_1c_2 * arg4)) << 2)) = (*(arg1 + (var_14_1 + 
(var_1c_2 * arg4))) / 255f);
                }
            }
            free(arg1);
            rax = rax_2;
        }
    }
    return rax;
}

void* stbi__hdr_to_ldr(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    void* rax;
    if (arg1 == 0)
    {
        rax = nullptr;
    }
    else
    {
        void* rax_2;
        float rsi_1;
        float rdi_1;
        rax_2 = stbi__malloc_mad3(arg2, arg3, arg4, 0);
        if (rax_2 == 0)
        {
            free(arg1);
            stbi__err("outofmem");
            rax = nullptr;
        }
        else
        {
            int32_t var_1c_1;
            if ((arg4 & 1) == 0)
            {
                var_1c_1 = (arg4 - 1);
            }
            else
            {
                var_1c_1 = arg4;
            }
            for (int32_t var_24_1 = 0; var_24_1 < (arg2 * arg3); var_24_1 = (var_24_1 + 1))
            {
                int32_t var_20_1;
                for (var_20_1 = 0; var_20_1 < var_1c_1; var_20_1 = (var_20_1 + 1))
                {
                    stbi__h2l_gamma_i;
                    (*(arg1 + ((var_20_1 + (var_24_1 * arg4)) << 2)) * stbi__h2l_scale_i);
                    float zmm0;
                    rsi_1 = std::pow(rdi_1, rsi_1);
                    float var_18_1 = (0.5f + (255f * zmm0));
                    if ((!0f <= var_18_1))
                    {
                        var_18_1 = 0f;
                    }
                    if ((!var_18_1 <= 255f))
                    {
                        var_18_1 = 255f;
                    }
                    *(rax_2 + (var_20_1 + (var_24_1 * arg4))) = (truncf(var_18_1, rax_2));
                }
                if (var_20_1 < arg4)
                {
                    float var_14_1 = (0.5f + (*(arg1 + ((var_20_1 + (var_24_1 * arg4)) << 2)) 
* 255f));
                    if ((!0f <= var_14_1))
                    {
                        var_14_1 = 0f;
                    }
                    if ((!var_14_1 <= 255f))
                    {
                        var_14_1 = 255f;
                    }
                    *(rax_2 + (var_20_1 + (var_24_1 * arg4))) = (truncf(var_14_1, rax_2));
                }
            }
            free(arg1);
            rax = rax_2;
        }
    }
    return rax;
}

int64_t stbi__build_huffman(char* arg1, void* arg2)
{
    int32_t var_1c = 0;
    int32_t var_24 = 0;
    int64_t rax_4;
    while (true)
    {
        if (var_24 > 0xf)
        {
            arg1[(var_1c + 0x500)] = 0;
            int32_t var_18_1 = 0;
            int32_t var_1c_1 = 0;
            int32_t var_20_2 = 1;
            while (true)
            {
                if (var_20_2 > 0x10)
                {
                    *((arg1 + ((var_20_2 + 0x180) << 2)) + 4) = 0xffffffff;
                    memset(arg1, 0xff, 0x200);
                    for (int32_t var_24_1 = 0; var_24_1 < var_1c_1; var_24_1 = (var_24_1 + 1))
                    {
                        uint32_t rax_37 = arg1[(var_24_1 + 0x500)];
                        if (rax_37 <= 9)
                        {
                            uint32_t rdx_28 = (*(arg1 + ((var_24_1 + 0x100) << 1)) << (9 - 
rax_37));
                            for (int32_t var_20_3 = 0; var_20_3 < (1 << (9 - rax_37)); 
var_20_3 = (var_20_3 + 1))
                            {
                                arg1[(var_20_3 + rdx_28)] = var_24_1;
                            }
                        }
                    }
                    rax_4 = 1;
                    break;
                }
                *((arg1 + ((var_20_2 + 0x190) << 2)) + 0xc) = (var_1c_1 - var_18_1);
                if (var_20_2 == arg1[(var_1c_1 + 0x500)])
                {
                    while (var_20_2 == arg1[(var_1c_1 + 0x500)])
                    {
                        int32_t rax_19 = var_18_1;
                        var_18_1 = (rax_19 + 1);
                        int32_t rax_20 = var_1c_1;
                        var_1c_1 = (rax_20 + 1);
                        *(arg1 + ((rax_20 + 0x100) << 1)) = rax_19;
                    }
                    if (((var_18_1 - 1) >> var_20_2) != 0)
                    {
                        rax_4 = stbi__err("bad code lengths");
                        break;
                    }
                }
                *((arg1 + ((var_20_2 + 0x180) << 2)) + 4) = (var_18_1 << (0x10 - var_20_2));
                var_18_1 = (var_18_1 << 1);
                var_20_2 = (var_20_2 + 1);
            }
            break;
        }
        int32_t var_20_1;
        for (var_20_1 = 0; var_20_1 < *(arg2 + (var_24 << 2)); var_20_1 = (var_20_1 + 1))
        {
            int32_t rax_2 = var_1c;
            var_1c = (rax_2 + 1);
            arg1[(rax_2 + 0x500)] = (var_24 + 1);
            if (var_1c > 0x100)
            {
                break;
            }
        }
        if (var_20_1 < *(arg2 + (var_24 << 2)))
        {
            rax_4 = stbi__err("bad size list");
            break;
        }
        var_24 = (var_24 + 1);
    }
    return rax_4;
}

void stbi__build_fast_ac(void* arg1, char* arg2)
{
    for (int32_t var_24 = 0; var_24 <= 0x1ff; var_24 = (var_24 + 1))
    {
        char rax_3 = arg2[var_24];
        int64_t rax_5 = var_24;
        *(arg1 + (rax_5 + rax_5)) = 0;
        if (rax_3 != 0xff)
        {
            uint32_t rax_10 = arg2[(rax_3 + 0x400)];
            int32_t rax_15 = (rax_10 & 0xf);
            int32_t var_10_1 = arg2[(rax_3 + 0x500)];
            if ((rax_15 != 0 && (rax_15 + var_10_1) <= 9))
            {
                int32_t var_20_1 = (((var_24 << var_10_1) & 0x1ff) >> (9 - rax_15));
                if (var_20_1 < (1 << (rax_15 - 1)))
                {
                    var_20_1 = ((var_20_1 + (0xffffffff << rax_15)) + 1);
                }
                if ((var_20_1 >= 0xffffff80 && var_20_1 <= 0x7f))
                {
                    int64_t rax_40 = var_24;
                    *(arg1 + (rax_40 + rax_40)) = (((((rax_10 >> 4) & 0xf) + (var_20_1 << 4)) 
<< 4) + (rax_15 + var_10_1));
                }
            }
        }
    }
}

int64_t* stbi__grow_buffer_unsafe(int64_t* arg1)
{
    int64_t* rax_17;
    do
    {
        uint32_t rax_6;
        if (*(arg1 + 0x482c) != 0)
        {
            rax_6 = 0;
        }
        else
        {
            rax_6 = stbi__get8(*arg1);
        }
        if (rax_6 == 0xff)
        {
            uint32_t var_10_1;
            for (var_10_1 = stbi__get8(*arg1); var_10_1 == 0xff; var_10_1 = stbi__get8(*arg1))
            {
            }
            if (var_10_1 != 0)
            {
                arg1[0x905] = var_10_1;  // {"erTMCloneTable"}
                rax_17 = arg1;
                *(rax_17 + 0x482c) = 1;
                break;
            }
        }
        arg1[0x904] = (arg1[0x904] | (rax_6 << (0x18 - *(arg1 + 0x4824))));  // 
{"terTMCloneTable"}
        *(arg1 + 0x4824) = (*(arg1 + 0x4824) + 8);
        rax_17 = *(arg1 + 0x4824);
    } while (rax_17 <= 0x18);
    return rax_17;
}

uint64_t stbi__jpeg_huff_decode(int64_t* arg1, char* arg2)
{
    if (*(arg1 + 0x4824) <= 0xf)
    {
        stbi__grow_buffer_unsafe(arg1);
    }
    uint32_t rax_9 = arg2[(arg1[0x904] >> 0x17)];  // {"terTMCloneTable"}
    uint64_t rax_16;
    if (rax_9 > 0xfe)
    {
        int32_t var_18_1 = 0xa;
        while ((arg1[0x904] >> 0x10) >= *((arg2 + ((var_18_1 + 0x180) << 2)) + 4))  // 
{"terTMCloneTable"}
        {
            var_18_1 = (var_18_1 + 1);
        }
        if (var_18_1 == 0x11)
        {
            *(arg1 + 0x4824) = (*(arg1 + 0x4824) - 0x10);
            rax_16 = 0xffffffff;
        }
        else if (var_18_1 > *(arg1 + 0x4824))
        {
            rax_16 = 0xffffffff;
        }
        else
        {
            int32_t rax_44 = (*((arg2 + ((var_18_1 + 0x190) << 2)) + 0xc) + ((arg1[0x904] >> 
(0x20 - var_18_1)) & *((var_18_1 << 2) + &stbi__bmask)));  // {"terTMCloneTable"}
            if ((rax_44 < 0 || (rax_44 >= 0 && rax_44 > 0xff)))
            {
                rax_16 = 0xffffffff;
            }
            if ((rax_44 >= 0 && rax_44 <= 0xff))
            {
                if (((arg1[0x904] >> (0x20 - arg2[(rax_44 + 0x500)])) & *((arg2[(rax_44 + 
0x500)] << 2) + &stbi__bmask)) != *(arg2 + ((rax_44 + 0x100) << 1)))  // {"terTMCloneTable"}
                {
                    __assert_fail("(((j->code_buffer) >> (32 - h->s…", "stb_image.h", 0x85a, 
"int stbi__jpeg_huff_decode(stbi_…");
                    /* no return */
                }
                *(arg1 + 0x4824) = (*(arg1 + 0x4824) - var_18_1);
                arg1[0x904] = (arg1[0x904] << var_18_1);  // {"terTMCloneTable"}
                rax_16 = arg2[(rax_44 + 0x400)];
            }
        }
    }
    else
    {
        uint32_t rax_13 = arg2[(rax_9 + 0x500)];
        if (rax_13 <= *(arg1 + 0x4824))
        {
            arg1[0x904] = (arg1[0x904] << rax_13);  // {"terTMCloneTable"}
            *(arg1 + 0x4824) = (*(arg1 + 0x4824) - rax_13);
            rax_16 = arg2[(rax_9 + 0x400)];
        }
        else
        {
            rax_16 = 0xffffffff;
        }
    }
    return rax_16;
}

uint64_t stbi__extend_receive(int64_t* arg1, int32_t arg2)
{
    if (arg2 > *(arg1 + 0x4824))
    {
        stbi__grow_buffer_unsafe(arg1);
    }
    uint64_t rax_5;
    if (arg2 <= *(arg1 + 0x4824))
    {
        uint32_t rax_8 = (arg1[0x904] >> 0x1f);  // {"terTMCloneTable"}
        int32_t rdx_2 = (ROLD(arg1[0x904], arg2));  // {"terTMCloneTable"}
        arg1[0x904] = ((!*((arg2 << 2) + &stbi__bmask)) & rdx_2);  // {"terTMCloneTable"}
        int32_t var_c_2 = (rdx_2 & *((arg2 << 2) + &stbi__bmask));
        *(arg1 + 0x4824) = (*(arg1 + 0x4824) - arg2);
        rax_5 = (var_c_2 + (*((arg2 << 2) + &stbi__jbias) & (rax_8 - 1)));
    }
    else
    {
        rax_5 = 0;
    }
    return rax_5;
}

uint64_t stbi__jpeg_get_bits(int64_t* arg1, int32_t arg2)
{
    if (arg2 > *(arg1 + 0x4824))
    {
        stbi__grow_buffer_unsafe(arg1);
    }
    uint64_t rax_5;
    if (arg2 <= *(arg1 + 0x4824))
    {
        int32_t rdx_2 = (ROLD(arg1[0x904], arg2));  // {"terTMCloneTable"}
        arg1[0x904] = ((!*((arg2 << 2) + &stbi__bmask)) & rdx_2);  // {"terTMCloneTable"}
        int32_t var_c_2 = (rdx_2 & *((arg2 << 2) + &stbi__bmask));
        *(arg1 + 0x4824) = (*(arg1 + 0x4824) - arg2);
        rax_5 = var_c_2;
    }
    else
    {
        rax_5 = 0;
    }
    return rax_5;
}

uint64_t stbi__jpeg_get_bit(int64_t* arg1)
{
    if (*(arg1 + 0x4824) <= 0)
    {
        stbi__grow_buffer_unsafe(arg1);
    }
    uint64_t rax_5;
    if (*(arg1 + 0x4824) > 0)
    {
        int32_t rax_7 = arg1[0x904];  // {"terTMCloneTable"}
        int32_t rax_9 = arg1[0x904];  // {"terTMCloneTable"}
        arg1[0x904] = (rax_9 + rax_9);  // {"terTMCloneTable"}
        *(arg1 + 0x4824) = (*(arg1 + 0x4824) - 1);
        rax_5 = (rax_7 & 0x80000000);
    }
    else
    {
        rax_5 = 0;
    }
    return rax_5;
}

int64_t stbi__jpeg_decode_block(int64_t* arg1, int16_t* arg2, char* arg3, 
    char* arg4, void* arg5, int32_t arg6, int16_t* arg7)
{
    if (*(arg1 + 0x4824) <= 0xf)
    {
        stbi__grow_buffer_unsafe(arg1);
    }
    int32_t rax_4 = stbi__jpeg_huff_decode(arg1, arg3);
    int64_t rax_5;
    if ((rax_4 < 0 || (rax_4 >= 0 && rax_4 > 0xf)))
    {
        rax_5 = stbi__err("bad huffman code");
    }
    if ((rax_4 >= 0 && rax_4 <= 0xf))
    {
        memset(arg2, 0, 0x80);
        int32_t rax_8;
        if (rax_4 == 0)
        {
            rax_8 = 0;
        }
        else
        {
            rax_8 = stbi__extend_receive(arg1, rax_4);
        }
        int64_t rdx_2 = arg6;
        int32_t rax_17;
        rax_17 = stbi__addints_valid(arg1[((((rdx_2 + rdx_2) + rdx_2) * 4) + 0x8d7)], rax_8) 
== 0;
        if (rax_17 != 0)
        {
            rax_5 = stbi__err("bad delta");
        }
        else
        {
            int64_t rdx_4 = arg6;
            int32_t rax_26 = (rax_8 + arg1[((((rdx_4 + rdx_4) + rdx_4) * 4) + 0x8d7)]);
            int64_t rdx_6 = arg6;
            arg1[((((rdx_6 + rdx_6) + rdx_6) * 4) + 0x8d7)] = rax_26;
            int32_t rax_38;
            rax_38 = stbi__mul2shorts_valid(rax_26, *arg7) == 0;
            if (rax_38 != 0)
            {
                rax_5 = stbi__err("can't merge dc and ac");
            }
            else
            {
                *arg2 = (*arg7 * rax_26);
                int32_t var_2c_1 = 1;
                while (true)
                {
                    if (*(arg1 + 0x4824) <= 0xf)
                    {
                        stbi__grow_buffer_unsafe(arg1);
                    }
                    int64_t rax_50 = (arg1[0x904] >> 0x17);  // {"terTMCloneTable"}
                    int32_t rax_54 = *(arg5 + (rax_50 + rax_50));
                    if (rax_54 != 0)
                    {
                        int32_t var_2c_2 = (var_2c_1 + ((rax_54 >> 4) & 0xf));
                        int32_t rax_59 = (rax_54 & 0xf);
                        if (rax_59 > *(arg1 + 0x4824))
                        {
                            rax_5 = stbi__err("bad huffman code");
                            break;
                        }
                        arg1[0x904] = (arg1[0x904] << rax_59);  // {"terTMCloneTable"}
                        *(arg1 + 0x4824) = (*(arg1 + 0x4824) - rax_59);
                        var_2c_1 = (var_2c_2 + 1);
                        uint32_t rax_72 = *(var_2c_2 + &stbi__jpeg_dezigzag);
                        uint64_t rax_75 = rax_72;
                        uint64_t rax_79 = rax_72;
                        *(arg2 + (rax_79 + rax_79)) = ((rax_54 >> 8) * *(arg7 + (rax_75 + 
rax_75)));
                    }
                    else
                    {
                        int32_t rax_83 = stbi__jpeg_huff_decode(arg1, arg4);
                        if (rax_83 < 0)
                        {
                            rax_5 = stbi__err("bad huffman code");
                            break;
                        }
                        int32_t rax_85 = (rax_83 & 0xf);
                        if (rax_85 != 0)
                        {
                            int32_t var_2c_3 = (var_2c_1 + (rax_83 >> 4));
                            var_2c_1 = (var_2c_3 + 1);
                            uint32_t rax_92 = *(var_2c_3 + &stbi__jpeg_dezigzag);
                            uint64_t rax_95 = rax_92;
                            uint64_t rax_99 = rax_92;
                            *(arg2 + (rax_99 + rax_99)) = (stbi__extend_receive(arg1, rax_85) 
* *(arg7 + (rax_95 + rax_95)));
                        }
                        else
                        {
                            if (rax_83 != 0xf0)
                            {
                            label_6096:
                                rax_5 = 1;
                                break;
                            }
                            var_2c_1 = (var_2c_1 + 0x10);
                        }
                    }
                    if (var_2c_1 > 0x3f)
                    {
                        goto label_6096;
                    }
                }
            }
        }
    }
    return rax_5;
}

int64_t stbi__jpeg_decode_block_prog_dc(int64_t* arg1, int16_t* arg2, 
    char* arg3, int32_t arg4)
{
    int64_t rax_2;
    if (arg1[0x907] != 0)  // {"TMCloneTable"}
    {
        rax_2 = stbi__err("can't merge dc and ac");
    }
    else
    {
        if (*(arg1 + 0x4824) <= 0xf)
        {
            stbi__grow_buffer_unsafe(arg1);
        }
        int32_t rax_10;
        int32_t rax_21;
        int32_t rax_43;
        if (*(arg1 + 0x483c) == 0)
        {
            memset(arg2, 0, 0x80);
            rax_10 = stbi__jpeg_huff_decode(arg1, arg3);
            if ((rax_10 < 0 || (rax_10 >= 0 && rax_10 > 0xf)))
            {
                rax_2 = stbi__err("can't merge dc and ac");
            }
            if ((rax_10 <= 0xf && rax_10 >= 0))
            {
                int32_t rax_12;
                if (rax_10 == 0)
                {
                    rax_12 = 0;
                }
                else
                {
                    rax_12 = stbi__extend_receive(arg1, rax_10);
                }
                int64_t rdx_2 = arg4;
                rax_21 = stbi__addints_valid(arg1[((((rdx_2 + rdx_2) + rdx_2) * 4) + 0x8d7)], 
rax_12) == 0;
                if (rax_21 == 0)
                {
                    int64_t rdx_4 = arg4;
                    int32_t rax_30 = (rax_12 + arg1[((((rdx_4 + rdx_4) + rdx_4) * 4) + 
0x8d7)]);
                    int64_t rdx_6 = arg4;
                    arg1[((((rdx_6 + rdx_6) + rdx_6) * 4) + 0x8d7)] = rax_30;
                    rax_43 = stbi__mul2shorts_valid(rax_30, (1 << arg1[0x908])) == 0;  // 
{"MCloneTable"}
                    if (rax_43 == 0)
                    {
                        *arg2 = (rax_30 << arg1[0x908]);  // {"MCloneTable"}
                    }
                    else
                    {
                        rax_2 = stbi__err("can't merge dc and ac");
                    }
                }
                else
                {
                    rax_2 = stbi__err("bad delta");
                }
            }
        }
        else
        {
            int32_t rax_49;
            rax_49 = stbi__jpeg_get_bit(arg1) != 0;
            if (rax_49 != 0)
            {
                *arg2 = ((1 << arg1[0x908]) + *arg2);  // {"MCloneTable"}
            }
        }
        if ((((((*(arg1 + 0x483c) == 0 && rax_10 >= 0) && rax_10 <= 0xf) && rax_21 == 0) && 
rax_43 == 0) || *(arg1 + 0x483c) != 0))
        {
            rax_2 = 1;
        }
    }
    return rax_2;
}

int64_t stbi__jpeg_decode_block_prog_ac(int64_t* arg1, void* arg2, char* arg3, 
    void* arg4)
{
    int64_t rax_2;
    if (*(arg1 + 0x4834) == 0)
    {
        rax_2 = stbi__err("can't merge dc and ac");
    }
    else
    {
        if (*(arg1 + 0x483c) == 0)
        {
            char rax_6 = arg1[0x908];  // {"MCloneTable"}
            if (*(arg1 + 0x4844) != 0)
            {
                *(arg1 + 0x4844) = (*(arg1 + 0x4844) - 1);
                rax_2 = 1;
            }
            else
            {
                int32_t var_40_1 = *(arg1 + 0x4834);
                do
                {
                    if (*(arg1 + 0x4824) <= 0xf)
                    {
                        stbi__grow_buffer_unsafe(arg1);
                    }
                    int64_t rax_21 = (arg1[0x904] >> 0x17);  // {"terTMCloneTable"}
                    int32_t rax_25 = *(arg4 + (rax_21 + rax_21));
                    if (rax_25 == 0)
                    {
                        int32_t rax_51 = stbi__jpeg_huff_decode(arg1, arg3);
                        if (rax_51 < 0)
                        {
                            return stbi__err("bad huffman code");
                        }
                        int32_t rax_53 = (rax_51 & 0xf);
                        int32_t rax_55 = (rax_51 >> 4);
                        if (rax_53 != 0)
                        {
                            int32_t var_40_3 = (var_40_1 + rax_55);
                            var_40_1 = (var_40_3 + 1);
                            uint64_t rax_72 = *(var_40_3 + &stbi__jpeg_dezigzag);
                            *(arg2 + (rax_72 + rax_72)) = (stbi__extend_receive(arg1, rax_53) 
<< rax_6);
                        }
                        else
                        {
                            if (rax_55 <= 0xe)
                            {
                                *(arg1 + 0x4844) = (1 << rax_55);
                                if (rax_55 != 0)
                                {
                                    int32_t rax_59 = stbi__jpeg_get_bits(arg1, rax_55);
                                    *(arg1 + 0x4844) = (*(arg1 + 0x4844) + rax_59);
                                }
                                *(arg1 + 0x4844) = (*(arg1 + 0x4844) - 1);
                                break;
                            }
                            var_40_1 = (var_40_1 + 0x10);
                        }
                    }
                    else
                    {
                        int32_t var_40_2 = (var_40_1 + ((rax_25 >> 4) & 0xf));
                        int32_t rax_30 = (rax_25 & 0xf);
                        if (rax_30 > *(arg1 + 0x4824))
                        {
                            return stbi__err("bad huffman code");
                        }
                        arg1[0x904] = (arg1[0x904] << rax_30);  // {"terTMCloneTable"}
                        *(arg1 + 0x4824) = (*(arg1 + 0x4824) - rax_30);
                        var_40_1 = (var_40_2 + 1);
                        uint64_t rax_47 = *(var_40_2 + &stbi__jpeg_dezigzag);
                        *(arg2 + (rax_47 + rax_47)) = ((rax_25 >> 8) << rax_6);
                    }
                } while (var_40_1 <= arg1[0x907]);  // {"TMCloneTable"}
            }
        }
        else
        {
            int16_t rdx_23 = (1 << arg1[0x908]);  // {"MCloneTable"}
            if (*(arg1 + 0x4844) == 0)
            {
                int32_t var_40_5 = *(arg1 + 0x4834);
                do
                {
                    int32_t rax_115 = stbi__jpeg_huff_decode(arg1, arg3);
                    if (rax_115 < 0)
                    {
                        return stbi__err("bad huffman code");
                    }
                    int32_t var_38_1 = (rax_115 & 0xf);
                    int32_t var_3c_1 = (rax_115 >> 4);
                    if (var_38_1 != 0)
                    {
                        if (var_38_1 != 1)
                        {
                            return stbi__err("bad huffman code");
                        }
                        int32_t rax_127;
                        rax_127 = stbi__jpeg_get_bit(arg1) != 0;
                        if (rax_127 == 0)
                        {
                            var_38_1 = (-rdx_23);
                        }
                        else
                        {
                            var_38_1 = rdx_23;
                        }
                    }
                    else if (var_3c_1 <= 0xe)
                    {
                        *(arg1 + 0x4844) = ((1 << var_3c_1) - 1);
                        if (var_3c_1 != 0)
                        {
                            int32_t rax_124 = stbi__jpeg_get_bits(arg1, var_3c_1);
                            *(arg1 + 0x4844) = (*(arg1 + 0x4844) + rax_124);
                        }
                        var_3c_1 = 0x40;
                    }
                    while (var_40_5 <= arg1[0x907])  // {"TMCloneTable"}
                    {
                        int32_t rax_131 = var_40_5;
                        var_40_5 = (rax_131 + 1);
                        uint64_t rax_134 = *(rax_131 + &stbi__jpeg_dezigzag);
                        void* rax_136 = ((rax_134 + rax_134) + arg2);
                        if (*rax_136 != 0)
                        {
                            int32_t rax_140;
                            rax_140 = stbi__jpeg_get_bit(arg1) != 0;
                            if ((rax_140 != 0 && (*rax_136 & rdx_23) == 0))
                            {
                                if (*rax_136 <= 0)
                                {
                                    *rax_136 = (*rax_136 - rdx_23);
                                }
                                else
                                {
                                    *rax_136 = (rdx_23 + *rax_136);
                                }
                            }
                        }
                        else
                        {
                            if (var_3c_1 == 0)
                            {
                                *rax_136 = var_38_1;
                                break;
                            }
                            var_3c_1 = (var_3c_1 - 1);
                        }
                    }
                } while (var_40_5 <= arg1[0x907]);  // {"TMCloneTable"}
            }
            else
            {
                *(arg1 + 0x4844) = (*(arg1 + 0x4844) - 1);
                for (int32_t var_40_4 = *(arg1 + 0x4834); var_40_4 <= arg1[0x907]; var_40_4 = 
(var_40_4 + 1))  // {"TMCloneTable"}
                {
                    uint64_t rax_90 = *(var_40_4 + &stbi__jpeg_dezigzag);
                    void* rax_92 = (arg2 + (rax_90 + rax_90));
                    if (*rax_92 != 0)
                    {
                        int32_t rax_96;
                        rax_96 = stbi__jpeg_get_bit(arg1) != 0;
                        if ((rax_96 != 0 && (*rax_92 & rdx_23) == 0))
                        {
                            if (*rax_92 <= 0)
                            {
                                *rax_92 = (*rax_92 - rdx_23);
                            }
                            else
                            {
                                *rax_92 = (rdx_23 + *rax_92);
                            }
                        }
                    }
                }
            }
        }
        if ((*(arg1 + 0x483c) != 0 || (*(arg1 + 0x483c) == 0 && *(arg1 + 0x4844) == 0)))
        {
            rax_2 = 1;
        }
    }
    return rax_2;
}

uint64_t stbi__clamp(int32_t arg1)
{
    uint64_t rax_1;
    if ((arg1 > 0xff && arg1 < 0))
    {
        rax_1 = 0;
    }
    if ((arg1 <= 0xff || ((arg1 > 0xff && arg1 >= 0) && arg1 <= 0xff)))
    {
        rax_1 = arg1;
    }
    if (((arg1 > 0xff && arg1 >= 0) && arg1 > 0xff))
    {
        rax_1 = 0xffffffff;
    }
    return rax_1;
}

int64_t stbi__idct_block(char* arg1, int32_t arg2, int16_t* arg3)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_128;
    void* var_140 = &var_128;
    int16_t* var_130 = arg3;
    int32_t var_1b0 = 0;
    while (var_1b0 <= 7)
    {
        if (var_130[8] != 0)
        {
        label_6a05:
            int32_t rax_42 = var_130[0x10];
            int32_t rax_46 = var_130[0x30];
            int32_t rax_49 = ((rax_46 + rax_42) * 0x8a9);
            int32_t rax_52 = (rax_49 + (rax_46 * 0xffffe271));
            int32_t rax_55 = (rax_49 + (rax_42 * 0xc3f));
            int32_t rax_58 = *var_130;
            int32_t rax_62 = var_130[0x20];
            int32_t rax_65 = ((rax_62 + rax_58) << 0xc);
            int32_t rax_68 = ((rax_58 - rax_62) << 0xc);
            int32_t rax_80 = var_130[0x38];
            int32_t rax_84 = var_130[0x28];
            int32_t rax_88 = var_130[0x18];
            int32_t rax_92 = var_130[8];
            int32_t rax_94 = (rax_88 + rax_80);
            int32_t rax_96 = (rax_92 + rax_84);
            int32_t rax_103 = ((rax_96 + rax_94) * 0x12d0);
            int32_t rax_114 = (rax_103 + ((rax_92 + rax_80) * 0xfffff19b));
            int32_t rax_117 = (rax_103 + ((rax_88 + rax_84) * 0xffffd6ff));
            int32_t rax_119 = (rax_94 * 0xffffe09e);
            int32_t rax_121 = (rax_96 * 0xfffff9c3);
            int32_t var_164_4 = ((rax_92 * 0x1805) + (rax_121 + rax_114));
            int32_t var_168_4 = ((rax_88 * 0x312a) + (rax_119 + rax_117));
            int32_t var_15c_4 = ((rax_84 * 0x20da) + (rax_121 + rax_117));
            int32_t var_160_4 = ((rax_80 * 0x4c7) + (rax_119 + rax_114));
            *var_140 = ((var_164_4 + ((rax_55 + rax_65) + 0x200)) >> 0xa);
            *(var_140 + 0xe0) = ((((rax_55 + rax_65) + 0x200) - var_164_4) >> 0xa);
            *(var_140 + 0x20) = ((((rax_52 + rax_68) + 0x200) + var_168_4) >> 0xa);
            *(var_140 + 0xc0) = ((((rax_52 + rax_68) + 0x200) - var_168_4) >> 0xa);
            *(var_140 + 0x40) = ((((rax_68 - rax_52) + 0x200) + var_15c_4) >> 0xa);
            *(var_140 + 0xa0) = ((((rax_68 - rax_52) + 0x200) - var_15c_4) >> 0xa);
            *(var_140 + 0x60) = ((((rax_65 - rax_55) + 0x200) + var_160_4) >> 0xa);
            *(var_140 - -0x80) = ((((rax_65 - rax_55) + 0x200) - var_160_4) >> 0xa);
        }
        else
        {
            if (var_130[0x10] != 0)
            {
                goto label_6a05;
            }
            if (var_130[0x18] != 0)
            {
                goto label_6a05;
            }
            if (var_130[0x20] != 0)
            {
                goto label_6a05;
            }
            if (var_130[0x28] != 0)
            {
                goto label_6a05;
            }
            if (var_130[0x30] != 0)
            {
                goto label_6a05;
            }
            if (var_130[0x38] != 0)
            {
                goto label_6a05;
            }
            *(var_140 + 0xe0) = (*var_130 << 2);
            *(var_140 + 0xc0) = *(var_140 + 0xe0);
            *(var_140 + 0xa0) = *(var_140 + 0xc0);
            *(var_140 - -0x80) = *(var_140 + 0xa0);
            *(var_140 + 0x60) = *(var_140 - -0x80);
            *(var_140 + 0x40) = *(var_140 + 0x60);
            *(var_140 + 0x20) = *(var_140 + 0x40);
            *var_140 = *(var_140 + 0x20);
        }
        var_1b0 = (var_1b0 + 1);
        var_130 = &var_130[1];
        var_140 = (var_140 + 4);
    }
    int32_t var_1b0_1 = 0;
    void* var_140_1 = &var_128;
    char* var_138 = arg1;
    while (var_1b0_1 <= 7)
    {
        int32_t rax_161 = *(var_140_1 + 8);
        int32_t rax_163 = *(var_140_1 + 0x18);
        int32_t rax_166 = ((rax_163 + rax_161) * 0x8a9);
        int32_t rax_169 = (rax_166 + (rax_163 * 0xffffe271));
        int32_t rax_172 = (rax_166 + (rax_161 * 0xc3f));
        int32_t rax_174 = *var_140_1;
        int32_t rax_176 = *(var_140_1 + 0x10);
        int32_t rax_179 = ((rax_176 + rax_174) << 0xc);
        int32_t rax_182 = ((rax_174 - rax_176) << 0xc);
        int32_t rax_192 = *(var_140_1 + 0x1c);
        int32_t rax_194 = *(var_140_1 + 0x14);
        int32_t rax_196 = *(var_140_1 + 0xc);
        int32_t rax_198 = *(var_140_1 + 4);
        int32_t rax_200 = (rax_196 + rax_192);
        int32_t rax_202 = (rax_198 + rax_194);
        int32_t rax_209 = ((rax_202 + rax_200) * 0x12d0);
        int32_t rax_220 = (rax_209 + ((rax_198 + rax_192) * 0xfffff19b));
        int32_t rax_223 = (rax_209 + ((rax_196 + rax_194) * 0xffffd6ff));
        int32_t rax_225 = (rax_200 * 0xffffe09e);
        int32_t rax_227 = (rax_202 * 0xfffff9c3);
        int32_t var_19c_4 = ((rax_198 * 0x1805) + (rax_227 + rax_220));
        int32_t var_1a0_4 = ((rax_196 * 0x312a) + (rax_225 + rax_223));
        int32_t var_194_4 = ((rax_194 * 0x20da) + (rax_227 + rax_223));
        int32_t var_198_4 = ((rax_192 * 0x4c7) + (rax_225 + rax_220));
        *var_138 = stbi__clamp(((var_19c_4 + ((rax_172 + rax_179) + 0x1010000)) >> 0x11));
        var_138[7] = stbi__clamp(((((rax_172 + rax_179) + 0x1010000) - var_19c_4) >> 0x11));
        var_138[1] = stbi__clamp(((var_1a0_4 + ((rax_169 + rax_182) + 0x1010000)) >> 0x11));
        var_138[6] = stbi__clamp(((((rax_169 + rax_182) + 0x1010000) - var_1a0_4) >> 0x11));
        var_138[2] = stbi__clamp(((var_194_4 + ((rax_182 - rax_169) + 0x1010000)) >> 0x11));
        var_138[5] = stbi__clamp(((((rax_182 - rax_169) + 0x1010000) - var_194_4) >> 0x11));
        var_138[3] = stbi__clamp(((var_198_4 + ((rax_179 - rax_172) + 0x1010000)) >> 0x11));
        var_138[4] = stbi__clamp(((((rax_179 - rax_172) + 0x1010000) - var_198_4) >> 0x11));
        var_1b0_1 = (var_1b0_1 + 1);
        var_140_1 = (var_140_1 + 0x20);
        var_138 = &var_138[arg2];
    }
    if (rax == *(fsbase + 0x28))
    {
        return (rax - *(fsbase + 0x28));
    }
    __stack_chk_fail();
    /* no return */
}

void* stbi__idct_simd(int64_t* arg1, int32_t arg2, int32_t (* arg3)[0x4])
{
    int32_t temp0[0x4] = _mm_insert_epi16(0x8a9, 0xeb1a, 1);
    int64_t zmm4 = _mm_insert_epi16(0x8a9, 0xeb1a, 1)[0];
    int32_t temp0_2[0x4] = _mm_insert_epi16(0x8a9, 0xeb1a, 1);
    int64_t zmm3 = _mm_insert_epi16(0x8a9, 0xeb1a, 1)[0];
    int32_t temp0_6[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0, zmm4), 
_mm_unpacklo_epi32(temp0_2, zmm3)[0]);
    int32_t temp0_7[0x4] = _mm_insert_epi16(0x14e8, 0x8a9, 1);
    zmm4 = _mm_insert_epi16(0x14e8, 0x8a9, 1)[0];
    int32_t temp0_9[0x4] = _mm_insert_epi16(0x14e8, 0x8a9, 1);
    zmm3 = _mm_insert_epi16(0x14e8, 0x8a9, 1)[0];
    int32_t temp0_13[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_7, zmm4), 
_mm_unpacklo_epi32(temp0_9, zmm3)[0]);
    int32_t temp0_14[0x4] = _mm_insert_epi16(0x46b, 0x12d0, 1);
    zmm4 = _mm_insert_epi16(0x46b, 0x12d0, 1)[0];
    int32_t temp0_16[0x4] = _mm_insert_epi16(0x46b, 0x12d0, 1);
    zmm3 = _mm_insert_epi16(0x46b, 0x12d0, 1)[0];
    int32_t temp0_20[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_14, zmm4), 
_mm_unpacklo_epi32(temp0_16, zmm3)[0]);
    int32_t temp0_21[0x4] = _mm_insert_epi16(0x12d0, 0xe9cf, 1);
    zmm4 = _mm_insert_epi16(0x12d0, 0xe9cf, 1)[0];
    int32_t temp0_23[0x4] = _mm_insert_epi16(0x12d0, 0xe9cf, 1);
    zmm3 = _mm_insert_epi16(0x12d0, 0xe9cf, 1)[0];
    int32_t temp0_27[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_21, zmm4), 
_mm_unpacklo_epi32(temp0_23, zmm3)[0]);
    int32_t temp0_28[0x4] = _mm_insert_epi16(0xe565, 0xe09e, 1);
    zmm4 = _mm_insert_epi16(0xe565, 0xe09e, 1)[0];
    int32_t temp0_30[0x4] = _mm_insert_epi16(0xe565, 0xe09e, 1);
    zmm3 = _mm_insert_epi16(0xe565, 0xe09e, 1)[0];
    int32_t temp0_34[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_28, zmm4), 
_mm_unpacklo_epi32(temp0_30, zmm3)[0]);
    int32_t temp0_35[0x4] = _mm_insert_epi16(0xe09e, 0x11c8, 1);
    zmm4 = _mm_insert_epi16(0xe09e, 0x11c8, 1)[0];
    int32_t temp0_37[0x4] = _mm_insert_epi16(0xe09e, 0x11c8, 1);
    zmm3 = _mm_insert_epi16(0xe09e, 0x11c8, 1)[0];
    int32_t temp0_41[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_35, zmm4), 
_mm_unpacklo_epi32(temp0_37, zmm3)[0]);
    int32_t temp0_42[0x4] = _mm_insert_epi16(0x1a9d, 0xf9c3, 1);
    zmm4 = _mm_insert_epi16(0x1a9d, 0xf9c3, 1)[0];
    int32_t temp0_44[0x4] = _mm_insert_epi16(0x1a9d, 0xf9c3, 1);
    zmm3 = _mm_insert_epi16(0x1a9d, 0xf9c3, 1)[0];
    int32_t temp0_48[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_42, zmm4), 
_mm_unpacklo_epi32(temp0_44, zmm3)[0]);
    int16_t var_28c0;
    __builtin_memcpy(var_28c0, 
"\xc3\xf9\xc8\x11\xc3\xf9\xc8\x11\xc3\xf9\xc8\x11\xc3\xf9\xc8\x11\xc8\x11\xc3\xf9\xc8\x11\xc3\xf9\xc8\x11\xc3\xf9\xc8\x11\xc3\xf9\x9d\x1a\xc3\xf9\x9d\x1a\xc3\xf9\x9d\x1a\xc3\xf9\x9d\x1a\xc3\xf9\xc3\xf9\x9d\x1a\xc3\xf9\x9d\x1a\xc3\xf9\x9d\x1a\xc3\xf9\x9d\x1a\x9e\xe0\xc8\x11\x9e\xe0\xc8\x11\x9e\xe0\xc8\x11\x9e\xe0\xc8\x11\xc8\x11\x9e\xe0\xc8\x11\x9e\xe0\xc8\x11\x9e\xe0\xc8\x11\x9e\xe0e\xe5\x9e\xe0e\xe5\x9e\xe0e\xe5\x9e\xe0e\xe5\x9e\xe0\x9e\xe0e\xe5\x9e\xe0e\xe5\x9e\xe0e\xe5\x9e\xe0e\xe5\xd0\x12\xcf\xe9\xd0\x12\xcf\xe9\xd0\x12\xcf\xe9\xd0\x12\xcf\xe9\xcf\xe9\xd0\x12\xcf\xe9\xd0\x12\xcf\xe9\xd0\x12\xcf\xe9\xd0\x12k\x04\xd0\x12k\x04\xd0\x12k\x04\xd0\x12k\x04\xd0\x12\xd0\x12k\x04\xd0\x12k\x04\xd0\x12k\x04\xd0\x12k\x04\xe8\x14\xa9\x08\xe8\x14\xa9\x08\xe8\x14\xa9\x08\xe8\x14\xa9\x08\xa9\x08\xe8\x14\xa9\x08\xe8\x14\xa9\x08\xe8\x14\xa9\x08\xe8\x14\xa9\x08\x1a\xeb\xa9\x08\x1a\xeb\xa9\x08\x1a\xeb\xa9\x08\x1a\xeb\x1a\xeb\xa9\x08\x1a\xeb\xa9\x08\x1a\xeb\xa9\x08\x1a\xeb\xa9\x08\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x11\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\x00\x00\x01\x01\x00\x00\x01\x01\x00\x00\x01\x01\x00\x00\x01\x01\x00\x00\x01\x01\x00\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00", 
0x1c8);
    int32_t temp0_49[0x4] = _mm_insert_epi16(0xf9c3, 0x11c8, 1);
    zmm4 = _mm_insert_epi16(0xf9c3, 0x11c8, 1)[0];
    int32_t temp0_51[0x4] = _mm_insert_epi16(0xf9c3, 0x11c8, 1);
    zmm3 = _mm_insert_epi16(0xf9c3, 0x11c8, 1)[0];
    int32_t temp0_55[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_49, zmm4), 
_mm_unpacklo_epi32(temp0_51, zmm3)[0]);
    int32_t temp0_56[0x4] = _mm_unpacklo_epi32(0x200, 0x200);
    int32_t temp0_58[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(0x200, 0x200), temp0_56[0]);
    int32_t temp0_59[0x4] = _mm_unpacklo_epi32(0x1010000, 0x1010000);
    int32_t temp0_61[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(0x1010000, 0x1010000), 
temp0_59[0]);
    int32_t var_25d8[0x4] = *arg3;
    int32_t var_25c8[0x4] = arg3[1];
    int32_t var_25b8[0x4] = arg3[2];
    int32_t var_25a8[0x4] = arg3[3];
    int32_t var_2598[0x4] = arg3[4];
    int32_t var_2588[0x4] = arg3[5];
    int32_t var_2578[0x4] = arg3[6];
    int32_t var_2568[0x4] = arg3[7];
    int32_t temp0_62[0x4] = _mm_unpacklo_epi16(var_25b8, var_2578[0]);
    int32_t temp0_63[0x4] = _mm_unpackhi_epi16(var_25b8, var_2578[0]);
    int32_t var_2538[0x4] = _mm_madd_epi16(temp0_6, temp0_62);
    int32_t var_2528[0x4] = _mm_madd_epi16(temp0_6, temp0_63);
    int32_t var_2518[0x4] = _mm_madd_epi16(temp0_13, temp0_62);
    int32_t var_2508[0x4] = _mm_madd_epi16(temp0_13, temp0_63);
    int32_t var_24f8[0x4] = _mm_add_epi16(var_2598, var_25d8);
    int32_t temp0_69[0x4] = _mm_sub_epi16(var_25d8, var_2598);
    int128_t var_128 = {0};
    int32_t temp0_71[0x4] = _mm_sra_epi32(_mm_unpacklo_epi16({0}, var_24f8[0]), 4);
    int128_t var_158 = {0};
    int32_t temp0_73[0x4] = _mm_sra_epi32(_mm_unpackhi_epi16({0}, var_24f8[0]), 4);
    int128_t var_188 = {0};
    int32_t temp0_75[0x4] = _mm_sra_epi32(_mm_unpacklo_epi16({0}, temp0_69[0]), 4);
    int128_t var_1b8 = {0};
    int32_t temp0_77[0x4] = _mm_sra_epi32(_mm_unpackhi_epi16({0}, temp0_69[0]), 4);
    int32_t temp0_78[0x4] = _mm_add_epi32(var_2518, temp0_71);
    int32_t temp0_79[0x4] = _mm_add_epi32(var_2508, temp0_73);
    int32_t temp0_80[0x4] = _mm_sub_epi32(temp0_71, var_2518);
    int32_t temp0_81[0x4] = _mm_sub_epi32(temp0_73, var_2508);
    int32_t temp0_82[0x4] = _mm_add_epi32(var_2538, temp0_75);
    int32_t temp0_83[0x4] = _mm_add_epi32(var_2528, temp0_77);
    int32_t temp0_84[0x4] = _mm_sub_epi32(temp0_75, var_2538);
    int32_t temp0_85[0x4] = _mm_sub_epi32(temp0_77, var_2528);
    int32_t temp0_86[0x4] = _mm_unpacklo_epi16(var_2568, var_25a8[0]);
    int32_t temp0_87[0x4] = _mm_unpackhi_epi16(var_2568, var_25a8[0]);
    int32_t var_23f8[0x4] = _mm_madd_epi16(temp0_34, temp0_86);
    int32_t var_23e8[0x4] = _mm_madd_epi16(temp0_34, temp0_87);
    int32_t var_23d8[0x4] = _mm_madd_epi16(temp0_41, temp0_86);
    int32_t var_23c8[0x4] = _mm_madd_epi16(temp0_41, temp0_87);
    int32_t temp0_92[0x4] = _mm_unpacklo_epi16(var_2588, var_25c8[0]);
    int32_t temp0_93[0x4] = _mm_unpackhi_epi16(var_2588, var_25c8[0]);
    int32_t var_2398[0x4] = _mm_madd_epi16(temp0_48, temp0_92);
    int32_t var_2388[0x4] = _mm_madd_epi16(temp0_48, temp0_93);
    int32_t var_2378[0x4] = _mm_madd_epi16(temp0_55, temp0_92);
    int32_t var_2368[0x4] = _mm_madd_epi16(temp0_55, temp0_93);
    int32_t var_2358[0x4] = _mm_add_epi16(var_2568, var_25c8);
    int32_t var_2348[0x4] = _mm_add_epi16(var_2588, var_25a8);
    int32_t temp0_100[0x4] = _mm_unpacklo_epi16(var_2358, var_2348[0]);
    int32_t temp0_101[0x4] = _mm_unpackhi_epi16(var_2358, var_2348[0]);
    int32_t var_2318[0x4] = _mm_madd_epi16(temp0_20, temp0_100);
    int32_t var_2308[0x4] = _mm_madd_epi16(temp0_20, temp0_101);
    int32_t var_22f8[0x4] = _mm_madd_epi16(temp0_27, temp0_100);
    int32_t var_22e8[0x4] = _mm_madd_epi16(temp0_27, temp0_101);
    int32_t temp0_106[0x4] = _mm_add_epi32(var_2318, var_23f8);
    int32_t temp0_107[0x4] = _mm_add_epi32(var_2308, var_23e8);
    int32_t temp0_108[0x4] = _mm_add_epi32(var_22f8, var_2398);
    int32_t temp0_109[0x4] = _mm_add_epi32(var_22e8, var_2388);
    int32_t temp0_110[0x4] = _mm_add_epi32(var_22f8, var_23d8);
    int32_t temp0_111[0x4] = _mm_add_epi32(var_22e8, var_23c8);
    int32_t temp0_112[0x4] = _mm_add_epi32(var_2318, var_2378);
    int32_t temp0_113[0x4] = _mm_add_epi32(var_2308, var_2368);
    int32_t temp0_114[0x4] = _mm_add_epi32(temp0_58, temp0_78);
    int32_t temp0_115[0x4] = _mm_add_epi32(temp0_58, temp0_79);
    int32_t temp0_116[0x4] = _mm_add_epi32(temp0_112, temp0_114);
    int32_t temp0_117[0x4] = _mm_add_epi32(temp0_113, temp0_115);
    int32_t temp0_118[0x4] = _mm_sub_epi32(temp0_114, temp0_112);
    int32_t temp0_119[0x4] = _mm_sub_epi32(temp0_115, temp0_113);
    int32_t temp0_120[0x4] = _mm_sra_epi32(temp0_117, 0xa);
    int32_t temp0_122[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_116, 0xa), temp0_120);
    int32_t temp0_123[0x4] = _mm_sra_epi32(temp0_119, 0xa);
    int32_t temp0_125[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_118, 0xa), temp0_123);
    int32_t temp0_126[0x4] = _mm_add_epi32(temp0_58, temp0_82);
    int32_t temp0_127[0x4] = _mm_add_epi32(temp0_58, temp0_83);
    int32_t temp0_128[0x4] = _mm_add_epi32(temp0_110, temp0_126);
    int32_t temp0_129[0x4] = _mm_add_epi32(temp0_111, temp0_127);
    int32_t temp0_130[0x4] = _mm_sub_epi32(temp0_126, temp0_110);
    int32_t temp0_131[0x4] = _mm_sub_epi32(temp0_127, temp0_111);
    int32_t temp0_132[0x4] = _mm_sra_epi32(temp0_129, 0xa);
    int32_t temp0_134[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_128, 0xa), temp0_132);
    int32_t temp0_135[0x4] = _mm_sra_epi32(temp0_131, 0xa);
    int32_t temp0_137[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_130, 0xa), temp0_135);
    int32_t temp0_138[0x4] = _mm_add_epi32(temp0_58, temp0_84);
    int32_t temp0_139[0x4] = _mm_add_epi32(temp0_58, temp0_85);
    int32_t temp0_140[0x4] = _mm_add_epi32(temp0_108, temp0_138);
    int32_t temp0_141[0x4] = _mm_add_epi32(temp0_109, temp0_139);
    int32_t temp0_142[0x4] = _mm_sub_epi32(temp0_138, temp0_108);
    int32_t temp0_143[0x4] = _mm_sub_epi32(temp0_139, temp0_109);
    int32_t temp0_144[0x4] = _mm_sra_epi32(temp0_141, 0xa);
    int32_t temp0_146[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_140, 0xa), temp0_144);
    int32_t temp0_147[0x4] = _mm_sra_epi32(temp0_143, 0xa);
    int32_t temp0_149[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_142, 0xa), temp0_147);
    int32_t temp0_150[0x4] = _mm_add_epi32(temp0_58, temp0_80);
    int32_t temp0_151[0x4] = _mm_add_epi32(temp0_58, temp0_81);
    int32_t temp0_152[0x4] = _mm_add_epi32(temp0_106, temp0_150);
    int32_t temp0_153[0x4] = _mm_add_epi32(temp0_107, temp0_151);
    int32_t temp0_154[0x4] = _mm_sub_epi32(temp0_150, temp0_106);
    int32_t temp0_155[0x4] = _mm_sub_epi32(temp0_151, temp0_107);
    int32_t temp0_156[0x4] = _mm_sra_epi32(temp0_153, 0xa);
    int32_t temp0_158[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_152, 0xa), temp0_156);
    int32_t temp0_159[0x4] = _mm_sra_epi32(temp0_155, 0xa);
    int32_t temp0_161[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_154, 0xa), temp0_159);
    int32_t temp0_162[0x4] = _mm_unpacklo_epi16(temp0_122, temp0_161[0]);
    int32_t temp0_163[0x4] = _mm_unpackhi_epi16(temp0_122, temp0_161[0]);
    int32_t temp0_164[0x4] = _mm_unpacklo_epi16(temp0_134, temp0_149[0]);
    int32_t temp0_165[0x4] = _mm_unpackhi_epi16(temp0_134, temp0_149[0]);
    int32_t temp0_166[0x4] = _mm_unpacklo_epi16(temp0_146, temp0_137[0]);
    int32_t temp0_167[0x4] = _mm_unpackhi_epi16(temp0_146, temp0_137[0]);
    int32_t temp0_168[0x4] = _mm_unpacklo_epi16(temp0_158, temp0_125[0]);
    int32_t temp0_169[0x4] = _mm_unpackhi_epi16(temp0_158, temp0_125[0]);
    int32_t temp0_170[0x4] = _mm_unpacklo_epi16(temp0_162, temp0_166[0]);
    int32_t temp0_171[0x4] = _mm_unpackhi_epi16(temp0_162, temp0_166[0]);
    int32_t temp0_172[0x4] = _mm_unpacklo_epi16(temp0_164, temp0_168[0]);
    int32_t temp0_173[0x4] = _mm_unpackhi_epi16(temp0_164, temp0_168[0]);
    int32_t temp0_174[0x4] = _mm_unpacklo_epi16(temp0_163, temp0_167[0]);
    int32_t temp0_175[0x4] = _mm_unpackhi_epi16(temp0_163, temp0_167[0]);
    int32_t temp0_176[0x4] = _mm_unpacklo_epi16(temp0_165, temp0_169[0]);
    int32_t temp0_177[0x4] = _mm_unpackhi_epi16(temp0_165, temp0_169[0]);
    int32_t temp0_178[0x4] = _mm_unpacklo_epi16(temp0_170, temp0_172[0]);
    int32_t temp0_179[0x4] = _mm_unpackhi_epi16(temp0_170, temp0_172[0]);
    int32_t temp0_180[0x4] = _mm_unpacklo_epi16(temp0_171, temp0_173[0]);
    int32_t temp0_181[0x4] = _mm_unpackhi_epi16(temp0_171, temp0_173[0]);
    int32_t temp0_182[0x4] = _mm_unpacklo_epi16(temp0_174, temp0_176[0]);
    int32_t temp0_183[0x4] = _mm_unpackhi_epi16(temp0_174, temp0_176[0]);
    int32_t temp0_184[0x4] = _mm_unpacklo_epi16(temp0_175, temp0_177[0]);
    int32_t temp0_185[0x4] = _mm_unpackhi_epi16(temp0_175, temp0_177[0]);
    int32_t temp0_186[0x4] = _mm_unpacklo_epi16(temp0_180, temp0_184[0]);
    int32_t temp0_187[0x4] = _mm_unpackhi_epi16(temp0_180, temp0_184[0]);
    int32_t var_20a8[0x4] = _mm_madd_epi16(temp0_6, temp0_186);
    int32_t var_2098[0x4] = _mm_madd_epi16(temp0_6, temp0_187);
    int32_t var_2088[0x4] = _mm_madd_epi16(temp0_13, temp0_186);
    int32_t var_2078[0x4] = _mm_madd_epi16(temp0_13, temp0_187);
    int32_t var_2068[0x4] = _mm_add_epi16(temp0_182, temp0_178);
    int32_t temp0_193[0x4] = _mm_sub_epi16(temp0_178, temp0_182);
    int128_t var_f68 = {0};
    int32_t temp0_195[0x4] = _mm_sra_epi32(_mm_unpacklo_epi16({0}, var_2068[0]), 4);
    int128_t var_f98 = {0};
    int32_t temp0_197[0x4] = _mm_sra_epi32(_mm_unpackhi_epi16({0}, var_2068[0]), 4);
    int128_t var_fc8 = {0};
    int32_t temp0_199[0x4] = _mm_sra_epi32(_mm_unpacklo_epi16({0}, temp0_193[0]), 4);
    int128_t var_ff8 = {0};
    int32_t temp0_201[0x4] = _mm_sra_epi32(_mm_unpackhi_epi16({0}, temp0_193[0]), 4);
    int32_t temp0_202[0x4] = _mm_add_epi32(var_2088, temp0_195);
    int32_t temp0_203[0x4] = _mm_add_epi32(var_2078, temp0_197);
    int32_t temp0_204[0x4] = _mm_sub_epi32(temp0_195, var_2088);
    int32_t temp0_205[0x4] = _mm_sub_epi32(temp0_197, var_2078);
    int32_t temp0_206[0x4] = _mm_add_epi32(var_20a8, temp0_199);
    int32_t temp0_207[0x4] = _mm_add_epi32(var_2098, temp0_201);
    int32_t temp0_208[0x4] = _mm_sub_epi32(temp0_199, var_20a8);
    int32_t temp0_209[0x4] = _mm_sub_epi32(temp0_201, var_2098);
    int32_t temp0_210[0x4] = _mm_unpacklo_epi16(temp0_185, temp0_181[0]);
    int32_t temp0_211[0x4] = _mm_unpackhi_epi16(temp0_185, temp0_181[0]);
    int32_t var_1f68[0x4] = _mm_madd_epi16(temp0_34, temp0_210);
    int32_t var_1f58[0x4] = _mm_madd_epi16(temp0_34, temp0_211);
    int32_t var_1f48[0x4] = _mm_madd_epi16(temp0_41, temp0_210);
    int32_t var_1f38[0x4] = _mm_madd_epi16(temp0_41, temp0_211);
    int32_t temp0_216[0x4] = _mm_unpacklo_epi16(temp0_183, temp0_179[0]);
    int32_t temp0_217[0x4] = _mm_unpackhi_epi16(temp0_183, temp0_179[0]);
    int32_t var_1f08[0x4] = _mm_madd_epi16(temp0_48, temp0_216);
    int32_t var_1ef8[0x4] = _mm_madd_epi16(temp0_48, temp0_217);
    int32_t var_1ee8[0x4] = _mm_madd_epi16(temp0_55, temp0_216);
    int32_t var_1ed8[0x4] = _mm_madd_epi16(temp0_55, temp0_217);
    int32_t var_1ec8[0x4] = _mm_add_epi16(temp0_185, temp0_179);
    int32_t var_1eb8[0x4] = _mm_add_epi16(temp0_183, temp0_181);
    int32_t temp0_224[0x4] = _mm_unpacklo_epi16(var_1ec8, var_1eb8[0]);
    int32_t temp0_225[0x4] = _mm_unpackhi_epi16(var_1ec8, var_1eb8[0]);
    int32_t var_1e88[0x4] = _mm_madd_epi16(temp0_20, temp0_224);
    int32_t var_1e78[0x4] = _mm_madd_epi16(temp0_20, temp0_225);
    int32_t var_1e68[0x4] = _mm_madd_epi16(temp0_27, temp0_224);
    int32_t var_1e58[0x4] = _mm_madd_epi16(temp0_27, temp0_225);
    int32_t temp0_230[0x4] = _mm_add_epi32(var_1e88, var_1f68);
    int32_t temp0_231[0x4] = _mm_add_epi32(var_1e78, var_1f58);
    int32_t temp0_232[0x4] = _mm_add_epi32(var_1e68, var_1f08);
    int32_t temp0_233[0x4] = _mm_add_epi32(var_1e58, var_1ef8);
    int32_t temp0_234[0x4] = _mm_add_epi32(var_1e68, var_1f48);
    int32_t temp0_235[0x4] = _mm_add_epi32(var_1e58, var_1f38);
    int32_t temp0_236[0x4] = _mm_add_epi32(var_1e88, var_1ee8);
    int32_t temp0_237[0x4] = _mm_add_epi32(var_1e78, var_1ed8);
    int32_t temp0_238[0x4] = _mm_add_epi32(temp0_61, temp0_202);
    int32_t temp0_239[0x4] = _mm_add_epi32(temp0_61, temp0_203);
    int32_t temp0_240[0x4] = _mm_add_epi32(temp0_236, temp0_238);
    int32_t temp0_241[0x4] = _mm_add_epi32(temp0_237, temp0_239);
    int32_t temp0_242[0x4] = _mm_sub_epi32(temp0_238, temp0_236);
    int32_t temp0_243[0x4] = _mm_sub_epi32(temp0_239, temp0_237);
    int32_t temp0_244[0x4] = _mm_sra_epi32(temp0_241, 0x11);
    int32_t temp0_246[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_240, 0x11), temp0_244);
    int32_t temp0_247[0x4] = _mm_sra_epi32(temp0_243, 0x11);
    int32_t temp0_249[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_242, 0x11), temp0_247);
    int32_t temp0_250[0x4] = _mm_add_epi32(temp0_61, temp0_206);
    int32_t temp0_251[0x4] = _mm_add_epi32(temp0_61, temp0_207);
    int32_t temp0_252[0x4] = _mm_add_epi32(temp0_234, temp0_250);
    int32_t temp0_253[0x4] = _mm_add_epi32(temp0_235, temp0_251);
    int32_t temp0_254[0x4] = _mm_sub_epi32(temp0_250, temp0_234);
    int32_t temp0_255[0x4] = _mm_sub_epi32(temp0_251, temp0_235);
    int32_t temp0_256[0x4] = _mm_sra_epi32(temp0_253, 0x11);
    int32_t temp0_258[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_252, 0x11), temp0_256);
    int32_t temp0_259[0x4] = _mm_sra_epi32(temp0_255, 0x11);
    int32_t temp0_261[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_254, 0x11), temp0_259);
    int32_t temp0_262[0x4] = _mm_add_epi32(temp0_61, temp0_208);
    int32_t temp0_263[0x4] = _mm_add_epi32(temp0_61, temp0_209);
    int32_t temp0_264[0x4] = _mm_add_epi32(temp0_232, temp0_262);
    int32_t temp0_265[0x4] = _mm_add_epi32(temp0_233, temp0_263);
    int32_t temp0_266[0x4] = _mm_sub_epi32(temp0_262, temp0_232);
    int32_t temp0_267[0x4] = _mm_sub_epi32(temp0_263, temp0_233);
    int32_t temp0_268[0x4] = _mm_sra_epi32(temp0_265, 0x11);
    int32_t temp0_270[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_264, 0x11), temp0_268);
    int32_t temp0_271[0x4] = _mm_sra_epi32(temp0_267, 0x11);
    int32_t temp0_273[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_266, 0x11), temp0_271);
    int32_t temp0_274[0x4] = _mm_add_epi32(temp0_61, temp0_204);
    int32_t temp0_275[0x4] = _mm_add_epi32(temp0_61, temp0_205);
    int32_t temp0_276[0x4] = _mm_add_epi32(temp0_230, temp0_274);
    int32_t temp0_277[0x4] = _mm_add_epi32(temp0_231, temp0_275);
    int32_t temp0_278[0x4] = _mm_sub_epi32(temp0_274, temp0_230);
    int32_t temp0_279[0x4] = _mm_sub_epi32(temp0_275, temp0_231);
    int32_t temp0_280[0x4] = _mm_sra_epi32(temp0_277, 0x11);
    int32_t temp0_282[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_276, 0x11), temp0_280);
    int32_t temp0_283[0x4] = _mm_sra_epi32(temp0_279, 0x11);
    int32_t temp0_285[0x4] = _mm_packs_epi32(_mm_sra_epi32(temp0_278, 0x11), temp0_283);
    int32_t var_1c48[0x4] = _mm_packus_epi16(temp0_246, temp0_258);
    int32_t var_1c38[0x4] = _mm_packus_epi16(temp0_270, temp0_282);
    int32_t var_1c28[0x4] = _mm_packus_epi16(temp0_285, temp0_273);
    int32_t var_1c18[0x4] = _mm_packus_epi16(temp0_261, temp0_249);
    int32_t temp0_290[0x4] = _mm_unpacklo_epi8(var_1c48, var_1c28[0]);
    int32_t temp0_291[0x4] = _mm_unpackhi_epi8(var_1c48, var_1c28[0]);
    int32_t temp0_292[0x4] = _mm_unpacklo_epi8(var_1c38, var_1c18[0]);
    int32_t temp0_293[0x4] = _mm_unpackhi_epi8(var_1c38, var_1c18[0]);
    int32_t temp0_294[0x4] = _mm_unpacklo_epi8(temp0_290, temp0_292[0]);
    int32_t temp0_295[0x4] = _mm_unpackhi_epi8(temp0_290, temp0_292[0]);
    int32_t temp0_296[0x4] = _mm_unpacklo_epi8(temp0_291, temp0_293[0]);
    int32_t temp0_297[0x4] = _mm_unpackhi_epi8(temp0_291, temp0_293[0]);
    int32_t temp0_298[0x4] = _mm_unpacklo_epi8(temp0_294, temp0_296[0]);
    int32_t temp0_299[0x4] = _mm_unpackhi_epi8(temp0_294, temp0_296[0]);
    int32_t temp0_300[0x4] = _mm_unpacklo_epi8(temp0_295, temp0_297[0]);
    int32_t temp0_301[0x4] = _mm_unpackhi_epi8(temp0_295, temp0_297[0]);
    *arg1 = temp0_298[0];
    void* var_28d0_1 = (arg1 + arg2);
    *var_28d0_1 = _mm_shuffle_epi32(temp0_298, 0x4e)[0];
    void* var_28d0_2 = (var_28d0_1 + arg2);
    *var_28d0_2 = temp0_299[0];
    void* var_28d0_3 = (var_28d0_2 + arg2);
    *var_28d0_3 = _mm_shuffle_epi32(temp0_299, 0x4e)[0];
    void* var_28d0_4 = (var_28d0_3 + arg2);
    *var_28d0_4 = temp0_300[0];
    void* var_28d0_5 = (var_28d0_4 + arg2);
    *var_28d0_5 = _mm_shuffle_epi32(temp0_300, 0x4e)[0];
    void* var_28d0_6 = (var_28d0_5 + arg2);
    *var_28d0_6 = temp0_301[0];
    void* var_28d0_7 = (var_28d0_6 + arg2);
    *var_28d0_7 = _mm_shuffle_epi32(temp0_301, 0x4e)[0];
    return var_28d0_7;
}

uint64_t stbi__get_marker(int64_t* arg1)
{
    uint64_t rax_5;
    if (arg1[0x905] != 0xff)  // {"erTMCloneTable"}
    {
        char rax_3 = arg1[0x905];  // {"erTMCloneTable"}
        arg1[0x905] = 0xff;  // {"erTMCloneTable"}
        rax_5 = rax_3;
    }
    else
    {
        char var_9_1 = stbi__get8(*arg1);
        if (var_9_1 != 0xff)
        {
            rax_5 = 0xffffffff;
        }
        else
        {
            for (; var_9_1 == 0xff; var_9_1 = stbi__get8(*arg1))
            {
            }
            rax_5 = var_9_1;
        }
    }
    return rax_5;
}

void* stbi__jpeg_reset(void* arg1)
{
    *(arg1 + 0x4824) = 0;
    *(arg1 + 0x4820) = 0;
    *(arg1 + 0x482c) = 0;
    *(arg1 + 0x47d8) = 0;
    *(arg1 + 0x4778) = *(arg1 + 0x47d8);
    *(arg1 + 0x4718) = *(arg1 + 0x4778);
    *(arg1 + 0x46b8) = *(arg1 + 0x4718);
    *(arg1 + 0x4828) = 0xff;
    int32_t rax_14;
    if (*(arg1 + 0x4868) == 0)
    {
        rax_14 = 0x7fffffff;
    }
    else
    {
        rax_14 = *(arg1 + 0x4868);
    }
    *(arg1 + 0x486c) = rax_14;
    *(arg1 + 0x4844) = 0;
    return arg1;
}

int64_t stbi__parse_entropy_coded_data(int64_t* arg1)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    stbi__jpeg_reset(arg1);
    int64_t rax_71;
    if (arg1[0x906] != 0)  // {"rTMCloneTable"}
    {
        if (*(arg1 + 0x4854) != 1)
        {
            int32_t var_f4_1 = 0;
            int32_t var_f8_1;
            do
            {
                if (var_f4_1 >= *(arg1 + 0x4694))
                {
                    rax_71 = 1;
                    break;
                }
                var_f8_1 = 0;
                while (true)
                {
                    if (var_f8_1 >= arg1[0x8d2])
                    {
                        var_f4_1 = (var_f4_1 + 1);
                        break;
                    }
                    int32_t var_f0_1;
                    for (var_f0_1 = 0; var_f0_1 < *(arg1 + 0x4854); var_f0_1 = (var_f0_1 + 1))
                    {
                        int32_t rax_344 = *((arg1 + ((var_f0_1 + 0x1214) << 2)) + 8);
                        int32_t var_e8_1 = 0;
                        int64_t rdx_67;
                        while (true)
                        {
                            rdx_67 = rax_344;
                            if (var_e8_1 >= arg1[((((rdx_67 + rdx_67) + rdx_67) * 4) + 
0x8d5)])
                            {
                                break;
                            }
                            int32_t var_ec_1 = 0;
                            int64_t rdx_66;
                            while (true)
                            {
                                rdx_66 = rax_344;
                                if (var_ec_1 >= *(&arg1[(((rdx_66 + rdx_66) + rdx_66) * 4)] + 
0x46a4))
                                {
                                    break;
                                }
                                int64_t rdx_55 = rax_344;
                                int64_t rdx_57 = rax_344;
                                int64_t rdx_59 = rax_344;
                                int64_t rdx_60 = rax_344;
                                int32_t rax_384 = ((var_ec_1 + (*(&arg1[(((rdx_55 + rdx_55) + 
rdx_55) * 4)] + 0x46a4) * var_f8_1)) + (arg1[((((rdx_60 + rdx_60) + rdx_60) * 4) + 0x8df)] * 
(var_e8_1 + (arg1[((((rdx_57 + rdx_57) + rdx_57) * 4) + 0x8d5)] * var_f4_1))));
                                int64_t rax_386 = (rax_384 << 6);
                                int64_t rdx_62 = rax_344;
                                int32_t rax_401 = stbi__jpeg_decode_block_prog_dc(arg1, 
((rax_386 + rax_386) + arg1[((((rdx_59 + rdx_59) + rdx_59) * 4) + 0x8de)]), 
&arg1[((*(&arg1[(((rdx_62 + rdx_62) + rdx_62) * 4)] + &data_46b0) * 0xd2) + 1)], rax_344);
                                rax_401 = rax_401 == 0;
                                if (rax_401 != 0)
                                {
                                    break;
                                }
                                var_ec_1 = (var_ec_1 + 1);
                            }
                            if (var_ec_1 < *(((((rdx_66 + rdx_66) + rdx_66) << 5) + arg1) + 
0x46a4))
                            {
                                break;
                            }
                            var_e8_1 = (var_e8_1 + 1);
                        }
                        if (var_e8_1 < *(((((rdx_67 + rdx_67) + rdx_67) << 5) + arg1) + 
0x46a8))
                        {
                            break;
                        }
                    }
                    if (var_f0_1 < *(arg1 + 0x4854))
                    {
                        rax_71 = 0;
                        break;
                    }
                    *(arg1 + 0x486c) = (*(arg1 + 0x486c) - 1);
                    int32_t rax_424;
                    rax_424 = *(arg1 + 0x486c) <= 0;
                    if (rax_424 != 0)
                    {
                        if (*(arg1 + 0x4824) <= 0x17)
                        {
                            stbi__grow_buffer_unsafe(arg1);
                        }
                        if ((arg1[0x905] <= 0xcf || (arg1[0x905] > 0xcf && arg1[0x905] > 
0xd7)))  // {"erTMCloneTable"}
                        {
                            rax_71 = 1;
                            break;
                        }
                        if ((arg1[0x905] > 0xcf && arg1[0x905] <= 0xd7))  // 
{"erTMCloneTable"}
                        {
                            stbi__jpeg_reset(arg1);
                        }
                    }
                    var_f8_1 = (var_f8_1 + 1);
                }
            } while (var_f8_1 >= arg1[0x8d2]);
        }
        else
        {
            int32_t rax_250 = arg1[0x90b];  // {"oneTable"}
            int64_t rdx_38 = rax_250;
            int32_t rax_260 = ((*(&arg1[(((rdx_38 + rdx_38) + rdx_38) * 4)] + 0x46bc) + 7) >> 
3);
            int64_t rdx_39 = rax_250;
            int32_t rax_270 = ((arg1[((((rdx_39 + rdx_39) + rdx_39) * 4) + 0x8d8)] + 7) >> 3);
            int32_t var_fc_1 = 0;
            int32_t var_100_1;
            do
            {
                if (var_fc_1 >= rax_270)
                {
                    rax_71 = 1;
                    break;
                }
                var_100_1 = 0;
                while (true)
                {
                    if (var_100_1 >= rax_260)
                    {
                        var_fc_1 = (var_fc_1 + 1);
                        break;
                    }
                    int64_t rdx_40 = rax_250;
                    int64_t rdx_41 = rax_250;
                    int64_t rax_290 = ((var_100_1 + (arg1[((((rdx_41 + rdx_41) + rdx_41) * 4) 
+ 0x8df)] * var_fc_1)) << 6);
                    int16_t* rax_292 = ((rax_290 + rax_290) + arg1[((((rdx_40 + rdx_40) + 
rdx_40) * 4) + 0x8de)]);
                    if (*(arg1 + 0x4834) != 0)
                    {
                        int64_t rdx_47 = rax_250;
                        int32_t rax_315 = *(&arg1[(((rdx_47 + rdx_47) + rdx_47) * 4)] + 
0x46b4);
                        int32_t rax_327;
                        rax_327 = stbi__jpeg_decode_block_prog_ac(arg1, rax_292, ((arg1 + 
((rax_315 * 0x690) + 0x1a40)) + 8), ((arg1 + ((rax_315 << 0xa) + 0x3680)) + 8)) == 0;
                        if (rax_327 != 0)
                        {
                            rax_71 = 0;
                            break;
                        }
                    }
                    else
                    {
                        int64_t rdx_43 = rax_250;
                        int32_t rax_307;
                        rax_307 = stbi__jpeg_decode_block_prog_dc(arg1, rax_292, 
&arg1[((*(&arg1[(((rdx_43 + rdx_43) + rdx_43) * 4)] + &data_46b0) * 0xd2) + 1)], rax_250) == 
0;
                        if (rax_307 != 0)
                        {
                            rax_71 = 0;
                            break;
                        }
                    }
                    *(arg1 + 0x486c) = (*(arg1 + 0x486c) - 1);
                    int32_t rax_332;
                    rax_332 = *(arg1 + 0x486c) <= 0;
                    if (rax_332 != 0)
                    {
                        if (*(arg1 + 0x4824) <= 0x17)
                        {
                            stbi__grow_buffer_unsafe(arg1);
                        }
                        if ((arg1[0x905] <= 0xcf || (arg1[0x905] > 0xcf && arg1[0x905] > 
0xd7)))  // {"erTMCloneTable"}
                        {
                            rax_71 = 1;
                            break;
                        }
                        if ((arg1[0x905] > 0xcf && arg1[0x905] <= 0xd7))  // 
{"erTMCloneTable"}
                        {
                            stbi__jpeg_reset(arg1);
                        }
                    }
                    var_100_1 = (var_100_1 + 1);
                }
            } while (var_100_1 >= rax_260);
        }
    }
    else
    {
        void var_98;
        if (*(arg1 + 0x4854) != 1)
        {
            int32_t var_110_1 = 0;
            int32_t var_114_1;
            do
            {
                if (var_110_1 >= *(arg1 + 0x4694))
                {
                    rax_71 = 1;
                    break;
                }
                var_114_1 = 0;
                while (true)
                {
                    if (var_114_1 >= arg1[0x8d2])
                    {
                        var_110_1 = (var_110_1 + 1);
                        break;
                    }
                    int32_t var_10c_1;
                    for (var_10c_1 = 0; var_10c_1 < *(arg1 + 0x4854); var_10c_1 = (var_10c_1 + 
1))
                    {
                        int32_t rax_117 = *((arg1 + ((var_10c_1 + 0x1214) << 2)) + 8);
                        int32_t var_104_1 = 0;
                        int64_t rdx_36;
                        while (true)
                        {
                            rdx_36 = rax_117;
                            if (var_104_1 >= arg1[((((rdx_36 + rdx_36) + rdx_36) * 4) + 
0x8d5)])
                            {
                                break;
                            }
                            int32_t var_108_1 = 0;
                            int64_t rdx_35;
                            while (true)
                            {
                                rdx_35 = rax_117;
                                if (var_108_1 >= *(&arg1[(((rdx_35 + rdx_35) + rdx_35) * 4)] + 
0x46a4))
                                {
                                    break;
                                }
                                int64_t rdx_19 = rax_117;
                                int32_t rax_129 = ((var_108_1 + (*(&arg1[(((rdx_19 + rdx_19) + 
rdx_19) * 4)] + 0x46a4) * var_114_1)) << 3);
                                int64_t rdx_21 = rax_117;
                                int32_t rax_141 = ((var_104_1 + (arg1[((((rdx_21 + rdx_21) + 
rdx_21) * 4) + 0x8d5)] * var_110_1)) << 3);
                                int64_t rdx_23 = rax_117;
                                int32_t rax_149 = *(&arg1[(((rdx_23 + rdx_23) + rdx_23) * 4)] 
+ 0x46b4);
                                int64_t rdx_24 = rax_117;
                                int64_t rdx_28 = rax_117;
                                int32_t rax_184 = stbi__jpeg_decode_block(arg1, &var_98, 
&arg1[(1 + (*(&arg1[(((rdx_28 + rdx_28) + rdx_28) * 4)] + &data_46b0) * 0xd2))], &arg1[(0x349 
+ (rax_149 * 0xd2))], ((arg1 + ((rax_149 << 0xa) + 0x3680)) + 8), rax_117, 
&arg1[(((*(&arg1[(((rdx_24 + rdx_24) + rdx_24) * 4)] + 0x46ac) + 0x69) * 0x10) + 1)]);
                                rax_184 = rax_184 == 0;
                                if (rax_184 != 0)
                                {
                                    break;
                                }
                                int64_t rdx_30 = rax_117;
                                uint64_t rcx_14 = *(&arg1[(((rdx_30 + rdx_30) + rdx_30) * 4)] 
+ 0x46c4);
                                int64_t rdx_31 = rax_117;
                                int64_t rdx_32 = rax_117;
                                arg1[0x90e]((arg1[((((rdx_31 + rdx_31) + rdx_31) * 4) + 
0x8da)] + (rax_129 + (*(&arg1[(((rdx_32 + rdx_32) + rdx_32) * 4)] + 0x46c4) * rax_141))), 
rcx_14, &var_98, rcx_14);  // {"Table"}
                                var_108_1 = (var_108_1 + 1);
                            }
                            if (var_108_1 < *(((((rdx_35 + rdx_35) + rdx_35) << 5) + arg1) + 
0x46a4))
                            {
                                break;
                            }
                            var_104_1 = (var_104_1 + 1);
                        }
                        if (var_104_1 < *(((((rdx_36 + rdx_36) + rdx_36) << 5) + arg1) + 
0x46a8))
                        {
                            break;
                        }
                    }
                    if (var_10c_1 < *(arg1 + 0x4854))
                    {
                        rax_71 = 0;
                        break;
                    }
                    *(arg1 + 0x486c) = (*(arg1 + 0x486c) - 1);
                    int32_t rax_234;
                    rax_234 = *(arg1 + 0x486c) <= 0;
                    if (rax_234 != 0)
                    {
                        if (*(arg1 + 0x4824) <= 0x17)
                        {
                            stbi__grow_buffer_unsafe(arg1);
                        }
                        if ((arg1[0x905] <= 0xcf || (arg1[0x905] > 0xcf && arg1[0x905] > 
0xd7)))  // {"erTMCloneTable"}
                        {
                            rax_71 = 1;
                            break;
                        }
                        if ((arg1[0x905] > 0xcf && arg1[0x905] <= 0xd7))  // 
{"erTMCloneTable"}
                        {
                            stbi__jpeg_reset(arg1);
                        }
                    }
                    var_114_1 = (var_114_1 + 1);
                }
            } while (var_114_1 >= arg1[0x8d2]);
        }
        else
        {
            int32_t rax_7 = arg1[0x90b];  // {"oneTable"}
            int64_t rdx_1 = rax_7;
            int32_t rax_17 = ((*(&arg1[(((rdx_1 + rdx_1) + rdx_1) * 4)] + 0x46bc) + 7) >> 3);
            int64_t rdx_2 = rax_7;
            int32_t rax_27 = ((arg1[((((rdx_2 + rdx_2) + rdx_2) * 4) + 0x8d8)] + 7) >> 3);
            int32_t var_118_1 = 0;
            int32_t var_11c_1;
            do
            {
                if (var_118_1 >= rax_27)
                {
                    rax_71 = 1;
                    break;
                }
                var_11c_1 = 0;
                while (true)
                {
                    if (var_11c_1 >= rax_17)
                    {
                        var_118_1 = (var_118_1 + 1);
                        break;
                    }
                    int64_t rdx_3 = rax_7;
                    int32_t rax_35 = *(&arg1[(((rdx_3 + rdx_3) + rdx_3) * 4)] + 0x46b4);
                    int64_t rdx_4 = rax_7;
                    int64_t rdx_8 = rax_7;
                    int32_t rax_70 = stbi__jpeg_decode_block(arg1, &var_98, &arg1[(1 + 
(*(&arg1[(((rdx_8 + rdx_8) + rdx_8) * 4)] + &data_46b0) * 0xd2))], &arg1[(0x349 + (rax_35 * 
0xd2))], ((arg1 + ((rax_35 << 0xa) + 0x3680)) + 8), rax_7, &arg1[(((*(&arg1[(((rdx_4 + rdx_4) 
+ rdx_4) * 4)] + 0x46ac) + 0x69) * 0x10) + 1)]);
                    rax_70 = rax_70 == 0;
                    if (rax_70 != 0)
                    {
                        rax_71 = 0;
                        break;
                    }
                    int64_t rdx_10 = rax_7;
                    uint64_t rcx_7 = *(&arg1[(((rdx_10 + rdx_10) + rdx_10) * 4)] + 0x46c4);
                    int64_t rdx_11 = rax_7;
                    int64_t rdx_12 = rax_7;
                    int64_t rdi_4 = (arg1[((((rdx_11 + rdx_11) + rdx_11) * 4) + 0x8da)] + 
((var_11c_1 << 3) + ((*(&arg1[(((rdx_12 + rdx_12) + rdx_12) * 4)] + 0x46c4) * var_118_1) << 
3)));
                    arg1[0x90e](rdi_4, rcx_7, &var_98, rcx_7);  // {"Table"}
                    *(arg1 + 0x486c) = (*(arg1 + 0x486c) - 1);
                    int32_t rax_105;
                    rax_105 = *(arg1 + 0x486c) <= 0;
                    if (rax_105 != 0)
                    {
                        if (*(arg1 + 0x4824) <= 0x17)
                        {
                            stbi__grow_buffer_unsafe(arg1);
                        }
                        if ((arg1[0x905] <= 0xcf || (arg1[0x905] > 0xcf && arg1[0x905] > 
0xd7)))  // {"erTMCloneTable"}
                        {
                            rax_71 = 1;
                            break;
                        }
                        if ((arg1[0x905] > 0xcf && arg1[0x905] <= 0xd7))  // 
{"erTMCloneTable"}
                        {
                            stbi__jpeg_reset(arg1);
                        }
                    }
                    var_11c_1 = (var_11c_1 + 1);
                }
            } while (var_11c_1 >= rax_17);
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_71;
    }
    __stack_chk_fail();
    /* no return */
}

void stbi__jpeg_dequantize(void* arg1, void* arg2)
{
    for (int32_t var_c = 0; var_c <= 0x3f; var_c = (var_c + 1))
    {
        int64_t rax_2 = var_c;
        int64_t rax_7 = var_c;
        int64_t rax_12 = var_c;
        *(arg1 + (rax_12 + rax_12)) = (*(arg1 + (rax_2 + rax_2)) * *(arg2 + (rax_7 + rax_7)));
    }
}

uint64_t stbi__jpeg_finish(int64_t* arg1)
{
    uint64_t rax_1 = arg1[0x906];  // {"rTMCloneTable"}
    if (rax_1 != 0)
    {
        int32_t var_1c_1 = 0;
        while (true)
        {
            rax_1 = *(*arg1 + 8);
            if (var_1c_1 >= rax_1)
            {
                break;
            }
            int64_t rdx_1 = var_1c_1;
            int32_t rax_11 = ((*(&arg1[(((rdx_1 + rdx_1) + rdx_1) * 4)] + 0x46bc) + 7) >> 3);
            int64_t rdx_2 = var_1c_1;
            int32_t rax_21 = ((arg1[((((rdx_2 + rdx_2) + rdx_2) * 4) + 0x8d8)] + 7) >> 3);
            for (int32_t var_20_1 = 0; var_20_1 < rax_21; var_20_1 = (var_20_1 + 1))
            {
                for (int32_t var_24_1 = 0; var_24_1 < rax_11; var_24_1 = (var_24_1 + 1))
                {
                    int64_t rdx_3 = var_1c_1;
                    int64_t rdx_4 = var_1c_1;
                    int64_t rax_41 = ((var_24_1 + (arg1[((((rdx_4 + rdx_4) + rdx_4) * 4) + 
0x8df)] * var_20_1)) << 6);
                    void* rax_43 = ((rax_41 + rax_41) + arg1[((((rdx_3 + rdx_3) + rdx_3) * 4) 
+ 0x8de)]);
                    int64_t rdx_6 = var_1c_1;
                    stbi__jpeg_dequantize(rax_43, &arg1[(((*(&arg1[(((rdx_6 + rdx_6) + rdx_6) 
* 4)] + 0x46ac) + 0x69) * 0x10) + 1)]);
                    int64_t rdx_9 = var_1c_1;
                    uint64_t rcx_7 = *(&arg1[(((rdx_9 + rdx_9) + rdx_9) * 4)] + 0x46c4);
                    int64_t rdx_10 = var_1c_1;
                    int64_t rdx_11 = var_1c_1;
                    int64_t rdi_2 = (arg1[((((rdx_10 + rdx_10) + rdx_10) * 4) + 0x8da)] + 
((var_24_1 << 3) + ((*(&arg1[(((rdx_11 + rdx_11) + rdx_11) * 4)] + 0x46c4) * var_20_1) << 
3)));
                    arg1[0x90e](rdi_2, rcx_7, rax_43, rcx_7);  // {"Table"}
                }
            }
            var_1c_1 = (var_1c_1 + 1);
        }
    }
    return rax_1;
}

uint64_t stbi__process_marker(int64_t* arg1, int32_t arg2)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    uint64_t rax_2;
    if (arg2 == 0xff)
    {
        rax_2 = stbi__err("expected marker");
    }
    else
    {
        if (arg2 == 0xdb)
        {
            int32_t var_ac_1 = (stbi__get16be(*arg1) - 2);
            while (true)
            {
                int32_t rax_12;
                if (var_ac_1 <= 0)
                {
                    rax_12 = var_ac_1 == 0;
                    rax_2 = rax_12;
                    break;
                }
                uint32_t rax_16 = stbi__get8(*arg1);
                int32_t var_88_1 = (rax_16 >> 4);
                int32_t rax_18;
                rax_18 = var_88_1 != 0;
                uint32_t rax_19 = rax_18;
                int32_t rax_21 = (rax_16 & 0xf);
                if ((var_88_1 != 0 && var_88_1 != 1))
                {
                    rax_2 = stbi__err("bad DQT type");
                    break;
                }
                if (rax_21 > 3)
                {
                    rax_2 = stbi__err("bad DQT table");
                    break;
                }
                for (int32_t var_a8_1 = 0; var_a8_1 <= 0x3f; var_a8_1 = (var_a8_1 + 1))
                {
                    uint16_t rax_24;
                    if (rax_19 == 0)
                    {
                        rax_24 = stbi__get8(*arg1);
                    }
                    else
                    {
                        rax_24 = stbi__get16be(*arg1);
                    }
                    *((arg1 + (((*(var_a8_1 + &stbi__jpeg_dezigzag) + (rax_21 << 6)) + 0x1a40) 
<< 1)) + 8) = rax_24;
                }
                if (rax_19 == 0)
                {
                    rax_12 = 0x41;
                }
                else
                {
                    rax_12 = 0x81;
                }
                var_ac_1 = (var_ac_1 - rax_12);
            }
        }
        if (arg2 == 0xc4)
        {
            int32_t var_ac_2 = (stbi__get16be(*arg1) - 2);
            while (true)
            {
                if (var_ac_2 <= 0)
                {
                    int32_t rax_31;
                    rax_31 = var_ac_2 == 0;
                    rax_2 = rax_31;
                    break;
                }
                int32_t var_a0_1 = 0;
                uint32_t rax_35 = stbi__get8(*arg1);
                int32_t rax_37 = (rax_35 >> 4);
                int32_t rax_39 = (rax_35 & 0xf);
                if ((rax_37 <= 1 && rax_39 <= 3))
                {
                    void var_68;
                    for (int32_t var_a4_1 = 0; var_a4_1 <= 0xf; var_a4_1 = (var_a4_1 + 1))
                    {
                        *(&var_68 + (var_a4_1 << 2)) = stbi__get8(*arg1);
                        var_a0_1 = (var_a0_1 + *(&var_68 + (var_a4_1 << 2)));
                    }
                    if (var_a0_1 > 0x100)
                    {
                        rax_2 = stbi__err("bad DHT header");
                        break;
                    }
                    void* var_70_1;
                    if (rax_37 != 0)
                    {
                        int32_t rax_63;
                        rax_63 = stbi__build_huffman(&arg1[(0x349 + (rax_39 * 0xd2))], 
&var_68) == 0;
                        if (rax_63 != 0)
                        {
                            rax_2 = 0;
                            break;
                        }
                        var_70_1 = ((arg1 + ((rax_39 * 0x690) + 0x1e40)) + 8);
                    }
                    else
                    {
                        int32_t rax_52;
                        rax_52 = stbi__build_huffman(&arg1[(1 + (rax_39 * 0xd2))], &var_68) == 
0;
                        if (rax_52 != 0)
                        {
                            rax_2 = 0;
                            break;
                        }
                        var_70_1 = ((arg1 + ((rax_39 * 0x690) + 0x400)) + 8);
                    }
                    for (int32_t var_a4_2 = 0; var_a4_2 < var_a0_1; var_a4_2 = (var_a4_2 + 1))
                    {
                        *(var_a4_2 + var_70_1) = stbi__get8(*arg1);
                    }
                    if (rax_37 != 0)
                    {
                        stbi__build_fast_ac(((arg1 + ((rax_39 << 0xa) + 0x3680)) + 8), 
&arg1[(0x349 + (rax_39 * 0xd2))]);
                    }
                    var_ac_2 = ((var_ac_2 - 0x11) - var_a0_1);
                    continue;
                }
                rax_2 = stbi__err("bad DHT header");
                break;
            }
        }
        if (arg2 == 0xdd)
        {
            int32_t rax_5;
            rax_5 = stbi__get16be(*arg1) != 4;
            if (rax_5 == 0)
            {
                arg1[0x90d] = stbi__get16be(*arg1);  // {"eTable"}
                rax_2 = 1;
            }
            else
            {
                rax_2 = stbi__err("bad DRI len");
            }
        }
        if (((arg2 > 0xff || ((arg2 <= 0xff && arg2 != 0xdd) && arg2 > 0xdd)) || ((((arg2 <= 
0xff && arg2 != 0xdd) && arg2 <= 0xdd) && arg2 != 0xc4) && arg2 != 0xdb)))
        {
            if ((arg2 > 0xdf && arg2 <= 0xef))
            {
            label_cbd3:
                int32_t rax_86 = stbi__get16be(*arg1);
                if (rax_86 > 1)
                {
                    int32_t var_ac_5 = (rax_86 - 2);
                    if ((arg2 == 0xe0 && var_ac_5 > 4))
                    {
                        int32_t var_9c_1 = 1;
                        for (int32_t var_98_1 = 0; var_98_1 <= 4; var_98_1 = (var_98_1 + 1))
                        {
                            if (stbi__get8(*arg1) != *"JFIF"[var_98_1] != 0)
                            {
                                var_9c_1 = 0;
                            }
                        }
                        var_ac_5 = (var_ac_5 - 5);
                        if (var_9c_1 != 0)
                        {
                            arg1[0x909] = 1;  // {"CloneTable"}
                        }
                    }
                    if ((((arg2 != 0xe0 || (arg2 == 0xe0 && var_ac_5 <= 4)) && arg2 == 0xee) 
&& var_ac_5 > 0xb))
                    {
                        int32_t var_94_1 = 1;
                        for (int32_t var_90_1 = 0; var_90_1 <= 5; var_90_1 = (var_90_1 + 1))
                        {
                            if (stbi__get8(*arg1) != *"Adobe"[var_90_1] != 0)
                            {
                                var_94_1 = 0;
                            }
                        }
                        var_ac_5 = (var_ac_5 - 6);
                        if (var_94_1 != 0)
                        {
                            stbi__get8(*arg1);
                            stbi__get16be(*arg1);
                            stbi__get16be(*arg1);
                            *(arg1 + 0x484c) = stbi__get8(*arg1);
                            var_ac_5 = (var_ac_5 - 6);
                        }
                    }
                    stbi__skip(*arg1, var_ac_5);
                    rax_2 = 1;
                }
                else if (arg2 != 0xfe)
                {
                    rax_2 = stbi__err("bad APP len");
                }
                else
                {
                    rax_2 = stbi__err("bad COM len");
                }
            }
            if ((arg2 <= 0xdf || (arg2 > 0xdf && arg2 > 0xef)))
            {
                if (arg2 == 0xfe)
                {
                    goto label_cbd3;
                }
                rax_2 = stbi__err("unknown marker");
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_2;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__process_scan_header(int64_t* arg1)
{
    int32_t rax_2 = stbi__get16be(*arg1);
    *(arg1 + 0x4854) = stbi__get8(*arg1);
    int64_t rax_15;
    if (((*(arg1 + 0x4854) <= 0 || (*(arg1 + 0x4854) > 0 && *(arg1 + 0x4854) > 4)) || ((*(arg1 
+ 0x4854) > 0 && *(arg1 + 0x4854) <= 4) && *(arg1 + 0x4854) > *(*arg1 + 8))))
    {
        rax_15 = stbi__err("bad SOS component count");
    }
    if (((*(arg1 + 0x4854) > 0 && *(arg1 + 0x4854) <= 4) && *(arg1 + 0x4854) <= *(*arg1 + 8)))
    {
        int32_t rax_18 = (*(arg1 + 0x4854) + 3);
        if (rax_2 != (rax_18 + rax_18))
        {
            rax_15 = stbi__err("bad SOS len");
        }
        else
        {
            int32_t var_20_1 = 0;
            while (true)
            {
                if (var_20_1 >= *(arg1 + 0x4854))
                {
                    *(arg1 + 0x4834) = stbi__get8(*arg1);
                    arg1[0x907] = stbi__get8(*arg1);  // {"TMCloneTable"}
                    uint32_t rax_90 = stbi__get8(*arg1);
                    *(arg1 + 0x483c) = (rax_90 >> 4);
                    arg1[0x908] = (rax_90 & 0xf);  // {"MCloneTable"}
                    if (arg1[0x906] != 0)  // {"rTMCloneTable"}
                    {
                        if (*(arg1 + 0x4834) <= 0x3f)
                        {
                            if (arg1[0x907] > 0x3f)  // {"TMCloneTable"}
                            {
                                goto label_d116;
                            }
                            if (*(arg1 + 0x4834) > arg1[0x907])  // {"TMCloneTable"}
                            {
                                goto label_d116;
                            }
                            if (*(arg1 + 0x483c) > 0xd)
                            {
                                goto label_d116;
                            }
                            if (arg1[0x908] > 0xd)  // {"MCloneTable"}
                            {
                                goto label_d116;
                            }
                            goto label_d177;
                        }
                    label_d116:
                        rax_15 = stbi__err("bad SOS");
                    }
                    else if (*(arg1 + 0x4834) != 0)
                    {
                        rax_15 = stbi__err("bad SOS");
                    }
                    else
                    {
                        if ((*(arg1 + 0x483c) != 0 || (*(arg1 + 0x483c) == 0 && arg1[0x908] != 
0)))  // {"MCloneTable"}
                        {
                            rax_15 = stbi__err("bad SOS");
                        }
                        if ((*(arg1 + 0x483c) == 0 && arg1[0x908] == 0))  // {"MCloneTable"}
                        {
                            arg1[0x907] = 0x3f;  // {"TMCloneTable"}
                        label_d177:
                            rax_15 = 1;
                        }
                    }
                    break;
                }
                uint32_t rax_23 = stbi__get8(*arg1);
                uint32_t rax_27 = stbi__get8(*arg1);
                int32_t var_1c_1;
                for (var_1c_1 = 0; var_1c_1 < *(*arg1 + 8); var_1c_1 = (var_1c_1 + 1))
                {
                    int64_t rdx_2 = var_1c_1;
                    if (rax_23 == arg1[((((rdx_2 + rdx_2) + rdx_2) * 4) + 0x8d4)])
                    {
                        break;
                    }
                }
                if (var_1c_1 == *(*arg1 + 8))
                {
                    rax_15 = 0;
                    break;
                }
                int64_t rdx_3 = var_1c_1;
                *(&arg1[(((rdx_3 + rdx_3) + rdx_3) * 4)] + &data_46b0) = (rax_27 >> 4);
                int64_t rdx_4 = var_1c_1;
                if (*(&arg1[(((rdx_4 + rdx_4) + rdx_4) * 4)] + &data_46b0) > 3)
                {
                    rax_15 = stbi__err("bad DC huff");
                    break;
                }
                int64_t rdx_5 = var_1c_1;
                *(&arg1[(((rdx_5 + rdx_5) + rdx_5) * 4)] + 0x46b4) = (rax_27 & 0xf);
                int64_t rdx_6 = var_1c_1;
                if (*(&arg1[(((rdx_6 + rdx_6) + rdx_6) * 4)] + 0x46b4) > 3)
                {
                    rax_15 = stbi__err("bad AC huff");
                    break;
                }
                *((arg1 + ((var_20_1 + 0x1214) << 2)) + 8) = var_1c_1;
                var_20_1 = (var_20_1 + 1);
            }
        }
    }
    return rax_15;
}

uint64_t stbi__free_jpeg_components(int64_t arg1, int32_t arg2, int32_t arg3)
{
    for (int32_t var_c = 0; var_c < arg2; var_c = (var_c + 1))
    {
        int64_t rdx = var_c;
        if (*(((((rdx + rdx) + rdx) << 5) + arg1) + 0x46d8) != 0)
        {
            int64_t rdx_1 = var_c;
            free(*(((((rdx_1 + rdx_1) + rdx_1) << 5) + arg1) + 0x46d8));
            int64_t rdx_2 = var_c;
            *(((((rdx_2 + rdx_2) + rdx_2) << 5) + arg1) + 0x46d8) = 0;
            int64_t rdx_3 = var_c;
            *(((((rdx_3 + rdx_3) + rdx_3) << 5) + arg1) + 0x46d0) = 0;
        }
        int64_t rdx_4 = var_c;
        if (*(((((rdx_4 + rdx_4) + rdx_4) << 5) + arg1) + 0x46e0) != 0)
        {
            int64_t rdx_5 = var_c;
            free(*(((((rdx_5 + rdx_5) + rdx_5) << 5) + arg1) + 0x46e0));
            int64_t rdx_6 = var_c;
            *(((((rdx_6 + rdx_6) + rdx_6) << 5) + arg1) + 0x46e0) = 0;
            int64_t rdx_7 = var_c;
            *(((((rdx_7 + rdx_7) + rdx_7) << 5) + arg1) + 0x46f0) = 0;
        }
        int64_t rdx_8 = var_c;
        if (*(((((rdx_8 + rdx_8) + rdx_8) << 5) + arg1) + 0x46e8) != 0)
        {
            int64_t rdx_9 = var_c;
            free(*(((((rdx_9 + rdx_9) + rdx_9) << 5) + arg1) + 0x46e8));
            int64_t rdx_10 = var_c;
            *(((((rdx_10 + rdx_10) + rdx_10) << 5) + arg1) + 0x46e8) = 0;
        }
    }
    return arg3;
}

uint64_t stbi__process_frame_header(int64_t* arg1, int32_t arg2)
{
    char* rax_1 = *arg1;
    int32_t var_28 = 1;
    int32_t var_24 = 1;
    int32_t rax_3 = stbi__get16be(rax_1);
    uint64_t rax_4;
    if (rax_3 <= 0xa)
    {
        rax_4 = stbi__err("bad SOF len");
    }
    else if (stbi__get8(rax_1) != 8)
    {
        rax_4 = stbi__err("only 8-bit");
    }
    else
    {
        *(rax_1 + 4) = stbi__get16be(rax_1);
        if (*(rax_1 + 4) == 0)
        {
            rax_4 = stbi__err("no header height");
        }
        else
        {
            *rax_1 = stbi__get16be(rax_1);
            if (*rax_1 == 0)
            {
                rax_4 = stbi__err("0 width");
            }
            else if (*(rax_1 + 4) > 0x1000000)
            {
                rax_4 = stbi__err("too large");
            }
            else if (*rax_1 > 0x1000000)
            {
                rax_4 = stbi__err("too large");
            }
            else
            {
                uint32_t rax_24 = stbi__get8(rax_1);
                if (((rax_24 == 3 || rax_24 == 1) || rax_24 == 4))
                {
                    *(rax_1 + 8) = rax_24;
                    for (int32_t var_2c_1 = 0; var_2c_1 < rax_24; var_2c_1 = (var_2c_1 + 1))
                    {
                        int64_t rdx_4 = var_2c_1;
                        arg1[((((rdx_4 + rdx_4) + rdx_4) * 4) + 0x8da)] = 0;
                        int64_t rdx_5 = var_2c_1;
                        arg1[((((rdx_5 + rdx_5) + rdx_5) * 4) + 0x8dd)] = 0;
                    }
                    int32_t rdx_6 = *(rax_1 + 8);
                    if (rax_3 != (((rdx_6 + rdx_6) + rdx_6) + 8))
                    {
                        rax_4 = stbi__err("bad SOF len");
                    }
                    else
                    {
                        arg1[0x90a] = 0;  // {"loneTable"}
                        int32_t var_2c_2 = 0;
                        while (true)
                        {
                            if (var_2c_2 >= *(rax_1 + 8))
                            {
                                if (arg2 != 0)
                                {
                                    rax_4 = 1;
                                }
                                else
                                {
                                    int32_t rax_146;
                                    rax_146 = stbi__mad3sizes_valid(*rax_1, *(rax_1 + 4), 
*(rax_1 + 8), 0) == 0;
                                    if (rax_146 != 0)
                                    {
                                        rax_4 = stbi__err("too large");
                                    }
                                    else
                                    {
                                        for (int32_t var_2c_3 = 0; var_2c_3 < *(rax_1 + 8); 
var_2c_3 = (var_2c_3 + 1))
                                        {
                                            int64_t rdx_24 = var_2c_3;
                                            if (var_28 < *(&arg1[(((rdx_24 + rdx_24) + rdx_24) 
* 4)] + 0x46a4))
                                            {
                                                int64_t rdx_25 = var_2c_3;
                                                var_28 = *(&arg1[(((rdx_25 + rdx_25) + rdx_25) 
* 4)] + 0x46a4);
                                            }
                                            int64_t rdx_26 = var_2c_3;
                                            if (var_24 < arg1[((((rdx_26 + rdx_26) + rdx_26) * 
4) + 0x8d5)])
                                            {
                                                int64_t rdx_27 = var_2c_3;
                                                var_24 = arg1[((((rdx_27 + rdx_27) + rdx_27) * 
4) + 0x8d5)];
                                            }
                                        }
                                        int32_t var_2c_4 = 0;
                                        while (true)
                                        {
                                            if (var_2c_4 >= *(rax_1 + 8))
                                            {
                                                arg1[0x8d1] = var_28;
                                                *(arg1 + 0x468c) = var_24;
                                                arg1[0x8d3] = (var_28 << 3);
                                                *(arg1 + 0x469c) = (var_24 << 3);
                                                arg1[0x8d2] = (COMBINE(0, ((arg1[0x8d3] + 
*rax_1) - 1)) / arg1[0x8d3]);
                                                *(arg1 + 0x4694) = (COMBINE(0, ((*(arg1 + 
0x469c) + *(rax_1 + 4)) - 1)) / *(arg1 + 0x469c));
                                                int32_t var_2c_5 = 0;
                                                while (true)
                                                {
                                                    if (var_2c_5 >= *(rax_1 + 8))
                                                    {
                                                        rax_4 = 1;
                                                        break;
                                                    }
                                                    int64_t rdx_44 = var_2c_5;
                                                    int64_t rdx_46 = var_2c_5;
                                                    *(&arg1[(((rdx_46 + rdx_46) + rdx_46) * 
4)] + 0x46bc) = (COMBINE(0, ((var_28 + (*rax_1 * *(&arg1[(((rdx_44 + rdx_44) + rdx_44) * 4)] + 
0x46a4))) - 1)) / var_28);
                                                    int64_t rdx_47 = var_2c_5;
                                                    int64_t rdx_49 = var_2c_5;
                                                    arg1[((((rdx_49 + rdx_49) + rdx_49) * 4) + 
0x8d8)] = (COMBINE(0, ((var_24 + (*(rax_1 + 4) * arg1[((((rdx_47 + rdx_47) + rdx_47) * 4) + 
0x8d5)])) - 1)) / var_24);
                                                    int64_t rdx_50 = var_2c_5;
                                                    int64_t rdx_51 = var_2c_5;
                                                    *(&arg1[(((rdx_51 + rdx_51) + rdx_51) * 
4)] + 0x46c4) = ((*(&arg1[(((rdx_50 + rdx_50) + rdx_50) * 4)] + 0x46a4) * arg1[0x8d2]) << 3);
                                                    int64_t rdx_52 = var_2c_5;
                                                    int64_t rdx_53 = var_2c_5;
                                                    arg1[((((rdx_53 + rdx_53) + rdx_53) * 4) + 
0x8d9)] = ((arg1[((((rdx_52 + rdx_52) + rdx_52) * 4) + 0x8d5)] * *(arg1 + 0x4694)) << 3);
                                                    int64_t rdx_54 = var_2c_5;
                                                    arg1[((((rdx_54 + rdx_54) + rdx_54) * 4) + 
0x8de)] = 0;
                                                    int64_t rdx_55 = var_2c_5;
                                                    arg1[((((rdx_55 + rdx_55) + rdx_55) * 4) + 
0x8dc)] = 0;
                                                    int64_t rdx_56 = var_2c_5;
                                                    arg1[((((rdx_56 + rdx_56) + rdx_56) * 4) + 
0x8dd)] = 0;
                                                    int64_t rdx_57 = var_2c_5;
                                                    int64_t rdx_58 = var_2c_5;
                                                    int64_t rdx_59 = var_2c_5;
                                                    arg1[((((rdx_59 + rdx_59) + rdx_59) * 4) + 
0x8db)] = stbi__malloc_mad2(*(&arg1[(((rdx_58 + rdx_58) + rdx_58) * 4)] + 0x46c4), 
arg1[((((rdx_57 + rdx_57) + rdx_57) * 4) + 0x8d9)], 0xf);
                                                    int64_t rdx_60 = var_2c_5;
                                                    if (arg1[((((rdx_60 + rdx_60) + rdx_60) * 
4) + 0x8db)] == 0)
                                                    {
                                                        stbi__err("outofmem");
                                                        rax_4 = 
stbi__free_jpeg_components(arg1, (var_2c_5 + 1), 0);
                                                        break;
                                                    }
                                                    int64_t rdx_61 = var_2c_5;
                                                    int64_t rdx_62 = var_2c_5;
                                                    arg1[((((rdx_62 + rdx_62) + rdx_62) * 4) + 
0x8da)] = ((arg1[((((rdx_61 + rdx_61) + rdx_61) * 4) + 0x8db)] + 0xf) & 0xfffffffffffffff0);
                                                    if (arg1[0x906] != 0)  // 
{"rTMCloneTable"}
                                                    {
                                                        int64_t rdx_63 = var_2c_5;
                                                        int32_t rax_381 = *(&arg1[(((rdx_63 + 
rdx_63) + rdx_63) * 4)] + 0x46c4);
                                                        if (rax_381 < 0)
                                                        {
                                                            rax_381 = (rax_381 + 7);
                                                        }
                                                        int64_t rdx_65 = var_2c_5;
                                                        arg1[((((rdx_65 + rdx_65) + rdx_65) * 
4) + 0x8df)] = (rax_381 >> 3);
                                                        int64_t rdx_66 = var_2c_5;
                                                        int32_t rax_397 = arg1[((((rdx_66 + 
rdx_66) + rdx_66) * 4) + 0x8d9)];
                                                        if (rax_397 < 0)
                                                        {
                                                            rax_397 = (rax_397 + 7);
                                                        }
                                                        int64_t rdx_68 = var_2c_5;
                                                        *(&arg1[(((rdx_68 + rdx_68) + rdx_68) 
* 4)] + 0x46fc) = (rax_397 >> 3);
                                                        int64_t rdx_69 = var_2c_5;
                                                        int64_t rdx_70 = var_2c_5;
                                                        int64_t rdx_71 = var_2c_5;
                                                        arg1[((((rdx_71 + rdx_71) + rdx_71) * 
4) + 0x8dc)] = stbi__malloc_mad3(*(&arg1[(((rdx_70 + rdx_70) + rdx_70) * 4)] + 0x46c4), 
arg1[((((rdx_69 + rdx_69) + rdx_69) * 4) + 0x8d9)], 2, 0xf);
                                                        int64_t rdx_72 = var_2c_5;
                                                        if (arg1[((((rdx_72 + rdx_72) + 
rdx_72) * 4) + 0x8dc)] == 0)
                                                        {
                                                            stbi__err("outofmem");
                                                            rax_4 = 
stbi__free_jpeg_components(arg1, (var_2c_5 + 1), 0);
                                                            break;
                                                        }
                                                        int64_t rdx_73 = var_2c_5;
                                                        int64_t rdx_74 = var_2c_5;
                                                        arg1[((((rdx_74 + rdx_74) + rdx_74) * 
4) + 0x8de)] = ((arg1[((((rdx_73 + rdx_73) + rdx_73) * 4) + 0x8dc)] + 0xf) & 
0xfffffffffffffff0);
                                                    }
                                                    var_2c_5 = (var_2c_5 + 1);
                                                }
                                                break;
                                            }
                                            int64_t rdx_28 = var_2c_4;
                                            int32_t temp3_1;
                                            int32_t temp4_1;
                                            temp3_1 = HIGHD(var_28);
                                            temp4_1 = LOWD(var_28);
                                            if ((COMBINE(temp3_1, temp4_1) % *(&arg1[(((rdx_28 
+ rdx_28) + rdx_28) * 4)] + 0x46a4)) != 0)
                                            {
                                                rax_4 = stbi__err("bad H");
                                                break;
                                            }
                                            int64_t rdx_31 = var_2c_4;
                                            int32_t temp17_1;
                                            int32_t temp18_1;
                                            temp17_1 = HIGHD(var_24);
                                            temp18_1 = LOWD(var_24);
                                            if ((COMBINE(temp17_1, temp18_1) % arg1[((((rdx_31 
+ rdx_31) + rdx_31) * 4) + 0x8d5)]) != 0)
                                            {
                                                rax_4 = stbi__err("bad V");
                                                break;
                                            }
                                            var_2c_4 = (var_2c_4 + 1);
                                        }
                                    }
                                }
                                break;
                            }
                            int64_t rdx_7 = var_2c_2;
                            arg1[((((rdx_7 + rdx_7) + rdx_7) * 4) + 0x8d4)] = 
stbi__get8(rax_1);
                            if (*(rax_1 + 8) == 3)
                            {
                                int64_t rdx_8 = var_2c_2;
                                if (arg1[((((rdx_8 + rdx_8) + rdx_8) * 4) + 0x8d4)] == 
*"RGBbad SOF len"[var_2c_2])
                                {
                                    arg1[0x90a] = (arg1[0x90a] + 1);  // {"loneTable"}
                                }
                            }
                            uint32_t rax_74 = stbi__get8(rax_1);
                            int64_t rdx_11 = var_2c_2;
                            *(&arg1[(((rdx_11 + rdx_11) + rdx_11) * 4)] + 0x46a4) = (rax_74 >> 
4);
                            int64_t rdx_12 = var_2c_2;
                            if (*(&arg1[(((rdx_12 + rdx_12) + rdx_12) * 4)] + 0x46a4) != 0)
                            {
                                int64_t rdx_13 = var_2c_2;
                                if (*(&arg1[(((rdx_13 + rdx_13) + rdx_13) * 4)] + 0x46a4) <= 
4)
                                {
                                    int64_t rdx_14 = var_2c_2;
                                    arg1[((((rdx_14 + rdx_14) + rdx_14) * 4) + 0x8d5)] = 
(rax_74 & 0xf);
                                    int64_t rdx_15 = var_2c_2;
                                    if (arg1[((((rdx_15 + rdx_15) + rdx_15) * 4) + 0x8d5)] != 
0)
                                    {
                                        int64_t rdx_16 = var_2c_2;
                                        if (arg1[((((rdx_16 + rdx_16) + rdx_16) * 4) + 0x8d5)] 
<= 4)
                                        {
                                            int64_t rdx_17 = var_2c_2;
                                            *(&arg1[(((rdx_17 + rdx_17) + rdx_17) * 4)] + 
0x46ac) = stbi__get8(rax_1);
                                            int64_t rdx_18 = var_2c_2;
                                            if (*(&arg1[(((rdx_18 + rdx_18) + rdx_18) * 4)] + 
0x46ac) > 3)
                                            {
                                                rax_4 = stbi__err("bad TQ");
                                                break;
                                            }
                                            var_2c_2 = (var_2c_2 + 1);
                                            continue;
                                        }
                                    }
                                    rax_4 = stbi__err("bad V");
                                    break;
                                }
                            }
                            rax_4 = stbi__err("bad H");
                            break;
                        }
                    }
                }
                if (((rax_24 != 3 && rax_24 != 1) && rax_24 != 4))
                {
                    rax_4 = stbi__err("bad component count");
                }
            }
        }
    }
    return rax_4;
}

int64_t stbi__decode_jpeg_header(int64_t* arg1, int32_t arg2)
{
    arg1[0x909] = 0;  // {"CloneTable"}
    *(arg1 + 0x484c) = 0xffffffff;
    arg1[0x905] = 0xff;  // {"erTMCloneTable"}
    int64_t rax_6;
    if (stbi__get_marker(arg1) != 0xd8)
    {
        rax_6 = stbi__err("no SOI");
    }
    else if (arg2 == 1)
    {
        rax_6 = 1;
    }
    else
    {
        uint32_t var_c_1 = stbi__get_marker(arg1);
        while (true)
        {
            if ((var_c_1 != 0xc0 && (var_c_1 != 0xc1 && var_c_1 != 0xc2)))
            {
                int32_t rax_11;
                rax_11 = stbi__process_marker(arg1, var_c_1) == 0;
                if (rax_11 != 0)
                {
                    rax_6 = 0;
                    break;
                }
                for (var_c_1 = stbi__get_marker(arg1); var_c_1 == 0xff; var_c_1 = 
stbi__get_marker(arg1))
                {
                    int32_t rax_16;
                    rax_16 = stbi__at_eof(*arg1) != 0;
                    if (rax_16 != 0)
                    {
                        break;
                    }
                }
                if (var_c_1 == 0xff)
                {
                    rax_6 = stbi__err("no SOF");
                    break;
                }
                continue;
            }
            uint32_t rax_9;
            rax_9 = var_c_1 == 0xc2;
            arg1[0x906] = rax_9;  // {"rTMCloneTable"}
            int32_t rax_21;
            rax_21 = stbi__process_frame_header(arg1, arg2) == 0;
            if (rax_21 == 0)
            {
                rax_6 = 1;
            }
            else
            {
                rax_6 = 0;
            }
            break;
        }
    }
    return rax_6;
}

uint64_t stbi__skip_jpeg_junk_at_end(int64_t* arg1)
{
    while (true)
    {
        int32_t rax_15;
        rax_15 = stbi__at_eof(*arg1) == 0;
        if (rax_15 == 0)
        {
            break;
        }
        uint32_t var_c_1 = stbi__get8(*arg1);
        while (var_c_1 == 0xff)
        {
            int32_t rax_7;
            rax_7 = stbi__at_eof(*arg1) != 0;
            if (rax_7 != 0)
            {
                return 0xff;
            }
            var_c_1 = stbi__get8(*arg1);
            if (var_c_1 != 0)
            {
                if (var_c_1 != 0xff)
                {
                    return var_c_1;
                }
            }
        }
    }
    return 0xff;
}

int64_t stbi__decode_jpeg_image(int64_t* arg1)
{
    for (int32_t var_14 = 0; var_14 <= 3; var_14 = (var_14 + 1))
    {
        int64_t rdx_1 = var_14;
        arg1[((((rdx_1 + rdx_1) + rdx_1) * 4) + 0x8db)] = 0;
        int64_t rdx_2 = var_14;
        arg1[((((rdx_2 + rdx_2) + rdx_2) * 4) + 0x8dc)] = 0;
    }
    arg1[0x90d] = 0;  // {"eTable"}
    int32_t rax_17;
    rax_17 = stbi__decode_jpeg_header(arg1, 0) == 0;
    int64_t rax_18;
    if (rax_17 != 0)
    {
        rax_18 = 0;
    }
    else
    {
        uint32_t var_14_1 = stbi__get_marker(arg1);
        while (true)
        {
            if (var_14_1 == 0xd9)
            {
                if (arg1[0x906] != 0)  // {"rTMCloneTable"}
                {
                    stbi__jpeg_finish(arg1);
                }
                rax_18 = 1;
                break;
            }
            if (var_14_1 == 0xda)
            {
                int32_t rax_23;
                rax_23 = stbi__process_scan_header(arg1) == 0;
                if (rax_23 != 0)
                {
                    rax_18 = 0;
                    break;
                }
                int32_t rax_25;
                rax_25 = stbi__parse_entropy_coded_data(arg1) == 0;
                if (rax_25 != 0)
                {
                    rax_18 = 0;
                    break;
                }
                if (arg1[0x905] == 0xff)  // {"erTMCloneTable"}
                {
                    arg1[0x905] = stbi__skip_jpeg_junk_at_end(arg1);  // {"erTMCloneTable"}
                }
                var_14_1 = stbi__get_marker(arg1);
                if ((var_14_1 > 0xcf && var_14_1 <= 0xd7))
                {
                    var_14_1 = stbi__get_marker(arg1);
                }
            }
            else if (var_14_1 != 0xdc)
            {
                int32_t rax_50;
                rax_50 = stbi__process_marker(arg1, var_14_1) == 0;
                if (rax_50 != 0)
                {
                    rax_18 = 1;
                    break;
                }
                var_14_1 = stbi__get_marker(arg1);
            }
            else
            {
                int32_t rax_39 = stbi__get16be(*arg1);
                int32_t rax_42 = stbi__get16be(*arg1);
                if (rax_39 != 4)
                {
                    rax_18 = stbi__err("bad DNL len");
                    break;
                }
                if (rax_42 != *(*arg1 + 4))
                {
                    rax_18 = stbi__err("bad DNL height");
                    break;
                }
                var_14_1 = stbi__get_marker(arg1);
            }
        }
    }
    return rax_18;
}

int64_t resample_row_1(int64_t arg1, int64_t arg2)
{
    int64_t var_10 = arg1;
    int64_t rdx;
    int64_t var_20 = rdx;
    int32_t rcx;
    int32_t var_24 = rcx;
    int32_t r8;
    int32_t var_28 = r8;
    return arg2;
}

void* stbi__resample_row_v_2(void* arg1, void* arg2, void* arg3, int32_t arg4)
{
    int32_t r8;
    int32_t var_38 = r8;
    for (int32_t var_c = 0; var_c < arg4; var_c = (var_c + 1))
    {
        uint32_t rdx_1 = *(arg2 + var_c);
        *(arg1 + var_c) = (((*(arg3 + var_c) + ((rdx_1 + rdx_1) + rdx_1)) + 2) >> 2);
    }
    return arg1;
}

char* stbi__resample_row_h_2(char* arg1, char* arg2, int64_t arg3, int32_t arg4)
{
    int64_t var_30 = arg3;
    int32_t r8;
    int32_t var_38 = r8;
    char* rax_4;
    if (arg4 == 1)
    {
        arg1[1] = *arg2;
        *arg1 = arg1[1];
        rax_4 = arg1;
    }
    else
    {
        *arg1 = *arg2;
        uint32_t rdx_4 = *arg2;
        arg1[1] = (((arg2[1] + (rdx_4 + (rdx_4 + rdx_4))) + 2) >> 2);
        int32_t var_18_1;
        for (var_18_1 = 1; var_18_1 < (arg4 - 1); var_18_1 = (var_18_1 + 1))
        {
            uint32_t rdx_8 = arg2[var_18_1];
            arg1[(var_18_1 + var_18_1)] = (((((rdx_8 + rdx_8) + rdx_8) + 2) + arg2[(var_18_1 - 
1)]) >> 2);
            arg1[((var_18_1 + var_18_1) + 1)] = (((((rdx_8 + rdx_8) + rdx_8) + 2) + 
arg2[(var_18_1 + 1)]) >> 2);
        }
        uint32_t rdx_18 = arg2[(arg4 - 2)];
        arg1[(var_18_1 + var_18_1)] = (((arg2[(arg4 - 1)] + (rdx_18 + (rdx_18 + rdx_18))) + 2) 
>> 2);
        arg1[((var_18_1 + var_18_1) + 1)] = arg2[(arg4 - 1)];
        rax_4 = arg1;
    }
    return rax_4;
}

char* stbi__resample_row_hv_2(char* arg1, char* arg2, char* arg3, int32_t arg4)
{
    int32_t r8;
    int32_t var_38 = r8;
    char* rax_13;
    if (arg4 == 1)
    {
        uint32_t rdx = *arg2;
        arg1[1] = (((*arg3 + (rdx + (rdx + rdx))) + 2) >> 2);
        *arg1 = arg1[1];
        rax_13 = arg1;
    }
    else
    {
        uint32_t rdx_4 = *arg2;
        uint32_t var_10_1 = (*arg3 + (rdx_4 + (rdx_4 + rdx_4)));
        *arg1 = ((var_10_1 + 2) >> 2);
        for (int32_t var_14_1 = 1; var_14_1 < arg4; var_14_1 = (var_14_1 + 1))
        {
            uint32_t var_c_1 = var_10_1;
            uint32_t rdx_8 = arg2[var_14_1];
            var_10_1 = (arg3[var_14_1] + ((rdx_8 + rdx_8) + rdx_8));
            arg1[((var_14_1 + var_14_1) - 1)] = (((var_10_1 + (var_c_1 + (var_c_1 + var_c_1))) 
+ 8) >> 4);
            arg1[(var_14_1 + var_14_1)] = (((var_c_1 + (var_10_1 + (var_10_1 + var_10_1))) + 
8) >> 4);
        }
        arg1[((arg4 + arg4) - 1)] = ((var_10_1 + 2) >> 2);
        rax_13 = arg1;
    }
    return rax_13;
}

char* stbi__resample_row_hv_2_simd(char* arg1, char* arg2, char* arg3, 
    int32_t arg4)
{
    int32_t r8;
    int32_t var_408 = r8;
    int32_t var_3cc = 0;
    char* rax_13;
    if (arg4 == 1)
    {
        uint32_t rdx = *arg2;
        arg1[1] = (((*arg3 + (rdx + (rdx + rdx))) + 2) >> 2);
        *arg1 = arg1[1];
        rax_13 = arg1;
    }
    else
    {
        uint32_t rdx_4 = *arg2;
        uint32_t var_3c8_1 = (*arg3 + (rdx_4 + (rdx_4 + rdx_4)));
        for (; var_3cc < ((arg4 - 1) & 0xfffffff8); var_3cc = (var_3cc + 8))
        {
            int32_t var_358_1[0x4] = {0};
            int32_t temp0_1[0x4] = _mm_unpacklo_epi64(*(arg3 + var_3cc), 0);
            int32_t temp0_2[0x4] = _mm_unpacklo_epi64(*(arg2 + var_3cc), 0);
            int32_t temp0_3[0x4] = _mm_unpacklo_epi8(temp0_1, var_358_1[0]);
            int32_t temp0_4[0x4] = _mm_unpacklo_epi8(temp0_2, var_358_1[0]);
            int32_t var_2e8_1[0x4] = _mm_add_epi16(_mm_sub_epi16(temp0_3, temp0_4), 
_mm_sll_epi16(temp0_4, 2));
            int32_t var_2d8_1[0x4] = _mm_slli_si128(var_2e8_1, 2);
            int32_t var_2c8_1[0x4] = _mm_bsrli_si128(var_2e8_1, 2);
            int32_t temp0_10[0x4] = _mm_insert_epi16(var_2d8_1, var_3c8_1, 0);
            uint16_t rdx_9 = arg2[(var_3cc + 8)];
            int32_t temp0_11[0x4] = _mm_insert_epi16(var_2c8_1, (arg3[(var_3cc + 8)] + ((rdx_9 
+ rdx_9) + rdx_9)), 7);
            int16_t var_3de;
            __builtin_memcpy(var_3de, 
"\x08\x00\x08\x00\x08\x00\x08\x00\x08\x00\x08\x00\x08\x00\x08\x00\x08\x00", 0x12);
            int32_t temp0_12[0x4] = _mm_insert_epi16(8, 8, 1);
            int64_t zmm4 = _mm_insert_epi16(8, 8, 1)[0];
            int32_t temp0_14[0x4] = _mm_insert_epi16(8, 8, 1);
            int64_t zmm3 = _mm_insert_epi16(8, 8, 1)[0];
            int32_t temp0_18[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_12, zmm4), 
_mm_unpacklo_epi32(temp0_14, zmm3)[0]);
            int32_t var_288_1[0x4] = _mm_sll_epi16(var_2e8_1, 2);
            int32_t temp0_20[0x4] = _mm_sub_epi16(temp0_10, var_2e8_1);
            int32_t temp0_21[0x4] = _mm_sub_epi16(temp0_11, var_2e8_1);
            int32_t var_258_1[0x4] = _mm_add_epi16(temp0_18, var_288_1);
            int32_t var_248_1[0x4] = _mm_add_epi16(var_258_1, temp0_20);
            int32_t var_238_1[0x4] = _mm_add_epi16(var_258_1, temp0_21);
            int32_t temp0_25[0x4] = _mm_unpacklo_epi16(var_248_1, var_238_1[0]);
            int32_t temp0_26[0x4] = _mm_unpackhi_epi16(var_248_1, var_238_1[0]);
            *(arg1 + (var_3cc + var_3cc)) = _mm_packus_epi16(_mm_srl_epi16(temp0_25, 4), 
_mm_srl_epi16(temp0_26, 4));
            uint32_t rdx_13 = arg2[(var_3cc + 7)];
            var_3c8_1 = (arg3[(var_3cc + 7)] + (rdx_13 + (rdx_13 + rdx_13)));
        }
        uint32_t rdx_16 = arg2[var_3cc];
        uint32_t var_3c8_2 = (arg3[var_3cc] + ((rdx_16 + rdx_16) + rdx_16));
        arg1[(var_3cc + var_3cc)] = (((var_3c8_1 + (var_3c8_2 + (var_3c8_2 + var_3c8_2))) + 8) 
>> 4);
        for (int32_t var_3cc_1 = (var_3cc + 1); var_3cc_1 < arg4; var_3cc_1 = (var_3cc_1 + 1))
        {
            uint32_t var_3c4_2 = var_3c8_2;
            uint32_t rdx_23 = arg2[var_3cc_1];
            var_3c8_2 = (arg3[var_3cc_1] + ((rdx_23 + rdx_23) + rdx_23));
            arg1[((var_3cc_1 + var_3cc_1) - 1)] = (((var_3c8_2 + (var_3c4_2 + (var_3c4_2 + 
var_3c4_2))) + 8) >> 4);
            arg1[(var_3cc_1 + var_3cc_1)] = (((var_3c4_2 + (var_3c8_2 + (var_3c8_2 + 
var_3c8_2))) + 8) >> 4);
        }
        arg1[((arg4 + arg4) - 1)] = ((var_3c8_2 + 2) >> 2);
        rax_13 = arg1;
    }
    return rax_13;
}

int64_t stbi__resample_row_generic(int64_t arg1, int64_t arg2, int64_t arg3, 
    int32_t arg4, int32_t arg5)
{
    int64_t var_30 = arg3;
    for (int32_t var_10 = 0; var_10 < arg4; var_10 = (var_10 + 1))
    {
        for (int32_t var_c_1 = 0; var_c_1 < arg5; var_c_1 = (var_c_1 + 1))
        {
            *((var_c_1 + (var_10 * arg5)) + arg1) = *(var_10 + arg2);
        }
    }
    return arg1;
}

uint64_t stbi__YCbCr_to_RGB_row(char* arg1, void* arg2, void* arg3, void* arg4, 
    int32_t arg5, int32_t arg6)
{
    char* var_30 = arg1;
    int32_t var_24 = 0;
    uint64_t rax_45;
    while (true)
    {
        rax_45 = var_24;
        if (rax_45 >= arg5)
        {
            break;
        }
        int32_t rax_7 = ((*(arg2 + var_24) << 0x14) + 0x80000);
        int32_t rax_13 = (*(arg4 + var_24) - 0x80);
        int32_t rax_27;
        rax_27 = 0;
        int32_t var_20_2 = ((rax_7 + (rax_13 * 0x166f00)) >> 0x14);
        int32_t var_1c_2 = ((rax_27 + (rax_7 + (rax_13 * 0xfff49300))) >> 0x14);
        int32_t var_18_2 = ((rax_7 + ((*(arg3 + var_24) - 0x80) * 0x1c5a00)) >> 0x14);
        if (var_20_2 > 0xff)
        {
            if (var_20_2 >= 0)
            {
                var_20_2 = 0xff;
            }
            else
            {
                var_20_2 = 0;
            }
        }
        if (var_1c_2 > 0xff)
        {
            if (var_1c_2 >= 0)
            {
                var_1c_2 = 0xff;
            }
            else
            {
                var_1c_2 = 0;
            }
        }
        if (var_18_2 > 0xff)
        {
            if (var_18_2 >= 0)
            {
                var_18_2 = 0xff;
            }
            else
            {
                var_18_2 = 0;
            }
        }
        *var_30 = var_20_2;
        var_30[1] = var_1c_2;
        var_30[2] = var_18_2;
        var_30[3] = 0xff;
        var_30 = &var_30[arg6];
        var_24 = (var_24 + 1);
    }
    return rax_45;
}

uint64_t stbi__YCbCr_to_RGB_simd(void* arg1, void* arg2, void* arg3, 
    void* arg4, int32_t arg5, int32_t arg6)
{
    void* var_640 = arg1;
    int32_t var_5bc = 0;
    if (arg6 == 4)
    {
        int32_t var_678_1 = 0xffffff80;
        int32_t var_664_1 = 0xffffff80;
        var_678_1 = -0x7f7f7f7f7f7f7f80;
        int64_t var_670_1 = -0x7f7f7f7f7f7f7f80;
        int32_t var_508_1[0x4] = var_678_1;
        int32_t temp0_1[0x4] = _mm_insert_epi16(0x166f, 0x166f, 1);
        int64_t zmm4 = _mm_insert_epi16(0x166f, 0x166f, 1)[0];
        int32_t temp0_3[0x4] = _mm_insert_epi16(0x166f, 0x166f, 1);
        int64_t zmm3 = _mm_insert_epi16(0x166f, 0x166f, 1)[0];
        int32_t temp0_7[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_1, zmm4), 
_mm_unpacklo_epi32(temp0_3, zmm3)[0]);
        int32_t temp0_8[0x4] = _mm_insert_epi16(0xf493, 0xf493, 1);
        zmm4 = _mm_insert_epi16(0xf493, 0xf493, 1)[0];
        int32_t temp0_10[0x4] = _mm_insert_epi16(0xf493, 0xf493, 1);
        zmm3 = _mm_insert_epi16(0xf493, 0xf493, 1)[0];
        int32_t temp0_14[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_8, zmm4), 
_mm_unpacklo_epi32(temp0_10, zmm3)[0]);
        int32_t temp0_15[0x4] = _mm_insert_epi16(0xfa7e, 0xfa7e, 1);
        zmm4 = _mm_insert_epi16(0xfa7e, 0xfa7e, 1)[0];
        int32_t temp0_17[0x4] = _mm_insert_epi16(0xfa7e, 0xfa7e, 1);
        zmm3 = _mm_insert_epi16(0xfa7e, 0xfa7e, 1)[0];
        int32_t temp0_21[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_15, zmm4), 
_mm_unpacklo_epi32(temp0_17, zmm3)[0]);
        int32_t temp0_22[0x4] = _mm_insert_epi16(0x1c5a, 0x1c5a, 1);
        zmm4 = _mm_insert_epi16(0x1c5a, 0x1c5a, 1)[0];
        int32_t temp0_24[0x4] = _mm_insert_epi16(0x1c5a, 0x1c5a, 1);
        zmm3 = _mm_insert_epi16(0x1c5a, 0x1c5a, 1)[0];
        int32_t temp0_28[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_22, zmm4), 
_mm_unpacklo_epi32(temp0_24, zmm3)[0]);
        char var_638;
        __builtin_memset(var_638, 0x80, 0x22);
        int32_t var_678_2 = 0xffffff80;
        int32_t var_664_2 = 0xffffff80;
        var_678_2 = -0x7f7f7f7f7f7f7f80;
        int64_t var_670_2 = -0x7f7f7f7f7f7f7f80;
        int16_t var_616;
        __builtin_memcpy(var_616, 
"\xff\x00\xff\x00\xff\x00\xff\x00\xff\x00\xff\x00\xff\x00\xff\x00\xff\x00Z\x1cZ\x1cZ\x1cZ\x1cZ\x1cZ\x1cZ\x1cZ\x1cZ\x1c~\xfa~\xfa~\xfa~\xfa~\xfa~\xfa~\xfa~\xfa~\xfa\x93\xf4\x93\xf4\x93\xf4\x93\xf4\x93\xf4\x93\xf4\x93\xf4\x93\xf4\x93\xf4o\x16o\x16o\x16o\x16o\x16o\x16o\x16o\x16o\x16", 
0x5a);
        int32_t temp0_29[0x4] = _mm_insert_epi16(0xff, 0xff, 1);
        zmm4 = _mm_insert_epi16(0xff, 0xff, 1)[0];
        int32_t temp0_31[0x4] = _mm_insert_epi16(0xff, 0xff, 1);
        zmm3 = _mm_insert_epi16(0xff, 0xff, 1)[0];
        int32_t temp0_35[0x4] = _mm_unpacklo_epi64(_mm_unpacklo_epi32(temp0_29, zmm4), 
_mm_unpacklo_epi32(temp0_31, zmm3)[0]);
        while (arg5 > (var_5bc + 7))
        {
            int32_t temp0_36[0x4] = _mm_unpacklo_epi64(*(arg2 + var_5bc), 0);
            int32_t temp0_37[0x4] = _mm_unpacklo_epi64(*(arg4 + var_5bc), 0);
            int32_t var_458_1[0x4] = (var_508_1 ^ _mm_unpacklo_epi64(*(arg3 + var_5bc), 0));
            int32_t temp0_39[0x4] = _mm_unpacklo_epi8(var_678_2, temp0_36[0]);
            int128_t var_b8_1 = {0};
            int32_t temp0_40[0x4] = _mm_unpacklo_epi8({0}, (var_508_1 ^ temp0_37)[0]);
            int128_t var_d8_1 = {0};
            int32_t temp0_41[0x4] = _mm_unpacklo_epi8({0}, var_458_1[0]);
            int32_t temp0_42[0x4] = _mm_srl_epi16(temp0_39, 4);
            int32_t var_408_1[0x4] = _mm_mulhi_epi16(temp0_40, temp0_7);
            int32_t var_3f8_1[0x4] = _mm_mulhi_epi16(temp0_41, temp0_21);
            int32_t var_3e8_1[0x4] = _mm_mulhi_epi16(temp0_28, temp0_41);
            int32_t var_3d8_1[0x4] = _mm_mulhi_epi16(temp0_14, temp0_40);
            int32_t var_3c8_1[0x4] = _mm_add_epi16(temp0_42, var_408_1);
            int32_t var_3b8_1[0x4] = _mm_add_epi16(temp0_42, var_3f8_1);
            int32_t var_3a8_1[0x4] = _mm_add_epi16(var_3e8_1, temp0_42);
            int32_t var_398_1[0x4] = _mm_add_epi16(var_3d8_1, var_3b8_1);
            int32_t var_388_1[0x4] = _mm_sra_epi16(var_3c8_1, 4);
            int32_t var_378_1[0x4] = _mm_sra_epi16(var_3a8_1, 4);
            int32_t var_368_1[0x4] = _mm_sra_epi16(var_398_1, 4);
            int32_t var_358_1[0x4] = _mm_packus_epi16(var_388_1, var_378_1);
            int32_t var_348_1[0x4] = _mm_packus_epi16(var_368_1, temp0_35);
            int32_t temp0_56[0x4] = _mm_unpacklo_epi8(var_358_1, var_348_1[0]);
            int32_t temp0_57[0x4] = _mm_unpackhi_epi8(var_358_1, var_348_1[0]);
            int32_t temp0_58[0x4] = _mm_unpacklo_epi16(temp0_56, temp0_57[0]);
            int32_t temp0_59[0x4] = _mm_unpackhi_epi16(temp0_56, temp0_57[0]);
            *var_640 = temp0_58;
            *(var_640 + 0x10) = temp0_59;
            var_640 = (var_640 + 0x20);
            var_5bc = (var_5bc + 8);
        }
    }
    uint64_t rax_70;
    while (true)
    {
        rax_70 = var_5bc;
        if (rax_70 >= arg5)
        {
            break;
        }
        int32_t rax_32 = ((*(arg2 + var_5bc) << 0x14) + 0x80000);
        int32_t rax_38 = (*(arg4 + var_5bc) - 0x80);
        int32_t rax_52;
        rax_52 = 0;
        int32_t var_5b8_2 = ((rax_32 + (rax_38 * 0x166f00)) >> 0x14);
        int32_t var_5b4_2 = ((rax_52 + (rax_32 + (rax_38 * 0xfff49300))) >> 0x14);
        int32_t var_5b0_2 = ((rax_32 + ((*(arg3 + var_5bc) - 0x80) * 0x1c5a00)) >> 0x14);
        if (var_5b8_2 > 0xff)
        {
            if (var_5b8_2 >= 0)
            {
                var_5b8_2 = 0xff;
            }
            else
            {
                var_5b8_2 = 0;
            }
        }
        if (var_5b4_2 > 0xff)
        {
            if (var_5b4_2 >= 0)
            {
                var_5b4_2 = 0xff;
            }
            else
            {
                var_5b4_2 = 0;
            }
        }
        if (var_5b0_2 > 0xff)
        {
            if (var_5b0_2 >= 0)
            {
                var_5b0_2 = 0xff;
            }
            else
            {
                var_5b0_2 = 0;
            }
        }
        *var_640 = var_5b8_2;
        *(var_640 + 1) = var_5b4_2;
        *(var_640 + 2) = var_5b0_2;
        *(var_640 + 3) = 0xff;
        var_640 = (var_640 + arg6);
        var_5bc = (var_5bc + 1);
    }
    return rax_70;
}

void* stbi__setup_jpeg(void* arg1)
{
    *(arg1 + 0x4870) = stbi__idct_block;
    *(arg1 + 0x4878) = stbi__YCbCr_to_RGB_row;
    *(arg1 + 0x4880) = stbi__resample_row_hv_2;
    void* rax_3;
    rax_3 = true;
    *(arg1 + 0x4870) = stbi__idct_simd;
    *(arg1 + 0x4878) = stbi__YCbCr_to_RGB_simd;
    *(arg1 + 0x4880) = stbi__resample_row_hv_2_simd;
    return arg1;
}

uint64_t stbi__cleanup_jpeg(int64_t* arg1)
{
    return stbi__free_jpeg_components(arg1, *(*arg1 + 8), 0);
}

uint64_t stbi__blinn_8x8(char arg1, char arg2)
{
    return ((((arg2 * arg1) - 0xffffff80) + (((arg2 * arg1) - 0xffffff80) >> 8)) >> 8);
}

int64_t load_jpeg_image(int64_t* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    *(*arg1 + 8) = 0;
    int64_t rax_3;
    if ((arg5 < 0 || (arg5 >= 0 && arg5 > 4)))
    {
        stbi__err("bad req_comp");
        rax_3 = 0;
    }
    if ((arg5 >= 0 && arg5 <= 4))
    {
        int32_t rax_5;
        rax_5 = stbi__decode_jpeg_image(arg1) == 0;
        if (rax_5 != 0)
        {
            stbi__cleanup_jpeg(arg1);
            rax_3 = 0;
        }
        else
        {
            int32_t rax_10;
            if (arg5 != 0)
            {
                rax_10 = arg5;
            }
            else if (*(*arg1 + 8) <= 2)
            {
                rax_10 = 1;
            }
            else
            {
                rax_10 = 3;
            }
            char rax_20;
            if (*(*arg1 + 8) != 3)
            {
            label_10629:
                rax_20 = 0;
            }
            else
            {
                if (arg1[0x90a] != 3)  // {"loneTable"}
                {
                    if (*(arg1 + 0x484c) != 0)
                    {
                        goto label_10629;
                    }
                    if (arg1[0x909] != 0)  // {"CloneTable"}
                    {
                        goto label_10629;
                    }
                }
                rax_20 = 1;
            }
            uint32_t rax_21 = rax_20;
            int32_t var_154_1;
            if (((*(*arg1 + 8) != 3 || (*(*arg1 + 8) == 3 && rax_10 > 2)) || ((*(*arg1 + 8) == 
3 && rax_10 <= 2) && rax_21 != 0)))
            {
                var_154_1 = *(*arg1 + 8);
            }
            if (((*(*arg1 + 8) == 3 && rax_10 <= 2) && rax_21 == 0))
            {
                var_154_1 = 1;
            }
            if (var_154_1 <= 0)
            {
                stbi__cleanup_jpeg(arg1);
                rax_3 = 0;
            }
            else
            {
                int64_t var_108;
                __builtin_memset(var_108, 0, 0x20);
                int32_t var_150_1 = 0;
                while (true)
                {
                    void var_e8;
                    if (var_150_1 >= var_154_1)
                    {
                        int64_t rax_136 = stbi__malloc_mad3(rax_10, **arg1, *(*arg1 + 4), 1);
                        if (rax_136 == 0)
                        {
                            stbi__cleanup_jpeg(arg1);
                            stbi__err("outofmem");
                            rax_3 = 0;
                        }
                        else
                        {
                            for (int32_t var_148_1 = 0; var_148_1 < *(*arg1 + 4); var_148_1 = 
(var_148_1 + 1))
                            {
                                char* var_138_1 = (rax_136 + ((rax_10 * **arg1) * var_148_1));
                                for (int32_t var_150_2 = 0; var_150_2 < var_154_1; var_150_2 = 
(var_150_2 + 1))
                                {
                                    int64_t rdx_20 = var_150_2;
                                    void* rax_150 = ((((rdx_20 + rdx_20) + rdx_20) << 4) + 
&var_e8);
                                    int32_t rax_154;
                                    rax_154 = *(rax_150 + 0x24) >= (*(rax_150 + 0x1c) >> 1);
                                    int64_t rsi_4;
                                    if (rax_154 == 0)
                                    {
                                        rsi_4 = *(rax_150 + 8);
                                    }
                                    else
                                    {
                                        rsi_4 = *(rax_150 + 0x10);
                                    }
                                    int64_t rcx_6 = var_150_2;
                                    &var_108[var_150_2] = *rax_150(arg1[((((rcx_6 + rcx_6) + 
rcx_6) * 4) + 0x8dd)], rsi_4);
                                    *(rax_150 + 0x24) = (*(rax_150 + 0x24) + 1);
                                    int32_t rax_173;
                                    rax_173 = *(rax_150 + 0x24) >= *(rax_150 + 0x1c);
                                    if (rax_173 != 0)
                                    {
                                        *(rax_150 + 0x24) = 0;
                                        *(rax_150 + 8) = *(rax_150 + 0x10);
                                        *(rax_150 + 0x28) = (*(rax_150 + 0x28) + 1);
                                        int64_t rdx_28 = var_150_2;
                                        int32_t rax_188;
                                        rax_188 = *(rax_150 + 0x28) < arg1[((((rdx_28 + 
rdx_28) + rdx_28) * 4) + 0x8d8)];
                                        if (rax_188 != 0)
                                        {
                                            int64_t rdx_29 = var_150_2;
                                            *(rax_150 + 0x10) = (*(rax_150 + 0x10) + 
*(&arg1[(((rdx_29 + rdx_29) + rdx_29) * 4)] + 0x46c4));
                                        }
                                    }
                                }
                                if (rax_10 > 2)
                                {
                                    int64_t rax_201 = var_108;
                                    if (*(*arg1 + 8) != 3)
                                    {
                                        if (*(*arg1 + 8) != 4)
                                        {
                                            for (int32_t var_14c_4 = 0; var_14c_4 < **arg1; 
var_14c_4 = (var_14c_4 + 1))
                                            {
                                                var_138_1[2] = *(rax_201 + var_14c_4);
                                                var_138_1[1] = var_138_1[2];
                                                *var_138_1 = var_138_1[1];
                                                var_138_1[3] = 0xff;
                                                var_138_1 = &var_138_1[rax_10];
                                            }
                                        }
                                        else if (*(arg1 + 0x484c) == 0)
                                        {
                                            for (int32_t var_14c_2 = 0; var_14c_2 < **arg1; 
var_14c_2 = (var_14c_2 + 1))
                                            {
                                                char rax_233 = *var_14c_2;
                                                *var_138_1 = stbi__blinn_8x8(*(var_14c_2 + 
var_108), rax_233);
                                                var_138_1[1] = stbi__blinn_8x8(*var_14c_2, 
rax_233);
                                                var_138_1[2] = stbi__blinn_8x8(*var_14c_2, 
rax_233);
                                                var_138_1[3] = 0xff;
                                                var_138_1 = &var_138_1[rax_10];
                                            }
                                        }
                                        else if (*(arg1 + 0x484c) != 2)
                                        {
                                            arg1[0x90f](var_138_1, rax_201, 0, 0, **arg1, 
rax_10);  // {"able"}
                                        }
                                        else
                                        {
                                            arg1[0x90f](var_138_1, rax_201, 0, 0, **arg1, 
rax_10);  // {"able"}
                                            for (int32_t var_14c_3 = 0; var_14c_3 < **arg1; 
var_14c_3 = (var_14c_3 + 1))
                                            {
                                                char rax_265 = *var_14c_3;
                                                *var_138_1 = stbi__blinn_8x8((!*var_138_1), 
rax_265);
                                                var_138_1[1] = 
stbi__blinn_8x8((!var_138_1[1]), rax_265);
                                                var_138_1[2] = 
stbi__blinn_8x8((!var_138_1[2]), rax_265);
                                                var_138_1 = &var_138_1[rax_10];
                                            }
                                        }
                                    }
                                    else if (rax_21 == 0)
                                    {
                                        arg1[0x90f](var_138_1, rax_201, 0, 0, **arg1, rax_10);  
// {"able"}
                                    }
                                    else
                                    {
                                        for (int32_t var_14c_1 = 0; var_14c_1 < **arg1; 
var_14c_1 = (var_14c_1 + 1))
                                        {
                                            *var_138_1 = *(rax_201 + var_14c_1);
                                            var_138_1[1] = *var_14c_1;
                                            var_138_1[2] = *var_14c_1;
                                            var_138_1[3] = 0xff;
                                            var_138_1 = &var_138_1[rax_10];
                                        }
                                    }
                                }
                                else if (rax_21 == 0)
                                {
                                    if ((*(*arg1 + 8) == 4 && *(arg1 + 0x484c) == 0))
                                    {
                                        for (int32_t var_14c_7 = 0; var_14c_7 < **arg1; 
var_14c_7 = (var_14c_7 + 1))
                                        {
                                            char rax_344 = *var_14c_7;
                                            *var_138_1 = 
stbi__compute_y(stbi__blinn_8x8(*(var_14c_7 + var_108), rax_344), stbi__blinn_8x8(*var_14c_7, 
rax_344), stbi__blinn_8x8(*var_14c_7, rax_344));
                                            var_138_1[1] = 0xff;
                                            var_138_1 = &var_138_1[rax_10];
                                        }
                                    }
                                    if ((*(*arg1 + 8) != 4 || (*(*arg1 + 8) == 4 && *(arg1 + 
0x484c) != 0)))
                                    {
                                        if ((*(*arg1 + 8) != 4 || (*(*arg1 + 8) == 4 && *(arg1 
+ 0x484c) != 2)))
                                        {
                                            int64_t rax_390 = var_108;
                                            if (rax_10 != 1)
                                            {
                                                for (int32_t var_14c_10 = 0; var_14c_10 < 
**arg1; var_14c_10 = (var_14c_10 + 1))
                                                {
                                                    void* rcx_21 = &var_138_1[1];
                                                    *var_138_1 = *(rax_390 + var_14c_10);
                                                    var_138_1 = (rcx_21 + 1);
                                                    *rcx_21 = 0xff;
                                                }
                                            }
                                            else
                                            {
                                                for (int32_t var_14c_9 = 0; var_14c_9 < 
**arg1; var_14c_9 = (var_14c_9 + 1))
                                                {
                                                    var_138_1[var_14c_9] = *(rax_390 + 
var_14c_9);
                                                }
                                            }
                                        }
                                        if ((*(*arg1 + 8) == 4 && *(arg1 + 0x484c) == 2))
                                        {
                                            for (int32_t var_14c_8 = 0; var_14c_8 < **arg1; 
var_14c_8 = (var_14c_8 + 1))
                                            {
                                                *var_138_1 = stbi__blinn_8x8((!*(var_14c_8 + 
var_108)), *var_14c_8);
                                                var_138_1[1] = 0xff;
                                                var_138_1 = &var_138_1[rax_10];
                                            }
                                        }
                                    }
                                }
                                else if (rax_10 != 1)
                                {
                                    int32_t var_14c_6 = 0;
                                    while (var_14c_6 < **arg1)
                                    {
                                        *var_138_1 = stbi__compute_y(*(var_14c_6 + var_108), 
*var_14c_6, *var_14c_6);
                                        var_138_1[1] = 0xff;
                                        var_14c_6 = (var_14c_6 + 1);
                                        var_138_1 = &var_138_1[2];
                                    }
                                }
                                else
                                {
                                    for (int32_t var_14c_5 = 0; var_14c_5 < **arg1; var_14c_5 
= (var_14c_5 + 1))
                                    {
                                        char* rax_317 = var_138_1;
                                        var_138_1 = &rax_317[1];
                                        *rax_317 = stbi__compute_y(*(var_14c_5 + var_108), 
*var_14c_5, *var_14c_5);
                                    }
                                }
                            }
                            stbi__cleanup_jpeg(arg1);
                            *arg2 = **arg1;
                            *arg3 = *(*arg1 + 4);
                            if (arg4 != 0)
                            {
                                int32_t rdx_69;
                                if (*(*arg1 + 8) <= 2)
                                {
                                    rdx_69 = 1;
                                }
                                else
                                {
                                    rdx_69 = 3;
                                }
                                *arg4 = rdx_69;
                            }
                            rax_3 = rax_136;
                        }
                        break;
                    }
                    int64_t rdx = var_150_1;
                    void* rax_34 = ((((rdx + rdx) + rdx) << 4) + &var_e8);
                    int64_t rdx_1 = var_150_1;
                    arg1[((((rdx_1 + rdx_1) + rdx_1) * 4) + 0x8dd)] = stbi__malloc((**arg1 + 
3));
                    int64_t rdx_2 = var_150_1;
                    if (arg1[((((rdx_2 + rdx_2) + rdx_2) * 4) + 0x8dd)] == 0)
                    {
                        stbi__cleanup_jpeg(arg1);
                        stbi__err("outofmem");
                        rax_3 = 0;
                        break;
                    }
                    int64_t rdx_3 = var_150_1;
                    int32_t temp5_1;
                    int32_t temp6_1;
                    temp5_1 = HIGHD(arg1[0x8d1]);
                    temp6_1 = LOWD(arg1[0x8d1]);
                    *(rax_34 + 0x18) = (COMBINE(temp5_1, temp6_1) / *(&arg1[(((rdx_3 + rdx_3) 
+ rdx_3) * 4)] + 0x46a4));
                    int64_t rdx_6 = var_150_1;
                    int32_t temp11_1;
                    int32_t temp12_1;
                    temp11_1 = HIGHD(*(arg1 + 0x468c));
                    temp12_1 = LOWD(*(arg1 + 0x468c));
                    *(rax_34 + 0x1c) = (COMBINE(temp11_1, temp12_1) / arg1[((((rdx_6 + rdx_6) 
+ rdx_6) * 4) + 0x8d5)]);
                    *(rax_34 + 0x24) = (*(rax_34 + 0x1c) >> 1);
                    *(rax_34 + 0x20) = (COMBINE(0, ((*(rax_34 + 0x18) + **arg1) - 1)) / 
*(rax_34 + 0x18));
                    *(rax_34 + 0x28) = 0;
                    int64_t rdx_13 = var_150_1;
                    *(rax_34 + 0x10) = arg1[((((rdx_13 + rdx_13) + rdx_13) * 4) + 0x8da)];
                    *(rax_34 + 8) = *(rax_34 + 0x10);
                    if ((*(rax_34 + 0x18) == 1 && *(rax_34 + 0x1c) == 1))
                    {
                        *rax_34 = resample_row_1;
                    }
                    if ((*(rax_34 + 0x18) != 1 || (*(rax_34 + 0x18) == 1 && *(rax_34 + 0x1c) 
!= 1)))
                    {
                        if ((*(rax_34 + 0x18) == 1 && *(rax_34 + 0x1c) == 2))
                        {
                            *rax_34 = stbi__resample_row_v_2;
                        }
                        if ((*(rax_34 + 0x18) != 1 || (*(rax_34 + 0x18) == 1 && *(rax_34 + 
0x1c) != 2)))
                        {
                            if ((*(rax_34 + 0x18) == 2 && *(rax_34 + 0x1c) == 1))
                            {
                                *rax_34 = stbi__resample_row_h_2;
                            }
                            if ((*(rax_34 + 0x18) != 2 || (*(rax_34 + 0x18) == 2 && *(rax_34 + 
0x1c) != 1)))
                            {
                                if ((*(rax_34 + 0x18) != 2 || (*(rax_34 + 0x18) == 2 && 
*(rax_34 + 0x1c) != 2)))
                                {
                                    *rax_34 = stbi__resample_row_generic;
                                }
                                if ((*(rax_34 + 0x18) == 2 && *(rax_34 + 0x1c) == 2))
                                {
                                    *rax_34 = arg1[0x910];  // {"ble"}
                                }
                            }
                        }
                    }
                    var_150_1 = (var_150_1 + 1);
                }
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_3;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__jpeg_load(int64_t arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5)
{
    int64_t r9;
    int64_t var_48 = r9;
    int64_t* rax = stbi__malloc(0x4888);
    int64_t rax_1;
    if (rax != 0)
    {
        memset(rax, 0, 0x4888);
        *rax = arg1;
        stbi__setup_jpeg(rax);
        int64_t rax_6 = load_jpeg_image(rax, arg2, arg3, arg4, arg5);
        free(rax);
        rax_1 = rax_6;
    }
    else
    {
        stbi__err("outofmem");
        rax_1 = 0;
    }
    return rax_1;
}

uint64_t stbi__jpeg_test(void* arg1)
{
    int64_t* rax = stbi__malloc(0x4888);
    uint64_t rax_1;
    if (rax != 0)
    {
        memset(rax, 0, 0x4888);
        *rax = arg1;
        stbi__setup_jpeg(rax);
        int32_t rax_6 = stbi__decode_jpeg_header(rax, 1);
        stbi__rewind(arg1);
        free(rax);
        rax_1 = rax_6;
    }
    else
    {
        rax_1 = stbi__err("outofmem");
    }
    return rax_1;
}

int64_t stbi__jpeg_info_raw(int64_t* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4)
{
    int32_t rax_1;
    rax_1 = stbi__decode_jpeg_header(arg1, 2) == 0;
    int64_t rax_4;
    if (rax_1 != 0)
    {
        stbi__rewind(*arg1);
        rax_4 = 0;
    }
    else
    {
        if (arg2 != 0)
        {
            *arg2 = **arg1;
        }
        if (arg3 != 0)
        {
            *arg3 = *(*arg1 + 4);
        }
        if (arg4 != 0)
        {
            int32_t rdx_2;
            if (*(*arg1 + 8) <= 2)
            {
                rdx_2 = 1;
            }
            else
            {
                rdx_2 = 3;
            }
            *arg4 = rdx_2;
        }
        rax_4 = 1;
    }
    return rax_4;
}

uint64_t stbi__jpeg_info(int64_t arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4)
{
    int64_t* rax = stbi__malloc(0x4888);
    uint64_t rax_1;
    if (rax != 0)
    {
        memset(rax, 0, 0x4888);
        *rax = arg1;
        int32_t rax_5 = stbi__jpeg_info_raw(rax, arg2, arg3, arg4);
        free(rax);
        rax_1 = rax_5;
    }
    else
    {
        rax_1 = stbi__err("outofmem");
    }
    return rax_1;
}

uint64_t stbi__bitreverse16(int32_t arg1)
{
    int32_t rax_6 = (((arg1 + arg1) & 0xaaaa) | ((arg1 >> 1) & 0x5555));
    int32_t rax_13 = (((rax_6 << 2) & 0xcccc) | ((rax_6 >> 2) & 0x3333));
    int32_t rax_20 = (((rax_13 << 4) & 0xf0f0) | ((rax_13 >> 4) & 0xf0f));
    return ((rax_20 << 8) | (rax_20 >> 8));
}

uint64_t stbi__bit_reverse(int32_t arg1, int32_t arg2)
{
    if (arg2 <= 0x10)
    {
        return (stbi__bitreverse16(arg1) >> (0x10 - arg2));
    }
    __assert_fail("bits <= 16", "stb_image.h", 0x1014, "int stbi__bit_reverse(int, int)");
    /* no return */
}

int64_t stbi__zbuild_huffman(void* arg1, void* arg2, int32_t arg3)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t var_ac = 0;
    int32_t var_58;
    memset(&var_58, 0, 0x44);
    memset(arg1, 0, 0x400);
    for (int32_t var_b0 = 0; var_b0 < arg3; var_b0 = (var_b0 + 1))
    {
        uint32_t rax_6 = *(arg2 + var_b0);
        &var_58[rax_6] = (&var_58[rax_6] + 1);
    }
    var_58 = 0;
    int32_t var_b0_1 = 1;
    int64_t rax_13;
    while (true)
    {
        if (var_b0_1 > 0xf)
        {
            int32_t var_a8_1 = 0;
            int32_t var_b0_2 = 1;
            while (true)
            {
                void var_98;
                if (var_b0_2 > 0xf)
                {
                    *(arg1 + 0x460) = 0x10000;
                    for (int32_t var_b0_3 = 0; var_b0_3 < arg3; var_b0_3 = (var_b0_3 + 1))
                    {
                        uint32_t rax_38 = *(arg2 + var_b0_3);
                        if (rax_38 != 0)
                        {
                            int32_t rax_47 = (*((arg1 + ((rax_38 + 0x230) << 1)) + 4) + 
(*(&var_98 + (rax_38 << 2)) - *(arg1 + ((rax_38 + 0x200) << 1))));
                            *((arg1 + rax_47) + 0x484) = rax_38;
                            *((arg1 + ((rax_47 + 0x2d0) << 1)) + 4) = var_b0_3;
                            if (rax_38 <= 9)
                            {
                                for (int32_t var_a4_1 = stbi__bit_reverse(*(&var_98 + (rax_38 
<< 2)), rax_38); var_a4_1 <= 0x1ff; var_a4_1 = (var_a4_1 + (1 << rax_38)))
                                {
                                    *(arg1 + (var_a4_1 << 1)) = (var_b0_3 | (rax_38 << 9));
                                }
                            }
                            *(&var_98 + (rax_38 << 2)) = (*(&var_98 + (rax_38 << 2)) + 1);
                        }
                    }
                    rax_13 = 1;
                    break;
                }
                *(&var_98 + (var_b0_2 << 2)) = var_a8_1;
                *(arg1 + ((var_b0_2 + 0x200) << 1)) = var_a8_1;
                *((arg1 + ((var_b0_2 + 0x230) << 1)) + 4) = var_ac;
                int32_t var_a8_2 = (var_a8_1 + &var_58[var_b0_2]);
                if ((&var_58[var_b0_2] != 0 && var_a8_2 > (1 << var_b0_2)))
                {
                    rax_13 = stbi__err("bad codelengths");
                    break;
                }
                *(arg1 + ((var_b0_2 + 0x108) << 2)) = (var_a8_2 << (0x10 - var_b0_2));
                var_a8_1 = (var_a8_2 << 1);
                var_ac = (var_ac + &var_58[var_b0_2]);
                var_b0_2 = (var_b0_2 + 1);
            }
            break;
        }
        if (&var_58[var_b0_1] > (1 << var_b0_1))
        {
            rax_13 = stbi__err("bad sizes");
            break;
        }
        var_b0_1 = (var_b0_1 + 1);
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_13;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi__zeof(int64_t* arg1)
{
    int64_t rax_2;
    rax_2 = *arg1 >= arg1[1];
    return rax_2;
}

uint64_t stbi__zget8(int64_t* arg1)
{
    uint64_t rax_4;
    if (stbi__zeof(arg1) != 0)
    {
        rax_4 = 0;
    }
    else
    {
        char* rax_3 = *arg1;
        *arg1 = &rax_3[1];
        rax_4 = *rax_3;
    }
    return rax_4;
}

int64_t* stbi__fill_bits(int64_t* arg1)
{
    int64_t* rax_6;
    do
    {
        if ((*(arg1 + 0x14) >> arg1[2]) != 0)
        {
            rax_6 = arg1;
            *rax_6 = arg1[1];
            break;
        }
        *(arg1 + 0x14) = ((stbi__zget8(arg1) << arg1[2]) | *(arg1 + 0x14));
        arg1[2] = (arg1[2] + 8);
        rax_6 = arg1[2];
    } while (rax_6 <= 0x18);
    return rax_6;
}

uint64_t stbi__zreceive(int64_t* arg1, int32_t arg2)
{
    if (arg2 > arg1[2])
    {
        stbi__fill_bits(arg1);
    }
    int32_t rax_7 = (((1 << arg2) - 1) & *(arg1 + 0x14));
    *(arg1 + 0x14) = (*(arg1 + 0x14) >> arg2);
    arg1[2] = (arg1[2] - arg2);
    return rax_7;
}

uint64_t stbi__zhuffman_decode_slowpath(void* arg1, int64_t arg2)
{
    int32_t rax_2 = stbi__bit_reverse(*(arg1 + 0x14), 0x10);
    int32_t var_14 = 0xa;
    while (rax_2 >= *(arg2 + ((var_14 + 0x108) << 2)))
    {
        var_14 = (var_14 + 1);
    }
    uint64_t rax_5;
    if (var_14 > 0xf)
    {
        rax_5 = 0xffffffff;
    }
    else
    {
        int32_t rax_13 = (*((arg2 + ((var_14 + 0x230) << 1)) + 4) + ((rax_2 >> (0x10 - 
var_14)) - *(arg2 + ((var_14 + 0x200) << 1))));
        if (rax_13 > 0x11f)
        {
            rax_5 = 0xffffffff;
        }
        else if (var_14 == *((arg2 + rax_13) + 0x484))
        {
            *(arg1 + 0x14) = (*(arg1 + 0x14) >> var_14);
            *(arg1 + 0x10) = (*(arg1 + 0x10) - var_14);
            rax_5 = *((arg2 + ((rax_13 + 0x2d0) << 1)) + 4);
        }
        else
        {
            rax_5 = 0xffffffff;
        }
    }
    return rax_5;
}

uint64_t stbi__zhuffman_decode(int64_t* arg1, int64_t arg2)
{
    int32_t rax_3;
    uint64_t rax_4;
    if (arg1[2] <= 0xf)
    {
        rax_3 = stbi__zeof(arg1) != 0;
        if (rax_3 == 0)
        {
            stbi__fill_bits(arg1);
        }
        else
        {
            rax_4 = 0xffffffff;
        }
    }
    if (((arg1[2] <= 0xf && rax_3 == 0) || arg1[2] > 0xf))
    {
        uint32_t rax_11 = *(arg2 + ((*(arg1 + 0x14) & 0x1ff) << 1));
        if (rax_11 == 0)
        {
            rax_4 = stbi__zhuffman_decode_slowpath(arg1, arg2);
        }
        else
        {
            int32_t rax_13 = (rax_11 >> 9);
            *(arg1 + 0x14) = (*(arg1 + 0x14) >> rax_13);
            arg1[2] = (arg1[2] - rax_13);
            rax_4 = (rax_11 & 0x1ff);
        }
    }
    return rax_4;
}

int64_t stbi__zexpand(void* arg1, int64_t arg2, int32_t arg3)
{
    *(arg1 + 0x18) = arg2;
    int64_t rax_3;
    if (*(arg1 + 0x30) == 0)
    {
        rax_3 = stbi__err("output buffer limit");
    }
    else
    {
        int32_t rdx_2 = (*(arg1 + 0x18) - *(arg1 + 0x20));
        int32_t var_1c_1 = (*(arg1 + 0x28) - *(arg1 + 0x20));
        if ((!rdx_2) < arg3)
        {
            rax_3 = stbi__err("outofmem");
        }
        else
        {
            while (true)
            {
                if (var_1c_1 >= (rdx_2 + arg3))
                {
                    int64_t rax_19 = realloc(*(arg1 + 0x20), var_1c_1);
                    if (rax_19 != 0)
                    {
                        *(arg1 + 0x20) = rax_19;
                        *(arg1 + 0x18) = (rdx_2 + rax_19);
                        *(arg1 + 0x28) = (var_1c_1 + rax_19);
                        rax_3 = 1;
                    }
                    else
                    {
                        rax_3 = stbi__err("outofmem");
                    }
                    break;
                }
                if (var_1c_1 < 0)
                {
                    rax_3 = stbi__err("outofmem");
                    break;
                }
                var_1c_1 = (var_1c_1 << 1);
            }
        }
    }
    return rax_3;
}

int64_t stbi__parse_huffman_block(int64_t* arg1)
{
    void* var_18 = arg1[3];
    int64_t rax_5;
    while (true)
    {
        int32_t rax_4 = stbi__zhuffman_decode(arg1, (arg1 + 0x34));
        if (rax_4 > 0xff)
        {
            if (rax_4 == 0x100)
            {
                arg1[3] = var_18;
                rax_5 = 1;
                break;
            }
            if (rax_4 > 0x11d)
            {
                rax_5 = stbi__err("bad huffman code");
                break;
            }
            int32_t var_24_1 = *(((rax_4 - 0x101) << 2) + &stbi__zlength_base);
            if (*(((rax_4 - 0x101) << 2) + &stbi__zlength_extra) != 0)
            {
                var_24_1 = (stbi__zreceive(arg1, *(((rax_4 - 0x101) << 2) + 
&stbi__zlength_extra)) + var_24_1);
            }
            int32_t rax_28 = stbi__zhuffman_decode(arg1, &arg1[0x103]);
            if ((rax_28 >= 0 && rax_28 <= 0x1d))
            {
                int32_t var_20_1 = *((rax_28 << 2) + &stbi__zdist_base);
                if (*((rax_28 << 2) + &stbi__zdist_extra) != 0)
                {
                    var_20_1 = (stbi__zreceive(arg1, *((rax_28 << 2) + &stbi__zdist_extra)) + 
var_20_1);
                }
                if ((var_18 - arg1[4]) < var_20_1)
                {
                    rax_5 = stbi__err("bad dist");
                    break;
                }
                if (arg1[5] < (var_24_1 + var_18))
                {
                    int32_t rax_49;
                    rax_49 = stbi__zexpand(arg1, var_18, var_24_1) == 0;
                    if (rax_49 != 0)
                    {
                        rax_5 = 0;
                        break;
                    }
                    var_18 = arg1[3];
                }
                void* var_10_1 = (var_18 + (-var_20_1));
                if (var_20_1 == 1)
                {
                    char rax_58 = *var_10_1;
                    if (var_24_1 == 0)
                    {
                        continue;
                    }
                    else
                    {
                        void* rax_59;
                        do
                        {
                            rax_59 = var_18;
                            var_18 = (rax_59 + 1);
                            *rax_59 = rax_58;
                            var_24_1 = (var_24_1 - 1);
                            rax_59 = var_24_1 != 0;
                        } while (rax_59 != 0);
                        continue;
                    }
                }
                else if (var_24_1 == 0)
                {
                    continue;
                }
                else
                {
                    void* rax_62;
                    do
                    {
                        void* rax_60 = var_10_1;
                        var_10_1 = (rax_60 + 1);
                        rax_62 = var_18;
                        var_18 = (rax_62 + 1);
                        *rax_62 = *rax_60;
                        var_24_1 = (var_24_1 - 1);
                        rax_62 = var_24_1 != 0;
                    } while (rax_62 != 0);
                    continue;
                }
            }
            rax_5 = stbi__err("bad huffman code");
            break;
        }
        if (rax_4 < 0)
        {
            rax_5 = stbi__err("bad huffman code");
            break;
        }
        if (var_18 >= arg1[5])
        {
            int32_t rax_9;
            rax_9 = stbi__zexpand(arg1, var_18, 1) == 0;
            if (rax_9 != 0)
            {
                rax_5 = 0;
                break;
            }
            var_18 = arg1[3];
        }
        char* rax_13 = var_18;
        var_18 = &rax_13[1];
        *rax_13 = rax_4;
    }
    return rax_5;
}

int64_t stbi__compute_huffman_codes(int64_t* arg1)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t rax_3 = (stbi__zreceive(arg1, 5) + 0x101);
    int32_t rax_6 = (stbi__zreceive(arg1, 5) + 1);
    int32_t rax_9 = (stbi__zreceive(arg1, 4) + 4);
    int32_t rax_11 = (rax_6 + rax_3);
    void var_1f8;
    memset(&var_1f8, 0, 0x13);
    for (int32_t var_a08 = 0; var_a08 < rax_9; var_a08 = (var_a08 + 1))
    {
        *(&var_1f8 + *(var_a08 + &stbi__compute_huffman_codes(stbi__zbuf*)::length_dezigzag)) 
= stbi__zreceive(arg1, 3);
    }
    void var_9e8;
    int32_t rax_20;
    rax_20 = stbi__zbuild_huffman(&var_9e8, &var_1f8, 0x13) == 0;
    int64_t rax_21;
    if (rax_20 != 0)
    {
        rax_21 = 0;
    }
    else
    {
        int32_t var_a04_1 = 0;
        while (true)
        {
            void var_1d8;
            if (var_a04_1 >= rax_11)
            {
                if (var_a04_1 != rax_11)
                {
                    rax_21 = stbi__err("bad codelengths");
                }
                else
                {
                    int32_t rax_48;
                    rax_48 = stbi__zbuild_huffman((arg1 + 0x34), &var_1d8, rax_3) == 0;
                    if (rax_48 != 0)
                    {
                        rax_21 = 0;
                    }
                    else
                    {
                        int32_t rax_53;
                        rax_53 = stbi__zbuild_huffman(&arg1[0x103], (&var_1d8 + rax_3), rax_6) 
== 0;
                        if (rax_53 == 0)
                        {
                            rax_21 = 1;
                        }
                        else
                        {
                            rax_21 = 0;
                        }
                    }
                }
                break;
            }
            int32_t rax_23 = stbi__zhuffman_decode(arg1, &var_9e8);
            if ((rax_23 >= 0 && rax_23 <= 0x12))
            {
                if (rax_23 <= 0xf)
                {
                    int32_t rax_25 = var_a04_1;
                    var_a04_1 = (rax_25 + 1);
                    *(&var_1d8 + rax_25) = rax_23;
                    continue;
                }
                else
                {
                    char var_a09_1 = 0;
                    int32_t var_a00_2;
                    if (rax_23 == 0x10)
                    {
                        var_a00_2 = (stbi__zreceive(arg1, 2) + 3);
                        if (var_a04_1 == 0)
                        {
                            rax_21 = stbi__err("bad codelengths");
                            break;
                        }
                        var_a09_1 = *(&var_1d8 + (var_a04_1 - 1));
                    }
                    else if (rax_23 == 0x11)
                    {
                        var_a00_2 = (stbi__zreceive(arg1, 3) + 3);
                    }
                    else
                    {
                        if (rax_23 != 0x12)
                        {
                            rax_21 = stbi__err("bad codelengths");
                            break;
                        }
                        var_a00_2 = (stbi__zreceive(arg1, 7) + 0xb);
                    }
                    if (var_a00_2 > (rax_11 - var_a04_1))
                    {
                        rax_21 = stbi__err("bad codelengths");
                        break;
                    }
                    memset((var_a04_1 + &var_1d8), var_a09_1, var_a00_2);
                    var_a04_1 = (var_a04_1 + var_a00_2);
                    continue;
                }
            }
            rax_21 = stbi__err("bad codelengths");
            break;
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_21;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__parse_uncompressed_block(int64_t* arg1)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    if ((arg1[2] & 7) != 0)
    {
        stbi__zreceive(arg1, (arg1[2] & 7));
    }
    int32_t var_20 = 0;
    char var_14;
    while (arg1[2] > 0)
    {
        int32_t rax_10 = var_20;
        var_20 = (rax_10 + 1);
        &var_14[rax_10] = *(arg1 + 0x14);
        *(arg1 + 0x14) = (*(arg1 + 0x14) >> 8);
        arg1[2] = (arg1[2] - 8);
    }
    int64_t rax_23;
    if (arg1[2] < 0)
    {
        rax_23 = stbi__err("zlib corrupt");
    }
    else
    {
        while (var_20 <= 3)
        {
            int32_t rax_26 = var_20;
            var_20 = (rax_26 + 1);
            &var_14[rax_26] = stbi__zget8(arg1);
        }
        char var_13;
        uint32_t rax_33 = (var_14 + (var_13 << 8));
        char var_12;
        char var_11;
        if ((var_12 + (var_11 << 8)) != (rax_33 ^ 0xffff))
        {
            rax_23 = stbi__err("zlib corrupt");
        }
        else if (arg1[1] < (*arg1 + rax_33))
        {
            rax_23 = stbi__err("read past buffer");
        }
        else
        {
            int32_t rax_54;
            if (arg1[5] < (arg1[3] + rax_33))
            {
                rax_54 = stbi__zexpand(arg1, arg1[3], rax_33) == 0;
                if (rax_54 != 0)
                {
                    rax_23 = 0;
                }
            }
            if ((arg1[5] >= (arg1[3] + rax_33) || (arg1[5] < (arg1[3] + rax_33) && rax_54 == 
0)))
            {
                memcpy(arg1[3], *arg1, rax_33);
                *arg1 = (*arg1 + rax_33);
                arg1[3] = (arg1[3] + rax_33);
                rax_23 = 1;
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_23;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__parse_zlib_header(int64_t* arg1)
{
    uint32_t rax_2 = stbi__zget8(arg1);
    uint32_t rax_7 = stbi__zget8(arg1);
    int32_t rax_9;
    rax_9 = stbi__zeof(arg1) != 0;
    int64_t rax_10;
    if (rax_9 != 0)
    {
        rax_10 = stbi__err("bad zlib header");
    }
    else
    {
        uint32_t rax_14 = (rax_7 + (rax_2 << 8));
        int32_t rdx_7 = (((((rax_14 * -0x7bdef7bd) >> 0x20) + rax_14) >> 4) - (rax_14 >> 
0x1f));
        if ((rax_14 - ((rdx_7 << 5) - rdx_7)) != 0)
        {
            rax_10 = stbi__err("bad zlib header");
        }
        else if ((rax_7 & 0x20) != 0)
        {
            rax_10 = stbi__err("no preset dict");
        }
        else if ((rax_2 & 0xf) == 8)
        {
            rax_10 = 1;
        }
        else
        {
            rax_10 = stbi__err("bad compression");
        }
    }
    return rax_10;
}

int64_t stbi__parse_zlib(int64_t* arg1, int32_t arg2)
{
    int32_t rax_2;
    int64_t rax_3;
    if (arg2 != 0)
    {
        rax_2 = stbi__parse_zlib_header(arg1) == 0;
        if (rax_2 != 0)
        {
            rax_3 = 0;
        }
    }
    if ((arg2 == 0 || (arg2 != 0 && rax_2 == 0)))
    {
        arg1[2] = 0;
        *(arg1 + 0x14) = 0;
        while (true)
        {
            int32_t rax_7 = stbi__zreceive(arg1, 1);
            int32_t rax_9 = stbi__zreceive(arg1, 2);
            if (rax_9 == 0)
            {
                int32_t rax_11;
                rax_11 = stbi__parse_uncompressed_block(arg1) == 0;
                if (rax_11 != 0)
                {
                    rax_3 = 0;
                    break;
                }
            }
            else
            {
                if (rax_9 == 3)
                {
                    rax_3 = 0;
                    break;
                }
                if (rax_9 != 1)
                {
                    int32_t rax_19;
                    rax_19 = stbi__compute_huffman_codes(arg1) == 0;
                    if (rax_19 != 0)
                    {
                        rax_3 = 0;
                        break;
                    }
                }
                else
                {
                    int32_t rax_14;
                    rax_14 = stbi__zbuild_huffman((arg1 + 0x34), &stbi__zdefault_length, 
0x120) == 0;
                    if (rax_14 != 0)
                    {
                        rax_3 = 0;
                        break;
                    }
                    int32_t rax_17;
                    rax_17 = stbi__zbuild_huffman(&arg1[0x103], &stbi__zdefault_distance, 
0x20) == 0;
                    if (rax_17 != 0)
                    {
                        rax_3 = 0;
                        break;
                    }
                }
                int32_t rax_21;
                rax_21 = stbi__parse_huffman_block(arg1) == 0;
                if (rax_21 != 0)
                {
                    rax_3 = 0;
                    break;
                }
            }
            if (rax_7 != 0)
            {
                rax_3 = 1;
                break;
            }
        }
    }
    return rax_3;
}

int64_t stbi__do_zlib(int64_t* arg1, int64_t arg2, int32_t arg3, int32_t arg4, 
    int32_t arg5)
{
    arg1[4] = arg2;
    arg1[3] = arg2;
    arg1[5] = (arg3 + arg2);
    arg1[6] = arg4;
    return stbi__parse_zlib(arg1, arg5);
}

int64_t stbi_zlib_decode_malloc_guesssize(int64_t arg1, int32_t arg2, 
    int32_t arg3, int32_t* arg4)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t rax_3 = stbi__malloc(arg3);
    int64_t rax_4;
    if (rax_3 == 0)
    {
        rax_4 = 0;
    }
    else
    {
        int64_t var_1018 = arg1;
        int64_t var_1010_1 = (arg1 + arg2);
        int32_t rax_9;
        rax_9 = stbi__do_zlib(&var_1018, rax_3, arg3, 1, 1) != 0;
        int64_t var_ff8;
        if (rax_9 == 0)
        {
            free(var_ff8);
            rax_4 = 0;
        }
        else
        {
            int32_t var_1000;
            if (arg4 != 0)
            {
                *arg4 = (var_1000 - var_ff8);
            }
            rax_4 = var_ff8;
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_4;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi_zlib_decode_malloc(int64_t arg1, int32_t arg2, int32_t* arg3)
{
    return stbi_zlib_decode_malloc_guesssize(arg1, arg2, 0x4000, arg3);
}

int64_t stbi_zlib_decode_malloc_guesssize_headerflag(int64_t arg1, 
    int32_t arg2, int32_t arg3, int32_t* arg4, int32_t arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t rax_3 = stbi__malloc(arg3);
    int64_t rax_4;
    if (rax_3 == 0)
    {
        rax_4 = 0;
    }
    else
    {
        int64_t var_1018 = arg1;
        int64_t var_1010_1 = (arg1 + arg2);
        int32_t rax_9;
        rax_9 = stbi__do_zlib(&var_1018, rax_3, arg3, 1, arg5) != 0;
        int64_t var_ff8;
        if (rax_9 == 0)
        {
            free(var_ff8);
            rax_4 = 0;
        }
        else
        {
            int32_t var_1000;
            if (arg4 != 0)
            {
                *arg4 = (var_1000 - var_ff8);
            }
            rax_4 = var_ff8;
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_4;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi_zlib_decode_buffer(int64_t arg1, int32_t arg2, int64_t arg3, 
    int32_t arg4)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t var_1018 = arg3;
    int64_t var_1010 = (arg3 + arg4);
    int32_t rax_5;
    rax_5 = stbi__do_zlib(&var_1018, arg1, arg2, 0, 1) != 0;
    uint64_t rax_7;
    int32_t var_1000;
    int32_t var_ff8;
    if (rax_5 == 0)
    {
        rax_7 = 0xffffffff;
    }
    else
    {
        rax_7 = (var_1000 - var_ff8);
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_7;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi_zlib_decode_noheader_malloc(int64_t arg1, int32_t arg2, 
    int32_t* arg3)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t rax_2 = stbi__malloc(0x4000);
    int64_t rax_3;
    if (rax_2 == 0)
    {
        rax_3 = 0;
    }
    else
    {
        int64_t var_1018 = arg1;
        int64_t var_1010_1 = (arg1 + arg2);
        int32_t rax_8;
        rax_8 = stbi__do_zlib(&var_1018, rax_2, 0x4000, 1, 0) != 0;
        int64_t var_ff8;
        if (rax_8 == 0)
        {
            free(var_ff8);
            rax_3 = 0;
        }
        else
        {
            int32_t var_1000;
            if (arg3 != 0)
            {
                *arg3 = (var_1000 - var_ff8);
            }
            rax_3 = var_ff8;
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_3;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi_zlib_decode_noheader_buffer(int64_t arg1, int32_t arg2, 
    int64_t arg3, int32_t arg4)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t var_1018 = arg3;
    int64_t var_1010 = (arg3 + arg4);
    int32_t rax_5;
    rax_5 = stbi__do_zlib(&var_1018, arg1, arg2, 0, 0) != 0;
    uint64_t rax_7;
    int32_t var_1000;
    int32_t var_ff8;
    if (rax_5 == 0)
    {
        rax_7 = 0xffffffff;
    }
    else
    {
        rax_7 = (var_1000 - var_ff8);
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_7;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__get_chunk_header(char* arg1)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t rax_2 = stbi__get32be(arg1);
    int32_t var_14 = stbi__get32be(arg1);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_2;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__check_png_header(char* arg1)
{
    int32_t var_c = 0;
    int64_t rax_3;
    while (true)
    {
        if (var_c > 7)
        {
            rax_3 = 1;
            break;
        }
        if (stbi__get8(arg1) != *(var_c + &stbi__check_png_header(stbi__context*)::png_sig) != 
0)
        {
            rax_3 = stbi__err("bad png sig");
            break;
        }
        var_c = (var_c + 1);
    }
    return rax_3;
}

uint64_t stbi__paeth(int32_t arg1, int32_t arg2, int32_t arg3)
{
    int32_t rax_2 = ((arg2 + arg1) - arg3);
    int32_t rax_4 = (rax_2 - arg1);
    int32_t rdx_2 = (-rax_4);
    if (rdx_2 >= 0)
    {
        rax_4 = rdx_2;
    }
    int32_t rax_6 = (rax_2 - arg2);
    int32_t rdx_4 = (-rax_6);
    if (rdx_4 >= 0)
    {
        rax_6 = rdx_4;
    }
    int32_t rax_8 = (rax_2 - arg3);
    int32_t rdx_6 = (-rax_8);
    if (rdx_6 >= 0)
    {
        rax_8 = rdx_6;
    }
    uint64_t rax_11;
    if ((rax_4 <= rax_6 && rax_4 <= rax_8))
    {
        rax_11 = arg1;
    }
    if ((rax_4 > rax_6 || (rax_4 <= rax_6 && rax_4 > rax_8)))
    {
        if (rax_6 > rax_8)
        {
            rax_11 = arg3;
        }
        else
        {
            rax_11 = arg2;
        }
    }
    return rax_11;
}

int64_t stbi__create_png_image_raw(int64_t* arg1, void* arg2, int32_t arg3, 
    int32_t arg4, uint32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8)
{
    void* var_a8 = arg2;
    int32_t rax;
    if (arg7 != 0x10)
    {
        rax = 1;
    }
    else
    {
        rax = 2;
    }
    void* rax_2 = *arg1;
    int32_t rax_6 = (rax * (arg4 * arg5));
    int32_t rax_8 = *(rax_2 + 8);
    int32_t rax_10 = (arg4 * rax);
    int32_t var_7c = (rax_8 * rax);
    uint32_t var_78 = arg5;
    if ((arg4 != *(rax_2 + 8) && arg4 != (*(rax_2 + 8) + 1)))
    {
        __assert_fail("out_n == s->img_n || out_n == s-…", "stb_image.h", 0x1237, "int 
stbi__create_png_image_raw(s…");
        /* no return */
    }
    arg1[3] = stbi__malloc_mad3(arg5, arg6, rax_10, 0);
    int64_t rax_23;
    if (arg1[3] == 0)
    {
        rax_23 = stbi__err("outofmem");
    }
    else
    {
        int32_t rax_25;
        rax_25 = stbi__mad3sizes_valid(rax_8, arg5, arg7, 7) == 0;
        if (rax_25 != 0)
        {
            rax_23 = stbi__err("too large");
        }
        else
        {
            uint32_t rax_31 = (((arg7 * (rax_8 * arg5)) + 7) >> 3);
            if (arg3 < (arg6 * (rax_31 + 1)))
            {
                rax_23 = stbi__err("not enough pixels");
            }
            else
            {
                int32_t var_84_1 = 0;
                while (true)
                {
                    if (var_84_1 >= arg6)
                    {
                        if (arg7 <= 7)
                        {
                            for (int32_t var_84_2 = 0; var_84_2 < arg6; var_84_2 = (var_84_2 + 
1))
                            {
                                uint8_t* var_40_1 = ((rax_6 * var_84_2) + arg1[3]);
                                char* var_38_1 = (arg1[3] + (((rax_6 * var_84_2) + (arg4 * 
arg5)) - rax_31));
                                char rax_440;
                                if (arg8 != 0)
                                {
                                    rax_440 = 1;
                                }
                                else
                                {
                                    rax_440 = *(arg7 + &stbi__depth_scale_table);
                                }
                                if (arg7 == 4)
                                {
                                    int32_t var_80_15 = (rax_8 * arg5);
                                    while (var_80_15 > 1)
                                    {
                                        void* rcx_30 = &var_40_1[1];
                                        *var_40_1 = ((*var_38_1 >> 4) * rax_440);
                                        var_40_1 = (rcx_30 + 1);
                                        *rcx_30 = ((*var_38_1 & 0xf) * rax_440);
                                        var_80_15 = (var_80_15 - 2);
                                        var_38_1 = &var_38_1[1];
                                    }
                                    if (var_80_15 > 0)
                                    {
                                        void* var_40_3 = &var_40_1[1];
                                        *var_40_1 = ((*var_38_1 >> 4) * rax_440);
                                    }
                                }
                                else if (arg7 == 2)
                                {
                                    int32_t var_80_16 = (rax_8 * arg5);
                                    while (var_80_16 > 3)
                                    {
                                        *var_40_1 = ((*var_38_1 >> 6) * rax_440);
                                        var_40_1[1] = (((*var_38_1 >> 4) & 3) * rax_440);
                                        void* rcx_35 = &var_40_1[3];
                                        var_40_1[2] = (((*var_38_1 >> 2) & 3) * rax_440);
                                        var_40_1 = (rcx_35 + 1);
                                        *rcx_35 = ((*var_38_1 & 3) * rax_440);
                                        var_80_16 = (var_80_16 - 4);
                                        var_38_1 = &var_38_1[1];
                                    }
                                    if (var_80_16 > 0)
                                    {
                                        uint8_t* rax_472 = var_40_1;
                                        var_40_1 = &rax_472[1];
                                        *rax_472 = ((*var_38_1 >> 6) * rax_440);
                                    }
                                    if (var_80_16 > 1)
                                    {
                                        uint8_t* rax_476 = var_40_1;
                                        var_40_1 = &rax_476[1];
                                        *rax_476 = (((*var_38_1 >> 4) & 3) * rax_440);
                                    }
                                    if (var_80_16 > 2)
                                    {
                                        void* var_40_7 = &var_40_1[1];
                                        *var_40_1 = (((*var_38_1 >> 2) & 3) * rax_440);
                                    }
                                }
                                else if (arg7 == 1)
                                {
                                    int32_t var_80_17 = (rax_8 * arg5);
                                    while (var_80_17 > 7)
                                    {
                                        *var_40_1 = ((*var_38_1 >> 7) * rax_440);
                                        var_40_1[1] = (((*var_38_1 >> 6) & 1) * rax_440);
                                        var_40_1[2] = (((*var_38_1 >> 5) & 1) * rax_440);
                                        var_40_1[3] = (((*var_38_1 >> 4) & 1) * rax_440);
                                        var_40_1[4] = (((*var_38_1 >> 3) & 1) * rax_440);
                                        var_40_1[5] = (((*var_38_1 >> 2) & 1) * rax_440);
                                        void* rcx_46 = &var_40_1[7];
                                        var_40_1[6] = (((*var_38_1 >> 1) & 1) * rax_440);
                                        var_40_1 = (rcx_46 + 1);
                                        *rcx_46 = ((*var_38_1 & 1) * rax_440);
                                        var_80_17 = (var_80_17 - 8);
                                        var_38_1 = &var_38_1[1];
                                    }
                                    if (var_80_17 > 0)
                                    {
                                        uint8_t* rax_516 = var_40_1;
                                        var_40_1 = &rax_516[1];
                                        *rax_516 = ((*var_38_1 >> 7) * rax_440);
                                    }
                                    if (var_80_17 > 1)
                                    {
                                        uint8_t* rax_520 = var_40_1;
                                        var_40_1 = &rax_520[1];
                                        *rax_520 = (((*var_38_1 >> 6) & 1) * rax_440);
                                    }
                                    if (var_80_17 > 2)
                                    {
                                        uint8_t* rax_524 = var_40_1;
                                        var_40_1 = &rax_524[1];
                                        *rax_524 = (((*var_38_1 >> 5) & 1) * rax_440);
                                    }
                                    if (var_80_17 > 3)
                                    {
                                        uint8_t* rax_528 = var_40_1;
                                        var_40_1 = &rax_528[1];
                                        *rax_528 = (((*var_38_1 >> 4) & 1) * rax_440);
                                    }
                                    if (var_80_17 > 4)
                                    {
                                        uint8_t* rax_532 = var_40_1;
                                        var_40_1 = &rax_532[1];
                                        *rax_532 = (((*var_38_1 >> 3) & 1) * rax_440);
                                    }
                                    if (var_80_17 > 5)
                                    {
                                        uint8_t* rax_536 = var_40_1;
                                        var_40_1 = &rax_536[1];
                                        *rax_536 = (((*var_38_1 >> 2) & 1) * rax_440);
                                    }
                                    if (var_80_17 > 6)
                                    {
                                        void* var_40_15 = &var_40_1[1];
                                        *var_40_1 = (((*var_38_1 >> 1) & 1) * rax_440);
                                    }
                                }
                                if (rax_8 != arg4)
                                {
                                    void* rax_546 = ((rax_6 * var_84_2) + arg1[3]);
                                    if (rax_8 == 1)
                                    {
                                        for (int32_t var_70_1 = (arg5 - 1); var_70_1 >= 0; 
var_70_1 = (var_70_1 - 1))
                                        {
                                            *(rax_546 + ((var_70_1 + var_70_1) + 1)) = 0xff;
                                            *(rax_546 + (var_70_1 + var_70_1)) = *(rax_546 + 
var_70_1);
                                        }
                                    }
                                    else
                                    {
                                        if (rax_8 != 3)
                                        {
                                            __assert_fail("img_n == 3", "stb_image.h", 
&data_12e4, "int stbi__create_png_image_raw(s…");
                                            /* no return */
                                        }
                                        for (int32_t var_70_2 = (arg5 - 1); var_70_2 >= 0; 
var_70_2 = (var_70_2 - 1))
                                        {
                                            *(rax_546 + ((var_70_2 << 2) + 3)) = 0xff;
                                            *(rax_546 + ((var_70_2 << 2) + 2)) = *(rax_546 + 
(((var_70_2 + var_70_2) + var_70_2) + 2));
                                            *(rax_546 + ((var_70_2 << 2) + 1)) = *(rax_546 + 
(((var_70_2 + var_70_2) + var_70_2) + 1));
                                            *(rax_546 + (var_70_2 << 2)) = *(rax_546 + 
((var_70_2 + var_70_2) + var_70_2));
                                        }
                                    }
                                }
                            }
                        }
                        else if (arg7 == 0x10)
                        {
                            uint16_t* var_30_1 = arg1[3];
                            uint16_t* var_28_1 = var_30_1;
                            int32_t var_88_9 = 0;
                            while (var_88_9 < (arg4 * (arg5 * arg6)))
                            {
                                *var_28_1 = (*(var_30_1 + 1) | (*var_30_1 << 8));
                                var_88_9 = (var_88_9 + 1);
                                var_28_1 = &var_28_1[1];
                                var_30_1 = &var_30_1[1];
                            }
                        }
                        rax_23 = 1;
                        break;
                    }
                    void* var_50_1 = ((rax_6 * var_84_1) + arg1[3]);
                    char* rax_41 = var_a8;
                    uint32_t var_74_1 = *rax_41;
                    if (var_74_1 > 4)
                    {
                        rax_23 = stbi__err("invalid filter");
                        break;
                    }
                    if (arg7 <= 7)
                    {
                        if (arg5 < rax_31)
                        {
                            rax_23 = stbi__err("invalid width");
                            break;
                        }
                        var_50_1 = (var_50_1 + ((arg4 * arg5) - rax_31));
                        var_7c = 1;
                        var_78 = rax_31;
                    }
                    void* rax_53 = (var_50_1 + (-rax_6));
                    if (var_84_1 == 0)
                    {
                        var_74_1 = *(var_74_1 + &first_row_filter);
                    }
                    for (int32_t var_80_1 = 0; var_80_1 < var_7c; var_80_1 = (var_80_1 + 1))
                    {
                        if (var_74_1 <= 6)
                        {
                            switch (var_74_1)
                            {
                                case 0:
                                {
                                    *(var_50_1 + var_80_1) = rax_41[(1 + var_80_1)];
                                    break;
                                }
                                case 1:
                                {
                                    *(var_50_1 + var_80_1) = rax_41[(1 + var_80_1)];
                                    break;
                                }
                                case 2:
                                {
                                    *(var_50_1 + var_80_1) = (rax_41[(1 + var_80_1)] + 
*(rax_53 + var_80_1));
                                    break;
                                }
                                case 3:
                                {
                                    *(var_50_1 + var_80_1) = (rax_41[(1 + var_80_1)] + 
(*(rax_53 + var_80_1) >> 1));
                                    break;
                                }
                                case 4:
                                {
                                    *(var_50_1 + var_80_1) = (rax_41[(1 + var_80_1)] + 
stbi__paeth(0, *(rax_53 + var_80_1), 0));
                                    break;
                                }
                                case 5:
                                {
                                    *(var_50_1 + var_80_1) = rax_41[(1 + var_80_1)];
                                    break;
                                }
                                case 6:
                                {
                                    *(var_50_1 + var_80_1) = rax_41[(1 + var_80_1)];
                                    break;
                                }
                            }
                        }
                    }
                    void* var_50_2;
                    void* var_48_2;
                    if (arg7 == 8)
                    {
                        if (rax_8 != arg4)
                        {
                            *(var_50_1 + rax_8) = 0xff;
                        }
                        var_a8 = &rax_41[(1 + rax_8)];
                        var_50_2 = (var_50_1 + arg4);
                        var_48_2 = (rax_53 + arg4);
                    }
                    else if (arg7 != 0x10)
                    {
                        var_a8 = &rax_41[2];
                        var_50_2 = (var_50_1 + 1);
                        var_48_2 = (rax_53 + 1);
                    }
                    else
                    {
                        if (rax_8 != arg4)
                        {
                            *(var_50_1 + var_7c) = 0xff;
                            *(var_50_1 + (var_7c + 1)) = 0xff;
                        }
                        var_a8 = &rax_41[(1 + var_7c)];
                        var_50_2 = (var_50_1 + rax_10);
                        var_48_2 = (rax_53 + rax_10);
                    }
                    if ((arg7 <= 7 || (arg7 > 7 && rax_8 == arg4)))
                    {
                        int32_t rax_137 = (var_7c * (var_78 - 1));
                        if (var_74_1 <= 6)
                        {
                            switch (var_74_1)
                            {
                                case 0:
                                {
                                    memcpy(var_50_2, var_a8, rax_137);
                                    break;
                                }
                                case 1:
                                {
                                    for (int32_t var_80_2 = 0; var_80_2 < rax_137; var_80_2 = 
(var_80_2 + 1))
                                    {
                                        *(var_50_2 + var_80_2) = (*(var_a8 + var_80_2) + 
*(var_50_2 + (var_80_2 - var_7c)));
                                    }
                                    break;
                                }
                                case 2:
                                {
                                    for (int32_t var_80_3 = 0; var_80_3 < rax_137; var_80_3 = 
(var_80_3 + 1))
                                    {
                                        *(var_50_2 + var_80_3) = (*(var_a8 + var_80_3) + 
*(var_48_2 + var_80_3));
                                    }
                                    break;
                                }
                                case 3:
                                {
                                    for (int32_t var_80_4 = 0; var_80_4 < rax_137; var_80_4 = 
(var_80_4 + 1))
                                    {
                                        *(var_50_2 + var_80_4) = (*(var_a8 + var_80_4) + 
((*(var_50_2 + (var_80_4 - var_7c)) + *(var_48_2 + var_80_4)) >> 1));
                                    }
                                    break;
                                }
                                case 4:
                                {
                                    for (int32_t var_80_5 = 0; var_80_5 < rax_137; var_80_5 = 
(var_80_5 + 1))
                                    {
                                        *(var_50_2 + var_80_5) = (*(var_a8 + var_80_5) + 
stbi__paeth(*(var_50_2 + (var_80_5 - var_7c)), *(var_48_2 + var_80_5), *(var_48_2 + (var_80_5 
- var_7c))));
                                    }
                                    break;
                                }
                                case 5:
                                {
                                    for (int32_t var_80_6 = 0; var_80_6 < rax_137; var_80_6 = 
(var_80_6 + 1))
                                    {
                                        *(var_50_2 + var_80_6) = (*(var_a8 + var_80_6) + 
(*(var_50_2 + (var_80_6 - var_7c)) >> 1));
                                    }
                                    break;
                                }
                                case 6:
                                {
                                    for (int32_t var_80_7 = 0; var_80_7 < rax_137; var_80_7 = 
(var_80_7 + 1))
                                    {
                                        *(var_50_2 + var_80_7) = (*(var_a8 + var_80_7) + 
stbi__paeth(*(var_50_2 + (var_80_7 - var_7c)), 0, 0));
                                    }
                                    break;
                                }
                            }
                        }
                        var_a8 = (var_a8 + rax_137);
                    }
                    if ((arg7 > 7 && rax_8 != arg4))
                    {
                        if (arg4 != (rax_8 + 1))
                        {
                            __assert_fail("img_n+1 == out_n", "stb_image.h", 0x128b, "int 
stbi__create_png_image_raw(s…");
                            /* no return */
                        }
                        if (var_74_1 <= 6)
                        {
                            switch (var_74_1)
                            {
                                case 0:
                                {
                                    int32_t var_88_1 = (arg5 - 1);
                                    while (var_88_1 != 0)
                                    {
                                        for (int32_t var_80_8 = 0; var_80_8 < var_7c; var_80_8 
= (var_80_8 + 1))
                                        {
                                            *(var_50_2 + var_80_8) = *(var_a8 + var_80_8);
                                        }
                                        var_88_1 = (var_88_1 - 1);
                                        *(var_50_2 + var_7c) = 0xff;
                                        var_a8 = (var_a8 + var_7c);
                                        var_50_2 = (var_50_2 + rax_10);
                                        var_48_2 = (var_48_2 + rax_10);
                                    }
                                    break;
                                }
                                case 1:
                                {
                                    int32_t var_88_2 = (arg5 - 1);
                                    while (var_88_2 != 0)
                                    {
                                        for (int32_t var_80_9 = 0; var_80_9 < var_7c; var_80_9 
= (var_80_9 + 1))
                                        {
                                            *(var_50_2 + var_80_9) = (*(var_a8 + var_80_9) + 
*(var_50_2 + (var_80_9 - rax_10)));
                                        }
                                        var_88_2 = (var_88_2 - 1);
                                        *(var_50_2 + var_7c) = 0xff;
                                        var_a8 = (var_a8 + var_7c);
                                        var_50_2 = (var_50_2 + rax_10);
                                        var_48_2 = (var_48_2 + rax_10);
                                    }
                                    break;
                                }
                                case 2:
                                {
                                    int32_t var_88_3 = (arg5 - 1);
                                    while (var_88_3 != 0)
                                    {
                                        for (int32_t var_80_10 = 0; var_80_10 < var_7c; 
var_80_10 = (var_80_10 + 1))
                                        {
                                            *(var_50_2 + var_80_10) = (*(var_a8 + var_80_10) + 
*(var_48_2 + var_80_10));
                                        }
                                        var_88_3 = (var_88_3 - 1);
                                        *(var_50_2 + var_7c) = 0xff;
                                        var_a8 = (var_a8 + var_7c);
                                        var_50_2 = (var_50_2 + rax_10);
                                        var_48_2 = (var_48_2 + rax_10);
                                    }
                                    break;
                                }
                                case 3:
                                {
                                    int32_t var_88_4 = (arg5 - 1);
                                    while (var_88_4 != 0)
                                    {
                                        for (int32_t var_80_11 = 0; var_80_11 < var_7c; 
var_80_11 = (var_80_11 + 1))
                                        {
                                            *(var_50_2 + var_80_11) = (*(var_a8 + var_80_11) + 
((*(var_50_2 + (var_80_11 - rax_10)) + *(var_48_2 + var_80_11)) >> 1));
                                        }
                                        var_88_4 = (var_88_4 - 1);
                                        *(var_50_2 + var_7c) = 0xff;
                                        var_a8 = (var_a8 + var_7c);
                                        var_50_2 = (var_50_2 + rax_10);
                                        var_48_2 = (var_48_2 + rax_10);
                                    }
                                    break;
                                }
                                case 4:
                                {
                                    int32_t var_88_5 = (arg5 - 1);
                                    while (var_88_5 != 0)
                                    {
                                        for (int32_t var_80_12 = 0; var_80_12 < var_7c; 
var_80_12 = (var_80_12 + 1))
                                        {
                                            *(var_50_2 + var_80_12) = (*(var_a8 + var_80_12) + 
stbi__paeth(*(var_50_2 + (var_80_12 - rax_10)), *(var_48_2 + var_80_12), *(var_48_2 + 
(var_80_12 - rax_10))));
                                        }
                                        var_88_5 = (var_88_5 - 1);
                                        *(var_50_2 + var_7c) = 0xff;
                                        var_a8 = (var_a8 + var_7c);
                                        var_50_2 = (var_50_2 + rax_10);
                                        var_48_2 = (var_48_2 + rax_10);
                                    }
                                    break;
                                }
                                case 5:
                                {
                                    int32_t var_88_6 = (arg5 - 1);
                                    while (var_88_6 != 0)
                                    {
                                        for (int32_t var_80_13 = 0; var_80_13 < var_7c; 
var_80_13 = (var_80_13 + 1))
                                        {
                                            *(var_50_2 + var_80_13) = (*(var_a8 + var_80_13) + 
(*(var_50_2 + (var_80_13 - rax_10)) >> 1));
                                        }
                                        var_88_6 = (var_88_6 - 1);
                                        *(var_50_2 + var_7c) = 0xff;
                                        var_a8 = (var_a8 + var_7c);
                                        var_50_2 = (var_50_2 + rax_10);
                                        var_48_2 = (var_48_2 + rax_10);
                                    }
                                    break;
                                }
                                case 6:
                                {
                                    int32_t var_88_7 = (arg5 - 1);
                                    while (var_88_7 != 0)
                                    {
                                        for (int32_t var_80_14 = 0; var_80_14 < var_7c; 
var_80_14 = (var_80_14 + 1))
                                        {
                                            *(var_50_2 + var_80_14) = (*(var_a8 + var_80_14) + 
stbi__paeth(*(var_50_2 + (var_80_14 - rax_10)), 0, 0));
                                        }
                                        var_88_7 = (var_88_7 - 1);
                                        *(var_50_2 + var_7c) = 0xff;
                                        var_a8 = (var_a8 + var_7c);
                                        var_50_2 = (var_50_2 + rax_10);
                                        var_48_2 = (var_48_2 + rax_10);
                                    }
                                    break;
                                }
                            }
                        }
                        if (arg7 == 0x10)
                        {
                            void* var_50_3 = ((rax_6 * var_84_1) + arg1[3]);
                            int32_t var_88_8 = 0;
                            while (var_88_8 < arg5)
                            {
                                *(var_50_3 + (var_7c + 1)) = 0xff;
                                var_88_8 = (var_88_8 + 1);
                                var_50_3 = (var_50_3 + rax_10);
                            }
                        }
                    }
                    var_84_1 = (var_84_1 + 1);
                }
            }
        }
    }
    return rax_23;
}

int64_t stbi__create_png_image(int64_t* arg1, void* arg2, int32_t arg3, 
    int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7)
{
    void* var_d8 = arg2;
    int32_t var_dc = arg3;
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t rax_2;
    if (arg5 != 0x10)
    {
        rax_2 = 1;
    }
    else
    {
        rax_2 = 2;
    }
    int32_t rax_4 = (arg4 * rax_2);
    int64_t rax_10;
    if (arg7 == 0)
    {
        rax_10 = stbi__create_png_image_raw(arg1, var_d8, var_dc, arg4, **arg1, *(*arg1 + 4), 
arg5, arg6);
    }
    else
    {
        int64_t rax_18 = stbi__malloc_mad3(**arg1, *(*arg1 + 4), rax_4, 0);
        if (rax_18 == 0)
        {
            rax_10 = stbi__err("outofmem");
        }
        else
        {
            int32_t var_c8_1 = 0;
            while (true)
            {
                if (var_c8_1 > 6)
                {
                    arg1[3] = rax_18;
                    rax_10 = 1;
                    break;
                }
                int32_t var_98 = 0;
                int32_t var_94_1 = 4;
                int32_t var_90_1 = 0;
                int32_t var_8c_1 = 2;
                int32_t var_88_1 = 0;
                int32_t var_84_1 = 1;
                int32_t var_80_1 = 0;
                int32_t var_78 = 0;
                int32_t var_74_1 = 0;
                int32_t var_70_1 = 4;
                int32_t var_6c_1 = 0;
                int32_t var_68_1 = 2;
                int32_t var_64_1 = 0;
                int32_t var_60_1 = 1;
                int32_t var_58;
                __builtin_memcpy(var_58, 
"\x08\x00\x00\x00\x08\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00", 
0x1c);
                int32_t var_38;
                __builtin_memcpy(var_38, 
"\x08\x00\x00\x00\x08\x00\x00\x00\x08\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00", 
0x1c);
                uint32_t temp0_1 = (COMBINE(0, ((&var_58[var_c8_1] + (**arg1 - 
&var_98[var_c8_1])) - 1)) / &var_58[var_c8_1]);
                uint32_t temp0_2 = (COMBINE(0, ((&var_38[var_c8_1] + (*(*arg1 + 4) - 
&var_78[var_c8_1])) - 1)) / &var_38[var_c8_1]);
                if ((temp0_1 != 0 && temp0_2 != 0))
                {
                    int32_t rax_55 = ((((((*(*arg1 + 8) * temp0_1) * arg5) + 7) >> 3) + 1) * 
temp0_2);
                    int32_t rax_57;
                    rax_57 = stbi__create_png_image_raw(arg1, var_d8, var_dc, arg4, temp0_1, 
temp0_2, arg5, arg6) == 0;
                    if (rax_57 != 0)
                    {
                        free(rax_18);
                        rax_10 = 0;
                        break;
                    }
                    for (int32_t var_c0_1 = 0; var_c0_1 < temp0_2; var_c0_1 = (var_c0_1 + 1))
                    {
                        for (int32_t var_c4_1 = 0; var_c4_1 < temp0_1; var_c4_1 = (var_c4_1 + 
1))
                        {
                            int64_t rcx_8 = ((rax_4 * (**arg1 * (&var_78[var_c8_1] + 
(&var_38[var_c8_1] * var_c0_1)))) + ((&var_98[var_c8_1] + (&var_58[var_c8_1] * var_c4_1)) * 
rax_4));
                            memcpy((rcx_8 + rax_18), (arg1[3] + ((var_c4_1 + (var_c0_1 * 
temp0_1)) * rax_4)), rax_4);
                        }
                    }
                    free(arg1[3]);
                    var_d8 = (var_d8 + rax_55);
                    var_dc = (var_dc - rax_55);
                }
                var_c8_1 = (var_c8_1 + 1);
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_10;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__compute_transparency(int64_t* arg1, char* arg2, int32_t arg3)
{
    int32_t* rax_1 = *arg1;
    int32_t rax_5 = (rax_1[1] * *rax_1);
    char* var_18 = arg1[3];
    if ((arg3 != 2 && arg3 != 4))
    {
        __assert_fail("out_n == 2 || out_n == 4", "stb_image.h", 0x1333, "int 
stbi__compute_transparency(s…");
        /* no return */
    }
    if (arg3 != 2)
    {
        for (int32_t var_20_1 = 0; var_20_1 < rax_5; var_20_1 = (var_20_1 + 1))
        {
            if ((*var_18 == *arg2 && (var_18[1] == arg2[1] && var_18[2] == arg2[2])))
            {
                var_18[3] = 0;
            }
            var_18 = &var_18[4];
        }
    }
    else
    {
        for (int32_t var_20 = 0; var_20 < rax_5; var_20 = (var_20 + 1))
        {
            char rdx_2;
            if (*var_18 != *arg2)
            {
                rdx_2 = -1;
            }
            else
            {
                rdx_2 = 0;
            }
            var_18[1] = rdx_2;
            var_18 = &var_18[2];
        }
    }
    return 1;
}

int64_t stbi__compute_transparency16(int64_t* arg1, int16_t* arg2, int32_t arg3)
{
    int32_t* rax_1 = *arg1;
    int32_t rax_5 = (rax_1[1] * *rax_1);
    int16_t* var_18 = arg1[3];
    if ((arg3 != 2 && arg3 != 4))
    {
        __assert_fail("out_n == 2 || out_n == 4", "stb_image.h", 0x134c, "int 
stbi__compute_transparency16…");
        /* no return */
    }
    if (arg3 != 2)
    {
        for (int32_t var_20_1 = 0; var_20_1 < rax_5; var_20_1 = (var_20_1 + 1))
        {
            if ((*var_18 == *arg2 && (var_18[1] == arg2[1] && var_18[2] == arg2[2])))
            {
                var_18[3] = 0;
            }
            var_18 = &var_18[4];
        }
    }
    else
    {
        for (int32_t var_20 = 0; var_20 < rax_5; var_20 = (var_20 + 1))
        {
            int16_t rdx_2;
            if (*var_18 != *arg2)
            {
                rdx_2 = -1;
            }
            else
            {
                rdx_2 = 0;
            }
            var_18[1] = rdx_2;
            var_18 = &var_18[2];
        }
    }
    return 1;
}

int64_t stbi__expand_png_palette(int64_t* arg1, void* arg2, int32_t arg3, 
    int32_t arg4)
{
    int32_t var_4c = arg3;
    int32_t rax_5 = (*(*arg1 + 4) * **arg1);
    int64_t rax_7 = arg1[3];
    char* var_20 = stbi__malloc_mad2(rax_5, arg4, 0);
    int64_t rax_10;
    if (var_20 == 0)
    {
        rax_10 = stbi__err("outofmem");
    }
    else
    {
        char* var_10_1 = var_20;
        if (arg4 != 3)
        {
            for (int32_t var_30_2 = 0; var_30_2 < rax_5; var_30_2 = (var_30_2 + 1))
            {
                uint32_t rax_36 = (*(rax_7 + var_30_2) << 2);
                *var_20 = *(arg2 + rax_36);
                var_20[1] = *(arg2 + (rax_36 + 1));
                var_20[2] = *(arg2 + (rax_36 + 2));
                var_20[3] = *(arg2 + (rax_36 + 3));
                var_20 = &var_20[4];
            }
        }
        else
        {
            for (int32_t var_30_1 = 0; var_30_1 < rax_5; var_30_1 = (var_30_1 + 1))
            {
                uint32_t rax_16 = (*(rax_7 + var_30_1) << 2);
                *var_20 = *(arg2 + rax_16);
                var_20[1] = *(arg2 + (rax_16 + 1));
                var_20[2] = *(arg2 + (rax_16 + 2));
                var_20 = &var_20[3];
            }
        }
        free(arg1[3]);
        arg1[3] = var_10_1;
        rax_10 = 1;
    }
    return rax_10;
}

uint64_t stbi_set_unpremultiply_on_load(int32_t arg1)
{
    uint64_t rax = arg1;
    stbi__unpremultiply_on_load_global = rax;
    return rax;
}

uint64_t stbi_convert_iphone_png_to_rgb(int32_t arg1)
{
    uint64_t rax = arg1;
    stbi__de_iphone_flag_global = rax;
    return rax;
}

uint64_t stbi_set_unpremultiply_on_load_thread(int32_t arg1)
{
    uint64_t rax = arg1;
    void* fsbase;
    *(fsbase - 0x10) = rax;
    *(fsbase - 0xc) = 1;
    return rax;
}

uint64_t stbi_convert_iphone_png_to_rgb_thread(int32_t arg1)
{
    uint64_t rax = arg1;
    void* fsbase;
    *(fsbase - 8) = rax;
    *(fsbase - 4) = 1;
    return rax;
}

uint64_t stbi__de_iphone(int64_t* arg1)
{
    int32_t* rax_1 = *arg1;
    int32_t rax_5 = (rax_1[1] * *rax_1);
    char* var_18 = arg1[3];
    uint64_t rax_67;
    if (rax_1[3] == 3)
    {
        int32_t var_20 = 0;
        while (true)
        {
            rax_67 = var_20;
            if (rax_67 >= rax_5)
            {
                break;
            }
            char rax_11 = *var_18;
            *var_18 = var_18[2];
            var_18[2] = rax_11;
            var_18 = &var_18[3];
            var_20 = (var_20 + 1);
        }
    }
    else
    {
        if (rax_1[3] != 4)
        {
            __assert_fail("s->img_out_n == 4", "stb_image.h", 0x13b8, "void 
stbi__de_iphone(stbi__png*)");
            /* no return */
        }
        uint32_t rax_19;
        void* fsbase;
        if (*(fsbase - 0xc) == 0)
        {
            rax_19 = stbi__unpremultiply_on_load_global;
        }
        else
        {
            rax_19 = *(fsbase - 0x10);
        }
        if (rax_19 == 0)
        {
            int32_t var_20_2 = 0;
            while (true)
            {
                rax_67 = var_20_2;
                if (rax_67 >= rax_5)
                {
                    break;
                }
                char rax_62 = *var_18;
                *var_18 = var_18[2];
                var_18[2] = rax_62;
                var_18 = &var_18[4];
                var_20_2 = (var_20_2 + 1);
            }
        }
        else
        {
            int32_t var_20_1 = 0;
            while (true)
            {
                rax_67 = var_20_1;
                if (rax_67 >= rax_5)
                {
                    break;
                }
                uint8_t rax_21 = var_18[3];
                char rax_23 = *var_18;
                if (rax_21 == 0)
                {
                    *var_18 = var_18[2];
                    var_18[2] = rax_23;
                }
                else
                {
                    uint8_t rax_24 = (rax_21 >> 1);
                    uint32_t rdx_3 = var_18[2];
                    int32_t temp2_1;
                    int32_t temp3_1;
                    temp2_1 = HIGHD((rax_24 + ((rdx_3 << 8) - rdx_3)));
                    temp3_1 = LOWD((rax_24 + ((rdx_3 << 8) - rdx_3)));
                    *var_18 = (COMBINE(temp2_1, temp3_1) / rax_21);
                    uint32_t rdx_6 = var_18[1];
                    int32_t temp8_1;
                    int32_t temp9_1;
                    temp8_1 = HIGHD((rax_24 + ((rdx_6 << 8) - rdx_6)));
                    temp9_1 = LOWD((rax_24 + ((rdx_6 << 8) - rdx_6)));
                    var_18[1] = (COMBINE(temp8_1, temp9_1) / rax_21);
                    uint32_t rdx_9 = rax_23;
                    int32_t temp14_1;
                    int32_t temp15_1;
                    temp14_1 = HIGHD((rax_24 + ((rdx_9 << 8) - rdx_9)));
                    temp15_1 = LOWD((rax_24 + ((rdx_9 << 8) - rdx_9)));
                    var_18[2] = (COMBINE(temp14_1, temp15_1) / rax_21);
                }
                var_18 = &var_18[4];
                var_20_1 = (var_20_1 + 1);
            }
        }
    }
    return rax_67;
}

int64_t stbi__parse_png_file(int64_t* arg1, int32_t arg2, int32_t arg3)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    char var_48a = 0;
    char var_489 = 0;
    int16_t var_42b = 0;
    char var_429 = 0;
    int32_t var_484 = 0;
    int32_t var_480 = 0;
    uint32_t var_478 = 0;
    int32_t var_474 = 1;
    uint32_t var_46c = 0;
    uint32_t var_468 = 0;
    int32_t var_464 = 0;
    char* rax_2 = *arg1;
    __builtin_memset(&arg1[1], 0, 0x18);
    int32_t rax_7;
    rax_7 = stbi__check_png_header(rax_2) == 0;
    int64_t rax_8;
    if (rax_7 != 0)
    {
        rax_8 = 0;
    }
    else if (arg2 == 1)
    {
        rax_8 = 1;
    }
    else
    {
        while (true)
        {
            int64_t rax_10 = stbi__get_chunk_header(rax_2);
            int32_t rax_11 = *rax_10[4];
            void var_432;
            void var_428;
            if (rax_11 == 0x74524e53)
            {
                if (var_474 != 0)
                {
                    rax_8 = stbi__err("first not IHDR");
                    break;
                }
                if (arg1[1] != 0)
                {
                    rax_8 = stbi__err("tRNS after IDAT");
                    break;
                }
                if (var_48a == 0)
                {
                    if ((*(rax_2 + 8) & 1) == 0)
                    {
                        rax_8 = stbi__err("tRNS with alpha");
                        break;
                    }
                    int32_t rax_112 = *(rax_2 + 8);
                    if (rax_10 != (rax_112 + rax_112))
                    {
                        rax_8 = stbi__err("bad tRNS len");
                        break;
                    }
                    var_489 = 1;
                    if (arg2 == 2)
                    {
                        *(rax_2 + 8) = (*(rax_2 + 8) + 1);
                        rax_8 = 1;
                        break;
                    }
                    if (arg1[4] != 0x10)
                    {
                        for (int32_t var_470_2 = 0; var_470_2 < *(rax_2 + 8); var_470_2 = 
(var_470_2 + 1))
                        {
                            *(&var_42b + var_470_2) = (stbi__get16be(rax_2) * *(arg1[4] + 
&stbi__depth_scale_table));
                        }
                    }
                    else
                    {
                        for (int32_t var_470_1 = 0; var_470_1 < *(rax_2 + 8); var_470_1 = 
(var_470_1 + 1))
                        {
                            *(&var_432 + (var_470_1 << 1)) = stbi__get16be(rax_2);
                        }
                    }
                }
                else
                {
                    if (arg2 == 2)
                    {
                        *(rax_2 + 8) = 4;
                        rax_8 = 1;
                        break;
                    }
                    if (var_478 == 0)
                    {
                        rax_8 = stbi__err("tRNS before PLTE");
                        break;
                    }
                    if (var_478 < rax_10)
                    {
                        rax_8 = stbi__err("bad tRNS len");
                        break;
                    }
                    var_48a = 4;
                    for (int32_t var_47c_2 = 0; var_47c_2 < rax_10; var_47c_2 = (var_47c_2 + 
1))
                    {
                        *(&var_428 + ((var_47c_2 << 2) + 3)) = stbi__get8(rax_2);
                    }
                }
            }
            else if (rax_11 > 0x74524e53)
            {
            label_15f6d:
                if (var_474 != 0)
                {
                    rax_8 = stbi__err("first not IHDR");
                    break;
                }
                if ((*rax_10[4] & 0x20000000) == 0)
                {
                    stbi__parse_png_file(stb...ng*, int32_t, int32_t)::invalid_chunk = 
(*rax_10[4] >> 0x18);
                    data_381a1 = (*rax_10[4] >> 0x10);
                    data_381a2 = (*rax_10[4] >> 8);
                    data_381a3 = *rax_10[4];
                    rax_8 = stbi__err(&stbi__parse_png_file(stb...ng*, int32_t, 
int32_t)::invalid_chunk);
                    break;
                }
                stbi__skip(rax_2, rax_10);
            }
            else if (rax_11 == 0x504c5445)
            {
                if (var_474 != 0)
                {
                    rax_8 = stbi__err("first not IHDR");
                    break;
                }
                if (rax_10 > 0x300)
                {
                    rax_8 = stbi__err("invalid PLTE");
                    break;
                }
                var_478 = (((0xaaaaaaab * rax_10) >> 0x20) >> 1);
                if ((var_478 + (var_478 + var_478)) != rax_10)
                {
                    rax_8 = stbi__err("invalid PLTE");
                    break;
                }
                for (int32_t var_47c_1 = 0; var_47c_1 < var_478; var_47c_1 = (var_47c_1 + 1))
                {
                    *(&var_428 + (var_47c_1 << 2)) = stbi__get8(rax_2);
                    *(&var_428 + ((var_47c_1 << 2) + 1)) = stbi__get8(rax_2);
                    *(&var_428 + ((var_47c_1 << 2) + 2)) = stbi__get8(rax_2);
                    *(&var_428 + ((var_47c_1 << 2) + 3)) = 0xff;
                }
            }
            else
            {
                if (rax_11 > 0x504c5445)
                {
                    goto label_15f6d;
                }
                if (rax_11 == 0x49484452)
                {
                    if (var_474 == 0)
                    {
                        rax_8 = stbi__err("multiple IHDR");
                        break;
                    }
                    var_474 = 0;
                    if (rax_10 != 0xd)
                    {
                        rax_8 = stbi__err("bad IHDR len");
                        break;
                    }
                    *rax_2 = stbi__get32be(rax_2);
                    *(rax_2 + 4) = stbi__get32be(rax_2);
                    if (*(rax_2 + 4) > 0x1000000)
                    {
                        rax_8 = stbi__err("too large");
                        break;
                    }
                    if (*rax_2 > 0x1000000)
                    {
                        rax_8 = stbi__err("too large");
                        break;
                    }
                    arg1[4] = stbi__get8(rax_2);
                    if ((arg1[4] != 1 && (arg1[4] != 2 && (arg1[4] != 4 && (arg1[4] != 8 && 
arg1[4] != 0x10)))))
                    {
                        rax_8 = stbi__err("1/2/4/8/16-bit only");
                        break;
                    }
                    var_468 = stbi__get8(rax_2);
                    if (var_468 > 6)
                    {
                        rax_8 = stbi__err("bad ctype");
                        break;
                    }
                    if ((var_468 == 3 && arg1[4] == 0x10))
                    {
                        rax_8 = stbi__err("bad ctype");
                        break;
                    }
                    if (var_468 == 3)
                    {
                        var_48a = 3;
                    }
                    else if ((var_468 & 1) != 0)
                    {
                        rax_8 = stbi__err("bad ctype");
                        break;
                    }
                    if (stbi__get8(rax_2) != 0)
                    {
                        rax_8 = stbi__err("bad comp method");
                        break;
                    }
                    if (stbi__get8(rax_2) != 0)
                    {
                        rax_8 = stbi__err("bad filter method");
                        break;
                    }
                    var_46c = stbi__get8(rax_2);
                    if (var_46c > 1)
                    {
                        rax_8 = stbi__err("bad interlace method");
                        break;
                    }
                    if ((*rax_2 == 0 || (*rax_2 != 0 && *(rax_2 + 4) == 0)))
                    {
                        rax_8 = stbi__err("0-pixel image");
                        break;
                    }
                    if ((*rax_2 != 0 && *(rax_2 + 4) != 0))
                    {
                        if (var_48a != 0)
                        {
                            *(rax_2 + 8) = 1;
                            if ((COMBINE(0, 0x10000000) / *rax_2) < *(rax_2 + 4))
                            {
                                rax_8 = stbi__err("too large");
                                break;
                            }
                        }
                        else
                        {
                            int32_t rdx_4;
                            if ((var_468 & 2) == 0)
                            {
                                rdx_4 = 1;
                            }
                            else
                            {
                                rdx_4 = 3;
                            }
                            *(rax_2 + 8) = (rdx_4 + ((var_468 >> 2) & 1));
                            if ((COMBINE(0, (COMBINE(0, 0x40000000) / *rax_2)) / *(rax_2 + 8)) 
< *(rax_2 + 4))
                            {
                                rax_8 = stbi__err("too large");
                                break;
                            }
                        }
                    }
                }
                else
                {
                    if (rax_11 > 0x49484452)
                    {
                        goto label_15f6d;
                    }
                    if (rax_11 == 0x49454e44)
                    {
                        if (var_474 != 0)
                        {
                            rax_8 = stbi__err("first not IHDR");
                        }
                        else if (arg2 != 0)
                        {
                            rax_8 = 1;
                        }
                        else if (arg1[1] == 0)
                        {
                            rax_8 = stbi__err("no IDAT");
                        }
                        else
                        {
                            int32_t var_488 = (*(rax_2 + 4) + (*(rax_2 + 8) * (*(rax_2 + 4) * 
(((*rax_2 * arg1[4]) + 7) >> 3))));
                            int32_t rax_169;
                            rax_169 = var_464 == 0;
                            arg1[2] = stbi_zlib_decode_malloc_guesssize_headerflag(arg1[1], 
var_484, var_488, &var_488, rax_169);
                            if (arg1[2] == 0)
                            {
                                rax_8 = 0;
                            }
                            else
                            {
                                free(arg1[1]);
                                arg1[1] = 0;
                                if ((arg3 == (*(rax_2 + 8) + 1) && (arg3 != 3 && var_48a == 
0)))
                                {
                                    goto label_15d53;
                                }
                                if (var_489 == 0)
                                {
                                    *(rax_2 + 0xc) = *(rax_2 + 8);
                                }
                                else
                                {
                                label_15d53:
                                    *(rax_2 + 0xc) = (*(rax_2 + 8) + 1);
                                }
                                int32_t rax_191;
                                rax_191 = stbi__create_png_image(arg1, arg1[2], var_488, 
*(rax_2 + 0xc), arg1[4], var_468, var_46c) == 0;
                                if (rax_191 != 0)
                                {
                                    rax_8 = 0;
                                }
                                else
                                {
                                    if (var_489 != 0)
                                    {
                                        if (arg1[4] != 0x10)
                                        {
                                            stbi__compute_transparency(arg1, &var_42b, *(rax_2 
+ 0xc));
                                        }
                                        else
                                        {
                                            stbi__compute_transparency16(arg1, &var_432, 
*(rax_2 + 0xc));
                                        }
                                    }
                                    if (var_464 != 0)
                                    {
                                        uint32_t rax_201;
                                        if (*(fsbase - 4) == 0)
                                        {
                                            rax_201 = stbi__de_iphone_flag_global;
                                        }
                                        else
                                        {
                                            rax_201 = *(fsbase - 8);
                                        }
                                        if ((rax_201 != 0 && *(rax_2 + 0xc) > 2))
                                        {
                                            stbi__de_iphone(arg1);
                                        }
                                    }
                                    int32_t rax_210;
                                    if (var_48a != 0)
                                    {
                                        *(rax_2 + 8) = var_48a;
                                        *(rax_2 + 0xc) = var_48a;
                                        if (arg3 > 2)
                                        {
                                            *(rax_2 + 0xc) = arg3;
                                        }
                                        rax_210 = stbi__expand_png_palette(arg1, &var_428, 
var_478, *(rax_2 + 0xc)) == 0;
                                        if (rax_210 != 0)
                                        {
                                            rax_8 = 0;
                                        }
                                    }
                                    else if (var_489 != 0)
                                    {
                                        *(rax_2 + 8) = (*(rax_2 + 8) + 1);
                                    }
                                    if (((var_48a != 0 && rax_210 == 0) || var_48a == 0))
                                    {
                                        free(arg1[2]);
                                        arg1[2] = 0;
                                        stbi__get32be(rax_2);
                                        rax_8 = 1;
                                    }
                                }
                            }
                        }
                        break;
                    }
                    if (rax_11 > 0x49454e44)
                    {
                        goto label_15f6d;
                    }
                    if (rax_11 == 0x43674249)
                    {
                        var_464 = 1;
                        stbi__skip(rax_2, rax_10);
                    }
                    else
                    {
                        if (rax_11 != 0x49444154)
                        {
                            goto label_15f6d;
                        }
                        if (var_474 != 0)
                        {
                            rax_8 = stbi__err("first not IHDR");
                            break;
                        }
                        if ((var_48a != 0 && var_478 == 0))
                        {
                            rax_8 = stbi__err("no PLTE");
                            break;
                        }
                        if (arg2 == 2)
                        {
                            if (var_48a != 0)
                            {
                                *(rax_2 + 8) = var_48a;
                            }
                            rax_8 = 1;
                            break;
                        }
                        if (rax_10 > 0x40000000)
                        {
                            rax_8 = stbi__err("IDAT size limit");
                            break;
                        }
                        if ((var_484 + rax_10) < var_484)
                        {
                            rax_8 = 0;
                            break;
                        }
                        if (var_480 < (var_484 + rax_10))
                        {
                            int32_t var_454_1 = var_480;
                            if (var_480 == 0)
                            {
                                int32_t rax_144 = rax_10;
                                if (rax_144 < 0x1000)
                                {
                                    rax_144 = 0x1000;
                                }
                                var_480 = rax_144;
                            }
                            for (; var_480 < (var_484 + rax_10); var_480 = (var_480 << 1))
                            {
                            }
                            int64_t rax_149 = realloc(arg1[1], var_480);
                            if (rax_149 == 0)
                            {
                                rax_8 = stbi__err("outofmem");
                                break;
                            }
                            arg1[1] = rax_149;
                        }
                        int32_t rax_155;
                        rax_155 = stbi__getn(rax_2, (arg1[1] + var_484), rax_10) == 0;
                        if (rax_155 != 0)
                        {
                            rax_8 = stbi__err("outofdata");
                            break;
                        }
                        var_484 = (var_484 + rax_10);
                    }
                }
            }
            stbi__get32be(rax_2);
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_8;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__do_png(int64_t* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5, int32_t* arg6)
{
    int64_t var_10 = 0;
    int64_t rax;
    if ((arg5 < 0 || (arg5 >= 0 && arg5 > 4)))
    {
        stbi__err("bad req_comp");
        rax = 0;
    }
    if ((arg5 >= 0 && arg5 <= 4))
    {
        int32_t rax_2;
        rax_2 = stbi__parse_png_file(arg1, 0, arg5) != 0;
        if (rax_2 == 0)
        {
        label_161ee:
            free(arg1[3]);
            arg1[3] = 0;
            free(arg1[2]);
            arg1[2] = 0;
            free(arg1[1]);
            arg1[1] = 0;
            rax = var_10;
        }
        else
        {
            if (arg1[4] <= 8)
            {
                *arg6 = 8;
            }
            if ((arg1[4] > 8 && arg1[4] != 0x10))
            {
                stbi__err("bad bits_per_channel");
                rax = 0;
            }
            if (arg1[4] == 0x10)
            {
                *arg6 = 0x10;
            }
            if ((arg1[4] <= 8 || arg1[4] == 0x10))
            {
                var_10 = arg1[3];
                arg1[3] = 0;
                if ((arg5 != 0 && arg5 != *(*arg1 + 0xc)))
                {
                    if (*arg6 != 8)
                    {
                        var_10 = stbi__convert_format16(var_10, *(*arg1 + 0xc), arg5, **arg1, 
*(*arg1 + 4));
                    }
                    else
                    {
                        var_10 = stbi__convert_format(var_10, *(*arg1 + 0xc), arg5, **arg1, 
*(*arg1 + 4));
                    }
                    *(*arg1 + 0xc) = arg5;
                }
                if (((arg5 == 0 || (arg5 != 0 && arg5 == *(*arg1 + 0xc))) || ((arg5 != 0 && 
arg5 != *(*arg1 + 0xc)) && var_10 != 0)))
                {
                    *arg2 = **arg1;
                    *arg3 = *(*arg1 + 4);
                    if (arg4 != 0)
                    {
                        *arg4 = *(*arg1 + 8);
                    }
                    goto label_161ee;
                }
                if (((arg5 != 0 && arg5 != *(*arg1 + 0xc)) && var_10 == 0))
                {
                    rax = var_10;
                }
            }
        }
    }
    return rax;
}

int64_t stbi__png_load(int64_t arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5, int32_t* arg6)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t var_38 = arg1;
    int64_t rax_2 = stbi__do_png(&var_38, arg2, arg3, arg4, arg5, arg6);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_2;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi__png_test(char* arg1)
{
    int32_t rax_1 = stbi__check_png_header(arg1);
    stbi__rewind(arg1);
    return rax_1;
}

int64_t stbi__png_info_raw(int64_t* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4)
{
    int32_t rax_1;
    rax_1 = stbi__parse_png_file(arg1, 2, 0) == 0;
    int64_t rax_4;
    if (rax_1 != 0)
    {
        stbi__rewind(*arg1);
        rax_4 = 0;
    }
    else
    {
        if (arg2 != 0)
        {
            *arg2 = **arg1;
        }
        if (arg3 != 0)
        {
            *arg3 = *(*arg1 + 4);
        }
        if (arg4 != 0)
        {
            *arg4 = *(*arg1 + 8);
        }
        rax_4 = 1;
    }
    return rax_4;
}

int64_t stbi__png_info(int64_t arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t var_38 = arg1;
    int64_t rax_2 = stbi__png_info_raw(&var_38, arg2, arg3, arg4);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_2;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__png_is16(void* arg1)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void* var_38 = arg1;
    int32_t rax_2;
    rax_2 = stbi__png_info_raw(&var_38, nullptr, nullptr, nullptr) == 0;
    int64_t rax_3;
    int32_t var_18;
    if (rax_2 != 0)
    {
        rax_3 = 0;
    }
    else if (var_18 == 0x10)
    {
        rax_3 = 1;
    }
    else
    {
        stbi__rewind(var_38);
        rax_3 = 0;
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_3;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi__bmp_test_raw(char* arg1)
{
    uint64_t rax_2;
    if (stbi__get8(arg1) != 0x42 != 0)
    {
        rax_2 = 0;
    }
    else if (stbi__get8(arg1) != 0x4d != 0)
    {
        rax_2 = 0;
    }
    else
    {
        stbi__get32le(arg1);
        stbi__get16le(arg1);
        stbi__get16le(arg1);
        stbi__get32le(arg1);
        int32_t rax_10 = stbi__get32le(arg1);
        char rax_11;
        if (((((rax_10 == 0xc || rax_10 == 0x28) || rax_10 == 0x38) || rax_10 == 0x6c) || 
rax_10 == 0x7c))
        {
            rax_11 = 1;
        }
        if (((((rax_10 != 0xc && rax_10 != 0x28) && rax_10 != 0x38) && rax_10 != 0x6c) && 
rax_10 != 0x7c))
        {
            rax_11 = 0;
        }
        rax_2 = rax_11;
    }
    return rax_2;
}

uint64_t stbi__bmp_test(char* arg1)
{
    int32_t rax_1 = stbi__bmp_test_raw(arg1);
    stbi__rewind(arg1);
    return rax_1;
}

uint64_t stbi__high_bit(uint32_t arg1)
{
    uint32_t var_1c = arg1;
    int32_t var_c = 0;
    uint64_t rax;
    if (var_1c == 0)
    {
        rax = 0xffffffff;
    }
    else
    {
        if (var_1c > 0xffff)
        {
            var_c = 0x10;
            var_1c = (var_1c >> 0x10);
        }
        if (var_1c > 0xff)
        {
            var_c = (var_c + 8);
            var_1c = (var_1c >> 8);
        }
        if (var_1c > 0xf)
        {
            var_c = (var_c + 4);
            var_1c = (var_1c >> 4);
        }
        if (var_1c > 3)
        {
            var_c = (var_c + 2);
            var_1c = (var_1c >> 2);
        }
        if (var_1c > 1)
        {
            var_c = (var_c + 1);
        }
        rax = var_c;
    }
    return rax;
}

uint64_t stbi__bitcount(int32_t arg1)
{
    int32_t rax_5 = (((arg1 >> 1) & 0x55555555) + (arg1 & 0x55555555));
    int32_t rax_11 = (((rax_5 >> 2) & 0x33333333) + (rax_5 & 0x33333333));
    int32_t rax_16 = ((rax_11 + (rax_11 >> 4)) & 0xf0f0f0f);
    int32_t var_c_4 = (rax_16 + (rax_16 >> 8));
    return (var_c_4 + (var_c_4 >> 0x10));
}

uint64_t stbi__shiftsigned(int32_t arg1, int32_t arg2, int32_t arg3)
{
    int32_t var_c_1;
    if (arg2 >= 0)
    {
        var_c_1 = (arg1 >> arg2);
    }
    else
    {
        var_c_1 = (arg1 << (-arg2));
    }
    if (var_c_1 > 0xff)
    {
        __assert_fail("v < 256", "stb_image.h", 0x1520, "int stbi__shiftsigned(unsigned i…");
        /* no return */
    }
    if ((arg3 >= 0 && arg3 <= 8))
    {
        return ((*((arg3 << 2) + &stbi__shiftsigned(uint32_t, int32_t, int32_t)::mul_table) * 
(var_c_1 >> (8 - arg3))) >> *((arg3 << 2) + &stbi__shiftsigned(uint32_t, int32_t, 
int32_t)::shift_table));
    }
    __assert_fail("bits >= 0 && bits <= 8", "stb_image.h", 0x1522, "int 
stbi__shiftsigned(unsigned i…");
    /* no return */
}

int64_t stbi__bmp_set_mask_defaults(int32_t* arg1, int32_t arg2)
{
    int64_t rax;
    if (arg2 == 3)
    {
        rax = 1;
    }
    else if (arg2 != 0)
    {
        rax = 0;
    }
    else
    {
        if (*arg1 == 0x10)
        {
            arg1[3] = 0x7c00;
            arg1[4] = 0x3e0;
            arg1[5] = 0x1f;
        }
        else if (*arg1 != 0x20)
        {
            arg1[6] = 0;
            arg1[5] = arg1[6];
            arg1[4] = arg1[5];
            arg1[3] = arg1[4];
        }
        else
        {
            arg1[3] = 0xff0000;
            arg1[4] = 0xff00;
            arg1[5] = 0xff;
            arg1[6] = 0xff000000;
            arg1[7] = 0;
        }
        rax = 1;
    }
    return rax;
}

int64_t stbi__bmp_parse_header(char* arg1, int32_t* arg2)
{
    char rax_1 = stbi__get8(arg1);
    char rax_3;
    char rax_4;
    if (rax_1 == 0x42)
    {
        rax_3 = stbi__get8(arg1);
        if (rax_3 == 0x4d)
        {
            rax_4 = 0;
        }
    }
    if ((rax_1 != 0x42 || (rax_1 == 0x42 && rax_3 != 0x4d)))
    {
        rax_4 = 1;
    }
    int64_t rax_5;
    if (rax_4 != 0)
    {
        stbi__err("not BMP");
        rax_5 = 0;
    }
    else
    {
        stbi__get32le(arg1);
        stbi__get16le(arg1);
        stbi__get16le(arg1);
        arg2[1] = stbi__get32le(arg1);
        int32_t rax_13 = stbi__get32le(arg1);
        arg2[2] = rax_13;
        arg2[6] = 0;
        arg2[5] = arg2[6];
        arg2[4] = arg2[5];
        arg2[3] = arg2[4];
        arg2[8] = 0xe;
        if (arg2[1] < 0)
        {
            stbi__err("bad BMP");
            rax_5 = 0;
        }
        else
        {
            if (((((rax_13 != 0xc && rax_13 != 0x28) && rax_13 != 0x38) && rax_13 != 0x6c) && 
rax_13 != 0x7c))
            {
                stbi__err("unknown BMP");
                rax_5 = 0;
            }
            if (((((rax_13 == 0xc || rax_13 == 0x28) || rax_13 == 0x38) || rax_13 == 0x6c) || 
rax_13 == 0x7c))
            {
                *arg1 = stbi__get32le(arg1);
                *(arg1 + 4) = stbi__get32le(arg1);
            }
            if (rax_13 == 0xc)
            {
                *arg1 = stbi__get16le(arg1);
                *(arg1 + 4) = stbi__get16le(arg1);
            }
            if ((((((rax_13 == 0xc || rax_13 == 0x28) || rax_13 == 0x38) || rax_13 == 0x6c) || 
rax_13 == 0x7c) || rax_13 == 0xc))
            {
                int32_t rax_36;
                rax_36 = stbi__get16le(arg1) != 1;
                if (rax_36 != 0)
                {
                    stbi__err("bad BMP");
                    rax_5 = 0;
                }
                else
                {
                    *arg2 = stbi__get16le(arg1);
                    if (rax_13 == 0xc)
                    {
                        goto label_16c88;
                    }
                    int32_t rax_40 = stbi__get32le(arg1);
                    if ((rax_40 == 1 || rax_40 == 2))
                    {
                        stbi__err("BMP RLE");
                        rax_5 = 0;
                    }
                    if ((rax_40 != 1 && rax_40 != 2))
                    {
                        if (rax_40 > 3)
                        {
                            stbi__err("BMP JPEG/PNG");
                            rax_5 = 0;
                        }
                        else
                        {
                            if (((rax_40 != 3 || (rax_40 == 3 && *arg2 == 0x10)) || (rax_40 == 
3 && *arg2 == 0x20)))
                            {
                                stbi__get32le(arg1);
                                stbi__get32le(arg1);
                                stbi__get32le(arg1);
                                stbi__get32le(arg1);
                                stbi__get32le(arg1);
                                if ((rax_13 != 0x28 && rax_13 != 0x38))
                                {
                                    if ((rax_13 == 0x6c || rax_13 == 0x7c))
                                    {
                                        arg2[3] = stbi__get32le(arg1);
                                        arg2[4] = stbi__get32le(arg1);
                                        arg2[5] = stbi__get32le(arg1);
                                        arg2[6] = stbi__get32le(arg1);
                                        if (rax_40 != 3)
                                        {
                                            stbi__bmp_set_mask_defaults(arg2, rax_40);
                                        }
                                        stbi__get32le(arg1);
                                        for (int32_t var_14_1 = 0; var_14_1 <= 0xb; var_14_1 = 
(var_14_1 + 1))
                                        {
                                            stbi__get32le(arg1);
                                        }
                                        if (rax_13 == 0x7c)
                                        {
                                            stbi__get32le(arg1);
                                            stbi__get32le(arg1);
                                            stbi__get32le(arg1);
                                            stbi__get32le(arg1);
                                        }
                                        goto label_16c88;
                                    }
                                    if ((rax_13 != 0x6c && rax_13 != 0x7c))
                                    {
                                        stbi__err("bad BMP");
                                        rax_5 = 0;
                                    }
                                }
                                if ((rax_13 == 0x28 || rax_13 == 0x38))
                                {
                                    if (rax_13 == 0x38)
                                    {
                                        stbi__get32le(arg1);
                                        stbi__get32le(arg1);
                                        stbi__get32le(arg1);
                                        stbi__get32le(arg1);
                                    }
                                    if ((*arg2 != 0x10 && *arg2 != 0x20))
                                    {
                                        goto label_16c88;
                                    }
                                    if (rax_40 == 0)
                                    {
                                        stbi__bmp_set_mask_defaults(arg2, rax_40);
                                    label_16c88:
                                        rax_5 = 1;
                                    }
                                    else if (rax_40 != 3)
                                    {
                                        stbi__err("bad BMP");
                                        rax_5 = 0;
                                    }
                                    else
                                    {
                                        arg2[3] = stbi__get32le(arg1);
                                        arg2[4] = stbi__get32le(arg1);
                                        arg2[5] = stbi__get32le(arg1);
                                        arg2[8] = (arg2[8] + 0xc);
                                        if (arg2[3] != arg2[4])
                                        {
                                            goto label_16c88;
                                        }
                                        if (arg2[4] != arg2[5])
                                        {
                                            goto label_16c88;
                                        }
                                        stbi__err("bad BMP");
                                        rax_5 = 0;
                                    }
                                }
                            }
                            if (((rax_40 == 3 && *arg2 != 0x10) && *arg2 != 0x20))
                            {
                                stbi__err("bad BMP");
                                rax_5 = 0;
                            }
                        }
                    }
                }
            }
        }
    }
    return rax_5;
}

struct Elf64_Header* const stbi__bmp_load(char* arg1, int32_t* arg2, 
    int32_t* arg3, int32_t* arg4, int32_t arg5)
{
    int64_t r9;
    int64_t var_538 = r9;
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t var_4a4 = 0;
    int32_t var_4a0 = 0;
    int32_t var_49c = 0;
    int32_t var_498 = 0;
    int32_t var_4f4 = 0;
    int32_t var_43c = 0xff;
    int32_t var_458;
    int64_t rax_2;
    rax_2 = stbi__bmp_parse_header(arg1, &var_458) == 0;
    struct Elf64_Header* const rax_3;
    if (rax_2 != 0)
    {
        rax_3 = nullptr;
    }
    else
    {
        int32_t rax_5;
        rax_5 = *(arg1 + 4) > 0;
        int32_t rax_8 = *(arg1 + 4);
        int32_t rdx_1 = (-rax_8);
        if (rdx_1 >= 0)
        {
            rax_8 = rdx_1;
        }
        *(arg1 + 4) = rax_8;
        if (*(arg1 + 4) > 0x1000000)
        {
            stbi__err("too large");
            rax_3 = nullptr;
        }
        else if (*arg1 > 0x1000000)
        {
            stbi__err("too large");
            rax_3 = nullptr;
        }
        else
        {
            int32_t var_4f8_1 = 0xff;
            int32_t var_454;
            int32_t var_450;
            int32_t var_438;
            if (var_450 != 0xc)
            {
                if (var_458 <= 0xf)
                {
                    var_4f4 = (((var_454 - var_438) - var_450) >> 2);
                }
            }
            else if (var_458 <= 0x17)
            {
                int32_t temp2_1;
                int32_t temp3_1;
                temp2_1 = HIGHD(((var_454 - var_438) - 0x18));
                temp3_1 = LOWD(((var_454 - var_438) - 0x18));
                var_4f4 = (((((var_454 - var_438) - 0x18) * 0x55555556) >> 0x20) - temp2_1);
            }
            int32_t rax_34;
            if (var_4f4 == 0)
            {
                rax_34 = ((*(arg1 + 0xc0) - *(arg1 + 0xd0)) + *(arg1 + 0xb8));
                if ((rax_34 <= 0 || (rax_34 > 0 && rax_34 > 0x400)))
                {
                    stbi__err("bad header");
                    rax_3 = nullptr;
                }
                if ((rax_34 <= 0x400 && rax_34 > 0))
                {
                    if ((rax_34 > var_454 || (rax_34 <= var_454 && 0x400 < (var_454 - 
rax_34))))
                    {
                        stbi__err("bad offset");
                        rax_3 = nullptr;
                    }
                    if ((rax_34 <= var_454 && 0x400 >= (var_454 - rax_34)))
                    {
                        stbi__skip(arg1, (var_454 - rax_34));
                    }
                }
            }
            if ((((((var_4f4 == 0 && rax_34 > 0) && rax_34 <= 0x400) && rax_34 <= var_454) && 
0x400 >= (var_454 - rax_34)) || var_4f4 != 0))
            {
                uint32_t var_440;
                if ((var_458 == 0x18 && var_440 == 0xff000000))
                {
                    *(arg1 + 8) = 3;
                }
                if ((var_458 != 0x18 || (var_458 == 0x18 && var_440 != 0xff000000)))
                {
                    int32_t rdx_13;
                    if (var_440 == 0)
                    {
                        rdx_13 = 3;
                    }
                    else
                    {
                        rdx_13 = 4;
                    }
                    *(arg1 + 8) = rdx_13;
                }
                if ((((var_458 == 0x18 && var_440 == 0xff000000) || var_458 != 0x18) || 
(var_458 == 0x18 && var_440 != 0xff000000)))
                {
                    int32_t var_4e4_1;
                    if ((arg5 == 0 || (arg5 != 0 && arg5 <= 2)))
                    {
                        var_4e4_1 = *(arg1 + 8);
                    }
                    if ((arg5 != 0 && arg5 > 2))
                    {
                        var_4e4_1 = arg5;
                    }
                    if (((arg5 == 0 || (arg5 != 0 && arg5 <= 2)) || (arg5 != 0 && arg5 > 2)))
                    {
                        int32_t rax_53;
                        rax_53 = stbi__mad3sizes_valid(var_4e4_1, *arg1, *(arg1 + 4), 0) == 0;
                        if (rax_53 != 0)
                        {
                            stbi__err("too large");
                            rax_3 = nullptr;
                        }
                        else
                        {
                            struct Elf64_Header* var_470_1 = stbi__malloc_mad3(var_4e4_1, 
*arg1, *(arg1 + 4), 0);
                            if (var_470_1 == 0)
                            {
                                stbi__err("outofmem");
                                rax_3 = nullptr;
                            }
                            else
                            {
                                int32_t var_4e0_1;
                                int32_t var_4a8_1;
                                void var_428;
                                void var_427;
                                void var_426;
                                if (var_458 > 0xf)
                                {
                                    int32_t var_4cc;
                                    __builtin_memset(var_4cc, 0, 0x28);
                                    stbi__skip(arg1, ((var_454 - var_438) - var_450));
                                    int32_t var_4e8_2;
                                    if (var_458 == 0x18)
                                    {
                                        int32_t rdx_47 = *arg1;
                                        var_4e8_2 = ((rdx_47 + rdx_47) + rdx_47);
                                    }
                                    else if (var_458 != 0x10)
                                    {
                                        var_4e8_2 = 0;
                                    }
                                    else
                                    {
                                        int32_t rax_198 = *arg1;
                                        var_4e8_2 = (rax_198 + rax_198);
                                    }
                                    uint32_t var_44c;
                                    uint32_t var_448;
                                    uint32_t var_444;
                                    if (var_458 == 0x18)
                                    {
                                        var_4a8_1 = 1;
                                    }
                                    else if ((var_458 == 0x20 && (var_444 == 0xff && (var_448 
== 0xff00 && (var_44c == 0xff0000 && var_440 == 0xff000000)))))
                                    {
                                        var_4a8_1 = 2;
                                    }
                                    int32_t var_4c8_1;
                                    int32_t var_4c4_1;
                                    int32_t var_4c0_1;
                                    int32_t var_4bc_1;
                                    int32_t var_4b8_1;
                                    int32_t var_4b4_1;
                                    int32_t var_4b0_1;
                                    if (var_4a8_1 != 0)
                                    {
                                    label_178e3:
                                        for (int32_t var_4ec_3 = 0; var_4ec_3 < *(arg1 + 4); 
var_4ec_3 = (var_4ec_3 + 1))
                                        {
                                            int32_t var_4ac_1;
                                            if (var_4a8_1 == 0)
                                            {
                                                int32_t rax_249 = var_458;
                                                for (int32_t var_4f0_5 = 0; var_4f0_5 < *arg1; 
var_4f0_5 = (var_4f0_5 + 1))
                                                {
                                                    int32_t rax_251;
                                                    if (rax_249 != 0x10)
                                                    {
                                                        rax_251 = stbi__get32le(arg1);
                                                    }
                                                    else
                                                    {
                                                        rax_251 = stbi__get16le(arg1);
                                                    }
                                                    *(var_4ac_1 + var_470_1) = 
stbi__shiftsigned((rax_251 & var_44c), var_4cc, var_4bc_1);
                                                    int32_t rdx_55 = (var_4ac_1 + 2);
                                                    *((var_4ac_1 + 1) + var_470_1) = 
stbi__shiftsigned((rax_251 & var_448), var_4c8_1, var_4b8_1);
                                                    var_4ac_1 = (rdx_55 + 1);
                                                    *(rdx_55 + var_470_1) = 
stbi__shiftsigned((rax_251 & var_444), var_4c4_1, var_4b4_1);
                                                    int32_t rax_273;
                                                    if (var_440 == 0)
                                                    {
                                                        rax_273 = 0xff;
                                                    }
                                                    else
                                                    {
                                                        rax_273 = stbi__shiftsigned((rax_251 & 
var_440), var_4c0_1, var_4b0_1);
                                                    }
                                                    var_4f8_1 = (var_4f8_1 | rax_273);
                                                    if (var_4e4_1 == 4)
                                                    {
                                                        int32_t rax_276 = var_4ac_1;
                                                        var_4ac_1 = (rax_276 + 1);
                                                        *(rax_276 + var_470_1) = rax_273;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                for (int32_t var_4f0_4 = 0; var_4f0_4 < *arg1; 
var_4f0_4 = (var_4f0_4 + 1))
                                                {
                                                    var_470_1->ident[(2 + var_4ac_1)] = 
stbi__get8(arg1);
                                                    var_470_1->ident[(1 + var_4ac_1)] = 
stbi__get8(arg1);
                                                    *(var_4ac_1 + var_470_1) = 
stbi__get8(arg1);
                                                    var_4ac_1 = (var_4ac_1 + 3);
                                                    char rax_242;
                                                    if (var_4a8_1 != 2)
                                                    {
                                                        rax_242 = -1;
                                                    }
                                                    else
                                                    {
                                                        rax_242 = stbi__get8(arg1);
                                                    }
                                                    var_4f8_1 = (var_4f8_1 | rax_242);
                                                    if (var_4e4_1 == 4)
                                                    {
                                                        int32_t rax_244 = var_4ac_1;
                                                        var_4ac_1 = (rax_244 + 1);
                                                        *(rax_244 + var_470_1) = rax_242;
                                                    }
                                                }
                                            }
                                            stbi__skip(arg1, ((-var_4e8_2) & 3));
                                        }
                                    }
                                    else
                                    {
                                        if (((var_44c == 0 || (var_44c != 0 && var_448 == 0)) 
|| ((var_44c != 0 && var_448 != 0) && var_444 == 0)))
                                        {
                                            free(var_470_1);
                                            stbi__err("bad masks");
                                            rax_3 = nullptr;
                                        }
                                        if (((var_44c != 0 && var_448 != 0) && var_444 != 0))
                                        {
                                            var_4cc = (stbi__high_bit(var_44c) - 7);
                                            var_4bc_1 = stbi__bitcount(var_44c);
                                            var_4c8_1 = (stbi__high_bit(var_448) - 7);
                                            var_4b8_1 = stbi__bitcount(var_448);
                                            var_4c4_1 = (stbi__high_bit(var_444) - 7);
                                            var_4b4_1 = stbi__bitcount(var_444);
                                            var_4c0_1 = (stbi__high_bit(var_440) - 7);
                                            var_4b0_1 = stbi__bitcount(var_440);
                                            if (var_4bc_1 <= 8)
                                            {
                                                if (var_4b8_1 > 8)
                                                {
                                                    goto label_178c5;
                                                }
                                                if (var_4b4_1 > 8)
                                                {
                                                    goto label_178c5;
                                                }
                                                if (var_4b0_1 <= 8)
                                                {
                                                    goto label_178e3;
                                                }
                                                goto label_178c5;
                                            }
                                        label_178c5:
                                            free(var_470_1);
                                            stbi__err("bad masks");
                                            rax_3 = nullptr;
                                        }
                                    }
                                }
                                else
                                {
                                    var_4e0_1 = 0;
                                    if ((var_4f4 == 0 || (var_4f4 != 0 && var_4f4 > 0x100)))
                                    {
                                        free(var_470_1);
                                        stbi__err("invalid");
                                        rax_3 = nullptr;
                                    }
                                    if ((var_4f4 != 0 && var_4f4 <= 0x100))
                                    {
                                        for (int32_t var_4f0_1 = 0; var_4f0_1 < var_4f4; 
var_4f0_1 = (var_4f0_1 + 1))
                                        {
                                            *(&var_426 + (var_4f0_1 << 2)) = stbi__get8(arg1);
                                            *(&var_427 + (var_4f0_1 << 2)) = stbi__get8(arg1);
                                            *(&var_428 + (var_4f0_1 << 2)) = stbi__get8(arg1);
                                            if (var_450 != 0xc)
                                            {
                                                stbi__get8(arg1);
                                            }
                                            void var_425;
                                            *(&var_425 + (var_4f0_1 << 2)) = 0xff;
                                        }
                                        int32_t rax_76;
                                        if (var_450 != 0xc)
                                        {
                                            rax_76 = 4;
                                        }
                                        else
                                        {
                                            rax_76 = 3;
                                        }
                                        stbi__skip(arg1, (((var_454 - var_438) - var_450) - 
(rax_76 * var_4f4)));
                                    }
                                }
                                if ((var_4f4 <= 0x100 && var_4f4 != 0))
                                {
                                    uint32_t var_4e8_1;
                                    if (var_458 == 1)
                                    {
                                        var_4e8_1 = ((*arg1 + 7) >> 3);
                                    }
                                    if (var_458 == 4)
                                    {
                                        var_4e8_1 = ((*arg1 + 1) >> 1);
                                    }
                                    if ((((var_458 <= 0xf && var_458 != 1) && var_458 != 4) && 
var_458 != 8))
                                    {
                                        free(var_470_1);
                                        stbi__err("bad bpp");
                                        rax_3 = nullptr;
                                    }
                                    if (var_458 == 8)
                                    {
                                        var_4e8_1 = *arg1;
                                    }
                                    if (((var_458 == 1 || var_458 == 4) || var_458 == 8))
                                    {
                                        int32_t rax_95 = ((-var_4e8_1) & 3);
                                        if (var_458 != 1)
                                        {
                                            for (int32_t var_4ec_2 = 0; var_4ec_2 < *(arg1 + 
4); var_4ec_2 = (var_4ec_2 + 1))
                                            {
                                                for (int32_t var_4f0_3 = 0; var_4f0_3 < *arg1; 
var_4f0_3 = (var_4f0_3 + 2))
                                                {
                                                    uint32_t var_4d4_1 = stbi__get8(arg1);
                                                    uint32_t var_4d0_1 = 0;
                                                    if (var_458 == 4)
                                                    {
                                                        var_4d0_1 = (var_4d4_1 & 0xf);
                                                        var_4d4_1 = (var_4d4_1 >> 4);
                                                    }
                                                    *(var_4e0_1 + var_470_1) = *(&var_428 + 
(var_4d4_1 << 2));
                                                    int32_t rcx_10 = (var_4e0_1 + 2);
                                                    *((var_4e0_1 + 1) + var_470_1) = 
*(&var_427 + (var_4d4_1 << 2));
                                                    var_4e0_1 = (rcx_10 + 1);
                                                    *(rcx_10 + var_470_1) = *(&var_426 + 
(var_4d4_1 << 2));
                                                    if (var_4e4_1 == 4)
                                                    {
                                                        int32_t rax_155 = var_4e0_1;
                                                        var_4e0_1 = (rax_155 + 1);
                                                        *(rax_155 + var_470_1) = 0xff;
                                                    }
                                                    if ((var_4f0_3 + 1) == *arg1)
                                                    {
                                                        break;
                                                    }
                                                    uint32_t rax_164;
                                                    if (var_458 != 8)
                                                    {
                                                        rax_164 = var_4d0_1;
                                                    }
                                                    else
                                                    {
                                                        rax_164 = stbi__get8(arg1);
                                                    }
                                                    *(var_4e0_1 + var_470_1) = *(&var_428 + 
(rax_164 << 2));
                                                    int32_t rcx_14 = (var_4e0_1 + 2);
                                                    *((var_4e0_1 + 1) + var_470_1) = 
*(&var_427 + (rax_164 << 2));
                                                    var_4e0_1 = (rcx_14 + 1);
                                                    *(rcx_14 + var_470_1) = *(&var_426 + 
(rax_164 << 2));
                                                    if (var_4e4_1 == 4)
                                                    {
                                                        int32_t rax_180 = var_4e0_1;
                                                        var_4e0_1 = (rax_180 + 1);
                                                        *(rax_180 + var_470_1) = 0xff;
                                                    }
                                                }
                                                stbi__skip(arg1, rax_95);
                                            }
                                        }
                                        else
                                        {
                                            for (int32_t var_4ec_1 = 0; var_4ec_1 < *(arg1 + 
4); var_4ec_1 = (var_4ec_1 + 1))
                                            {
                                                int32_t var_4dc_1 = 7;
                                                uint32_t var_4d8_1 = stbi__get8(arg1);
                                                for (int32_t var_4f0_2 = 0; var_4f0_2 < *arg1; 
var_4f0_2 = (var_4f0_2 + 1))
                                                {
                                                    int32_t rax_102 = ((var_4d8_1 >> 
var_4dc_1) & 1);
                                                    *(var_4e0_1 + var_470_1) = *(&var_428 + 
(rax_102 << 2));
                                                    int32_t rcx_6 = (var_4e0_1 + 2);
                                                    *((var_4e0_1 + 1) + var_470_1) = 
*(&var_427 + (rax_102 << 2));
                                                    var_4e0_1 = (rcx_6 + 1);
                                                    *(rcx_6 + var_470_1) = *(&var_426 + 
(rax_102 << 2));
                                                    if (var_4e4_1 == 4)
                                                    {
                                                        int32_t rax_118 = var_4e0_1;
                                                        var_4e0_1 = (rax_118 + 1);
                                                        *(rax_118 + var_470_1) = 0xff;
                                                    }
                                                    if ((var_4f0_2 + 1) == *arg1)
                                                    {
                                                        break;
                                                    }
                                                    var_4dc_1 = (var_4dc_1 - 1);
                                                    if ((var_4dc_1 >> 0x1f) != 0)
                                                    {
                                                        var_4dc_1 = 7;
                                                        var_4d8_1 = stbi__get8(arg1);
                                                    }
                                                }
                                                stbi__skip(arg1, rax_95);
                                            }
                                        }
                                    }
                                }
                                if ((((var_4f4 != 0 && var_4f4 <= 0x100) && ((var_458 == 1 || 
var_458 == 4) || var_458 == 8)) || (var_458 > 0xf && var_4a8_1 != 0)))
                                {
                                    if ((var_4e4_1 == 4 && var_4f8_1 == 0))
                                    {
                                        for (int32_t var_4f0_6 = (((*(arg1 + 4) * *arg1) << 2) 
- 1); var_4f0_6 >= 0; var_4f0_6 = (var_4f0_6 - 4))
                                        {
                                            *(var_470_1 + var_4f0_6) = 0xff;
                                        }
                                    }
                                    if (rax_5 != 0)
                                    {
                                        for (int32_t var_4ec_4 = 0; var_4ec_4 < (*(arg1 + 4) 
>> 1); var_4ec_4 = (var_4ec_4 + 1))
                                        {
                                            void* rax_298 = (var_470_1 + (var_4e4_1 * (*arg1 * 
var_4ec_4)));
                                            void* rax_306 = (var_470_1 + (var_4e4_1 * 
(((*(arg1 + 4) - var_4ec_4) - 1) * *arg1)));
                                            for (int32_t var_4f0_7 = 0; var_4f0_7 < (*arg1 * 
var_4e4_1); var_4f0_7 = (var_4f0_7 + 1))
                                            {
                                                char rax_310 = *(rax_298 + var_4f0_7);
                                                *(rax_298 + var_4f0_7) = *(rax_306 + 
var_4f0_7);
                                                *(var_4f0_7 + rax_306) = rax_310;
                                            }
                                        }
                                    }
                                    if (arg5 == 0)
                                    {
                                    label_17de1:
                                        *arg2 = *arg1;
                                        *arg3 = *(arg1 + 4);
                                        if (arg4 != 0)
                                        {
                                            *arg4 = *(arg1 + 8);
                                        }
                                        rax_3 = var_470_1;
                                    }
                                    else
                                    {
                                        if (arg5 == var_4e4_1)
                                        {
                                            goto label_17de1;
                                        }
                                        var_470_1 = stbi__convert_format(var_470_1, var_4e4_1, 
arg5, *arg1, *(arg1 + 4));
                                        if (var_470_1 != 0)
                                        {
                                            goto label_17de1;
                                        }
                                        rax_3 = var_470_1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_3;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi__tga_get_comp(int32_t arg1, int32_t arg2, int32_t* arg3)
{
    if (arg3 != 0)
    {
        *arg3 = 0;
    }
    uint64_t rax_8;
    if ((arg1 - 8) > 0x18)
    {
    label_17ebe:
        rax_8 = 0;
    }
    else
    {
        if (arg1 == 8)
        {
            rax_8 = 1;
        }
        if ((arg1 == 0x10 && arg2 != 0))
        {
            rax_8 = 2;
        }
        if ((arg1 == 0xf || (arg1 == 0x10 && arg2 == 0)))
        {
            if (arg3 != 0)
            {
                *arg3 = 1;
            }
            rax_8 = 3;
        }
        if ((arg1 == 0x18 || arg1 == 0x20))
        {
            int32_t rax_10 = arg1;
            if (rax_10 < 0)
            {
                rax_10 = (rax_10 + 7);
            }
            rax_8 = (rax_10 >> 3);
        }
        if ((((((((((((((((((((arg1 == 9 || arg1 == 0xa) || arg1 == 0xb) || arg1 == 0xc) || 
arg1 == 0xd) || arg1 == 0xe) || arg1 == 0x11) || arg1 == 0x12) || arg1 == 0x13) || arg1 == 
0x14) || arg1 == 0x15) || arg1 == 0x16) || arg1 == 0x17) || arg1 == 0x19) || arg1 == 0x1a) || 
arg1 == 0x1b) || arg1 == 0x1c) || arg1 == 0x1d) || arg1 == 0x1e) || arg1 == 0x1f))
        {
            goto label_17ebe;
        }
    }
    return rax_8;
}

int64_t stbi__tga_info(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)
{
    stbi__get8(arg1);
    uint32_t rax_3 = stbi__get8(arg1);
    int64_t rax_5;
    if (rax_3 > 1)
    {
        stbi__rewind(arg1);
        rax_5 = 0;
    }
    else
    {
        uint32_t rax_8 = stbi__get8(arg1);
        uint32_t var_24_1;
        if (rax_3 != 1)
        {
            if ((((rax_8 == 2 || rax_8 == 3) || rax_8 == 0xa) || rax_8 == 0xb))
            {
                stbi__skip(arg1, 9);
                var_24_1 = 0;
            label_18012:
                int32_t rax_20 = stbi__get16le(arg1);
                if (rax_20 <= 0)
                {
                    stbi__rewind(arg1);
                    rax_5 = 0;
                }
                else
                {
                    int32_t rax_23 = stbi__get16le(arg1);
                    if (rax_23 <= 0)
                    {
                        stbi__rewind(arg1);
                        rax_5 = 0;
                    }
                    else
                    {
                        uint32_t rax_27 = stbi__get8(arg1);
                        stbi__get8(arg1);
                        int32_t var_28_1;
                        if (var_24_1 != 0)
                        {
                            if ((rax_27 == 8 || rax_27 == 0x10))
                            {
                                var_28_1 = stbi__tga_get_comp(var_24_1, 0, nullptr);
                            }
                            if ((rax_27 != 8 && rax_27 != 0x10))
                            {
                                stbi__rewind(arg1);
                                rax_5 = 0;
                            }
                        }
                        else
                        {
                            char rax_32;
                            if ((rax_8 == 3 || rax_8 == 0xb))
                            {
                                rax_32 = 1;
                            }
                            if ((rax_8 != 3 && rax_8 != 0xb))
                            {
                                rax_32 = 0;
                            }
                            var_28_1 = stbi__tga_get_comp(rax_27, rax_32, nullptr);
                        }
                        if (((var_24_1 != 0 && (rax_27 == 8 || rax_27 == 0x10)) || var_24_1 == 
0))
                        {
                            if (var_28_1 == 0)
                            {
                                stbi__rewind(arg1);
                                rax_5 = 0;
                            }
                            else
                            {
                                if (arg2 != 0)
                                {
                                    *arg2 = rax_20;
                                }
                                if (arg3 != 0)
                                {
                                    *arg3 = rax_23;
                                }
                                if (arg4 != 0)
                                {
                                    *arg4 = var_28_1;
                                }
                                rax_5 = 1;
                            }
                        }
                    }
                }
            }
            if ((((rax_8 != 2 && rax_8 != 3) && rax_8 != 0xa) && rax_8 != 0xb))
            {
                stbi__rewind(arg1);
                rax_5 = 0;
            }
        }
        else
        {
            if ((rax_8 == 1 || rax_8 == 9))
            {
                stbi__skip(arg1, 4);
                uint32_t rax_13 = stbi__get8(arg1);
                if (((((rax_13 == 8 || rax_13 == 0xf) || rax_13 == 0x10) || rax_13 == 0x18) || 
rax_13 == 0x20))
                {
                    stbi__skip(arg1, 4);
                    var_24_1 = rax_13;
                    goto label_18012;
                }
                if (((((rax_13 != 8 && rax_13 != 0xf) && rax_13 != 0x10) && rax_13 != 0x18) && 
rax_13 != 0x20))
                {
                    stbi__rewind(arg1);
                    rax_5 = 0;
                }
            }
            if ((rax_8 != 1 && rax_8 != 9))
            {
                stbi__rewind(arg1);
                rax_5 = 0;
            }
        }
    }
    return rax_5;
}

uint64_t stbi__tga_test(char* arg1)
{
    int32_t var_14 = 0;
    stbi__get8(arg1);
    uint32_t rax_3 = stbi__get8(arg1);
    if (rax_3 <= 1)
    {
        uint32_t rax_6 = stbi__get8(arg1);
        if (rax_3 != 1)
        {
            if ((((rax_6 == 2 || rax_6 == 3) || rax_6 == 0xa) || rax_6 == 0xb))
            {
                stbi__skip(arg1, 9);
            label_18235:
                int32_t rax_14;
                rax_14 = stbi__get16le(arg1) <= 0;
                if (rax_14 == 0)
                {
                    int32_t rax_16;
                    rax_16 = stbi__get16le(arg1) <= 0;
                    if (rax_16 == 0)
                    {
                        uint32_t rax_19 = stbi__get8(arg1);
                        if (((rax_3 != 1 || (rax_3 == 1 && rax_19 == 8)) || (rax_3 == 1 && 
rax_19 == 0x10)))
                        {
                            if (rax_19 == 8)
                            {
                            label_18293:
                                var_14 = 1;
                            }
                            else
                            {
                                if (rax_19 == 0xf)
                                {
                                    goto label_18293;
                                }
                                if (rax_19 == 0x10)
                                {
                                    goto label_18293;
                                }
                                if (rax_19 == 0x18)
                                {
                                    goto label_18293;
                                }
                                if (rax_19 == 0x20)
                                {
                                    goto label_18293;
                                }
                            }
                        }
                    }
                }
            }
        }
        else if ((rax_6 == 1 || rax_6 == 9))
        {
            stbi__skip(arg1, 4);
            uint32_t rax_10 = stbi__get8(arg1);
            if (((((rax_10 == 8 || rax_10 == 0xf) || rax_10 == 0x10) || rax_10 == 0x18) || 
rax_10 == 0x20))
            {
                stbi__skip(arg1, 4);
                goto label_18235;
            }
        }
    }
    stbi__rewind(arg1);
    return var_14;
}

void* stbi__tga_read_rgb16(char* arg1, char* arg2)
{
    uint16_t rax_1 = stbi__get16le(arg1);
    uint32_t rax_3 = ((rax_1 >> 0xa) & 0x1f);
    uint32_t rax_5 = ((rax_1 >> 5) & 0x1f);
    uint32_t rax_7 = (rax_1 & 0x1f);
    uint32_t rax_10 = ((rax_3 << 8) - rax_3);
    *arg2 = (((((rax_10 * -0x7bdef7bd) >> 0x20) + rax_10) >> 4) - (rax_10 >> 0x1f));
    uint32_t rax_15 = ((rax_5 << 8) - rax_5);
    arg2[1] = (((((rax_15 * -0x7bdef7bd) >> 0x20) + rax_15) >> 4) - (rax_15 >> 0x1f));
    uint32_t rax_21 = ((rax_7 << 8) - rax_7);
    arg2[2] = (((((rax_21 * -0x7bdef7bd) >> 0x20) + rax_21) >> 4) - (rax_21 >> 0x1f));
    return &arg2[2];
}

char* stbi__tga_load(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, 
    int32_t arg5)
{
    int64_t r9;
    int64_t var_d8 = r9;
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    uint32_t rax_3 = stbi__get8(arg1);
    uint32_t rax_6 = stbi__get8(arg1);
    uint32_t var_a0 = stbi__get8(arg1);
    int32_t var_9c = 0;
    int32_t rax_11 = stbi__get16le(arg1);
    int32_t rax_13 = stbi__get16le(arg1);
    uint32_t rax_16 = stbi__get8(arg1);
    int32_t var_60 = stbi__get16le(arg1);
    int32_t var_5c = stbi__get16le(arg1);
    int32_t rax_22 = stbi__get16le(arg1);
    int32_t rax_24 = stbi__get16le(arg1);
    uint32_t rax_27 = stbi__get8(arg1);
    int32_t var_a4 = 0;
    uint32_t rax_30 = stbi__get8(arg1);
    char* var_38 = nullptr;
    int32_t var_14 = 0;
    int32_t var_8c = 0;
    int32_t var_88 = 0;
    int32_t var_84 = 1;
    char* rax_31;
    if (rax_24 > 0x1000000)
    {
        stbi__err("too large");
        rax_31 = nullptr;
    }
    else if (rax_22 > 0x1000000)
    {
        stbi__err("too large");
        rax_31 = nullptr;
    }
    else
    {
        if (var_a0 > 7)
        {
            var_a0 = (var_a0 - 8);
            var_9c = 1;
        }
        int32_t rax_33;
        rax_33 = (rax_30 & 0x20) == 0;
        uint32_t var_4c_1 = rax_33;
        int32_t var_98_1;
        if (rax_6 == 0)
        {
            uint32_t rax_34;
            rax_34 = var_a0 == 3;
            var_98_1 = stbi__tga_get_comp(rax_27, rax_34, &var_a4);
        }
        else
        {
            var_98_1 = stbi__tga_get_comp(rax_16, 0, &var_a4);
        }
        if (var_98_1 == 0)
        {
            stbi__err("bad format");
            rax_31 = nullptr;
        }
        else
        {
            *arg2 = rax_22;
            *arg3 = rax_24;
            if (arg4 != 0)
            {
                *arg4 = var_98_1;
            }
            int32_t rax_43;
            rax_43 = stbi__mad3sizes_valid(rax_22, rax_24, var_98_1, 0) == 0;
            if (rax_43 != 0)
            {
                stbi__err("too large");
                rax_31 = nullptr;
            }
            else
            {
                char* var_40_1 = stbi__malloc_mad3(rax_22, rax_24, var_98_1, 0);
                if (var_40_1 == 0)
                {
                    stbi__err("outofmem");
                    rax_31 = nullptr;
                }
                else
                {
                    stbi__skip(arg1, rax_3);
                    if (((rax_6 == 0 && var_9c == 0) && var_a4 == 0))
                    {
                        for (int32_t var_94_1 = 0; var_94_1 < rax_24; var_94_1 = (var_94_1 + 
1))
                        {
                            int32_t rax_50;
                            if (var_4c_1 == 0)
                            {
                                rax_50 = var_94_1;
                            }
                            else
                            {
                                rax_50 = ((rax_24 - var_94_1) - 1);
                            }
                            stbi__getn(arg1, &var_40_1[((rax_50 * rax_22) * var_98_1)], 
(rax_22 * var_98_1));
                        }
                    }
                    int32_t rax_74;
                    if (((rax_6 != 0 || (rax_6 == 0 && var_9c != 0)) || ((rax_6 == 0 && var_9c 
== 0) && var_a4 != 0)))
                    {
                        if ((rax_13 != 0 && rax_6 != 0))
                        {
                            stbi__skip(arg1, rax_11);
                            var_38 = stbi__malloc_mad2(rax_13, var_98_1, 0);
                            if (var_38 == 0)
                            {
                                free(var_40_1);
                                stbi__err("outofmem");
                                rax_31 = nullptr;
                            }
                            else if (var_a4 == 0)
                            {
                                rax_74 = stbi__getn(arg1, var_38, (rax_13 * var_98_1)) == 0;
                                if (rax_74 != 0)
                                {
                                    free(var_40_1);
                                    free(var_38);
                                    stbi__err("bad palette");
                                    rax_31 = nullptr;
                                }
                            }
                            else
                            {
                                char* var_30_1 = var_38;
                                if (var_98_1 != 3)
                                {
                                    __assert_fail("tga_comp == STBI_rgb", "stb_image.h", 
0x1745, "void* stbi__tga_load(stbi__conte…");
                                    /* no return */
                                }
                                for (int32_t var_94_2 = 0; var_94_2 < rax_13; var_94_2 = 
(var_94_2 + 1))
                                {
                                    stbi__tga_read_rgb16(arg1, var_30_1);
                                    var_30_1 = &var_30_1[var_98_1];
                                }
                            }
                        }
                        if (((rax_6 == 0 || ((((rax_6 != 0 && rax_13 != 0) && var_38 != 0) && 
var_a4 == 0) && rax_74 == 0)) || (((rax_6 != 0 && rax_13 != 0) && var_38 != 0) && var_a4 != 
0)))
                        {
                            for (int32_t var_94_3 = 0; var_94_3 < (rax_22 * rax_24); var_94_3 
= (var_94_3 + 1))
                            {
                                if (var_9c == 0)
                                {
                                    var_84 = 1;
                                }
                                else if (var_8c == 0)
                                {
                                    uint32_t rax_79 = stbi__get8(arg1);
                                    var_8c = ((rax_79 & 0x7f) + 1);
                                    var_88 = (rax_79 >> 7);
                                    var_84 = 1;
                                }
                                else if (var_88 == 0)
                                {
                                    var_84 = 1;
                                }
                                if (var_84 != 0)
                                {
                                    if (rax_6 != 0)
                                    {
                                        uint32_t rax_87;
                                        if (rax_27 != 8)
                                        {
                                            rax_87 = stbi__get16le(arg1);
                                        }
                                        else
                                        {
                                            rax_87 = stbi__get8(arg1);
                                        }
                                        uint32_t var_80_1 = rax_87;
                                        if (var_80_1 >= rax_13)
                                        {
                                            var_80_1 = 0;
                                        }
                                        for (int32_t var_90_1 = 0; var_90_1 < var_98_1; 
var_90_1 = (var_90_1 + 1))
                                        {
                                            *(&var_14 + var_90_1) = var_38[(var_90_1 + 
(var_80_1 * var_98_1))];
                                        }
                                    }
                                    else if (var_a4 == 0)
                                    {
                                        for (int32_t var_90_2 = 0; var_90_2 < var_98_1; 
var_90_2 = (var_90_2 + 1))
                                        {
                                            *(&var_14 + var_90_2) = stbi__get8(arg1);
                                        }
                                    }
                                    else
                                    {
                                        if (var_98_1 != 3)
                                        {
                                            __assert_fail("tga_comp == STBI_rgb", 
"stb_image.h", 0x1776, "void* stbi__tga_load(stbi__conte…");
                                            /* no return */
                                        }
                                        stbi__tga_read_rgb16(arg1, &var_14);
                                    }
                                    var_84 = 0;
                                }
                                for (int32_t var_90_3 = 0; var_90_3 < var_98_1; var_90_3 = 
(var_90_3 + 1))
                                {
                                    var_40_1[(var_90_3 + (var_94_3 * var_98_1))] = *(&var_14 + 
var_90_3);
                                }
                                var_8c = (var_8c - 1);
                            }
                            if (var_4c_1 != 0)
                            {
                                int32_t var_90_4 = 0;
                                while (rax_24 > (var_90_4 + var_90_4))
                                {
                                    int32_t var_7c_1 = ((var_90_4 * rax_22) * var_98_1);
                                    int32_t var_78_1 = ((((rax_24 - 1) - var_90_4) * rax_22) * 
var_98_1);
                                    for (int32_t var_94_4 = (rax_22 * var_98_1); var_94_4 > 0; 
var_94_4 = (var_94_4 - 1))
                                    {
                                        char rax_128 = var_40_1[var_7c_1];
                                        var_40_1[var_7c_1] = var_40_1[var_78_1];
                                        var_40_1[var_78_1] = rax_128;
                                        var_7c_1 = (var_7c_1 + 1);
                                        var_78_1 = (var_78_1 + 1);
                                    }
                                    var_90_4 = (var_90_4 + 1);
                                }
                            }
                            if (var_38 != 0)
                            {
                                free(var_38);
                            }
                        }
                    }
                    if (((((rax_6 != 0 || (rax_6 == 0 && var_9c != 0)) || ((rax_6 == 0 && 
var_9c == 0) && var_a4 != 0)) && ((rax_6 == 0 || ((((rax_6 != 0 && rax_13 != 0) && var_38 != 
0) && var_a4 == 0) && rax_74 == 0)) || (((rax_6 != 0 && rax_13 != 0) && var_38 != 0) && var_a4 
!= 0))) || ((rax_6 == 0 && var_9c == 0) && var_a4 == 0)))
                    {
                        if ((var_98_1 > 2 && var_a4 == 0))
                        {
                            char* var_28_1 = var_40_1;
                            for (int32_t var_94_5 = 0; var_94_5 < (rax_22 * rax_24); var_94_5 
= (var_94_5 + 1))
                            {
                                char rax_142 = *var_28_1;
                                *var_28_1 = var_28_1[2];
                                var_28_1[2] = rax_142;
                                var_28_1 = &var_28_1[var_98_1];
                            }
                        }
                        if (arg5 != 0)
                        {
                            if (arg5 != var_98_1)
                            {
                                var_40_1 = stbi__convert_format(var_40_1, var_98_1, arg5, 
rax_22, rax_24);
                            }
                            goto label_18c84;
                        }
                    label_18c84:
                        int32_t var_6c_1;
                        __builtin_memset(var_6c_1, 0, 0x14);
                        rax_31 = var_40_1;
                    }
                    if (((((rax_6 != 0 || (rax_6 == 0 && var_9c != 0)) || ((rax_6 == 0 && 
var_9c == 0) && var_a4 != 0)) && rax_6 != 0) && rax_13 == 0))
                    {
                        free(var_40_1);
                        stbi__err("bad palette");
                        rax_31 = nullptr;
                    }
                }
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_31;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi__psd_test(char* arg1)
{
    int32_t rax_1;
    rax_1 = stbi__get32be(arg1) == 0x38425053;
    stbi__rewind(arg1);
    return rax_1;
}

int64_t stbi__psd_decode_rle(char* arg1, char* arg2, int32_t arg3)
{
    char* var_28 = arg2;
    int32_t var_14 = 0;
    int64_t rax_5;
    while (true)
    {
        int32_t var_c_1 = (arg3 - var_14);
        int32_t rax_16;
        rax_16 = var_c_1 > 0;
        if (rax_16 == 0)
        {
            rax_5 = 1;
            break;
        }
        uint32_t rax_3 = stbi__get8(arg1);
        if (rax_3 != 0x80)
        {
            if (rax_3 <= 0x7f)
            {
                int32_t var_10_2 = (rax_3 + 1);
                if (var_10_2 > var_c_1)
                {
                    rax_5 = 0;
                    break;
                }
                var_14 = (var_14 + var_10_2);
                for (; var_10_2 != 0; var_10_2 = (var_10_2 - 1))
                {
                    *var_28 = stbi__get8(arg1);
                    var_28 = &var_28[4];
                }
            }
            else if (rax_3 > 0x80)
            {
                int32_t var_10_3 = (0x101 - rax_3);
                if (var_10_3 > var_c_1)
                {
                    rax_5 = 0;
                    break;
                }
                char rax_12 = stbi__get8(arg1);
                var_14 = (var_14 + var_10_3);
                for (; var_10_3 != 0; var_10_3 = (var_10_3 - 1))
                {
                    *var_28 = rax_12;
                    var_28 = &var_28[4];
                }
            }
        }
    }
    return rax_5;
}

struct Elf64_Header* const stbi__psd_load(char* arg1, int32_t* arg2, 
    int32_t* arg3, int32_t* arg4, int32_t arg5, int32_t* arg6, int32_t arg7)
{
    int32_t rax_1;
    rax_1 = stbi__get32be(arg1) != 0x38425053;
    struct Elf64_Header* const rax_2;
    if (rax_1 != 0)
    {
        stbi__err("not PSD");
        rax_2 = nullptr;
    }
    else
    {
        int32_t rax_4;
        rax_4 = stbi__get16be(arg1) != 1;
        if (rax_4 != 0)
        {
            stbi__err("wrong version");
            rax_2 = nullptr;
        }
        else
        {
            stbi__skip(arg1, 6);
            int32_t rax_7 = stbi__get16be(arg1);
            if ((rax_7 < 0 || (rax_7 >= 0 && rax_7 > 0x10)))
            {
                stbi__err("wrong channel count");
                rax_2 = nullptr;
            }
            if ((rax_7 >= 0 && rax_7 <= 0x10))
            {
                int32_t rax_9 = stbi__get32be(arg1);
                int32_t rax_11 = stbi__get32be(arg1);
                if (rax_9 > 0x1000000)
                {
                    stbi__err("too large");
                    rax_2 = nullptr;
                }
                else if (rax_11 > 0x1000000)
                {
                    stbi__err("too large");
                    rax_2 = nullptr;
                }
                else
                {
                    int32_t rax_13 = stbi__get16be(arg1);
                    if ((rax_13 == 8 || rax_13 == 0x10))
                    {
                        int32_t rax_15;
                        rax_15 = stbi__get16be(arg1) != 3;
                        if (rax_15 != 0)
                        {
                            stbi__err("wrong color format");
                            rax_2 = nullptr;
                        }
                        else
                        {
                            stbi__skip(arg1, stbi__get32be(arg1));
                            stbi__skip(arg1, stbi__get32be(arg1));
                            stbi__skip(arg1, stbi__get32be(arg1));
                            int32_t rax_26 = stbi__get16be(arg1);
                            if (rax_26 > 1)
                            {
                                stbi__err("bad compression");
                                rax_2 = nullptr;
                            }
                            else
                            {
                                int32_t rax_28;
                                rax_28 = stbi__mad3sizes_valid(4, rax_11, rax_9, 0) == 0;
                                if (rax_28 != 0)
                                {
                                    stbi__err("too large");
                                    rax_2 = nullptr;
                                }
                                else
                                {
                                    struct Elf64_Header* var_48_1;
                                    if (((rax_26 != 0 || (rax_26 == 0 && rax_13 != 0x10)) || 
((rax_26 == 0 && rax_13 == 0x10) && arg7 != 0x10)))
                                    {
                                        var_48_1 = stbi__malloc(((rax_11 * rax_9) << 2));
                                    }
                                    if (((rax_26 == 0 && rax_13 == 0x10) && arg7 == 0x10))
                                    {
                                        var_48_1 = stbi__malloc_mad3(8, rax_11, rax_9, 0);
                                        *arg6 = 0x10;
                                    }
                                    if (var_48_1 == 0)
                                    {
                                        stbi__err("outofmem");
                                        rax_2 = nullptr;
                                    }
                                    else
                                    {
                                        int32_t rax_38 = (rax_11 * rax_9);
                                        int32_t var_80_1;
                                        if (rax_26 != 0)
                                        {
                                            int32_t rax_40 = (rax_9 * rax_7);
                                            stbi__skip(arg1, (rax_40 + rax_40));
                                            for (var_80_1 = 0; var_80_1 <= 3; var_80_1 = 
(var_80_1 + 1))
                                            {
                                                char* var_40_1 = (var_48_1 + var_80_1);
                                                if (var_80_1 >= rax_7)
                                                {
                                                    int32_t var_7c_1 = 0;
                                                    while (var_7c_1 < rax_38)
                                                    {
                                                        char rdx_7;
                                                        if (var_80_1 != 3)
                                                        {
                                                            rdx_7 = 0;
                                                        }
                                                        else
                                                        {
                                                            rdx_7 = -1;
                                                        }
                                                        *var_40_1 = rdx_7;
                                                        var_7c_1 = (var_7c_1 + 1);
                                                        var_40_1 = &var_40_1[4];
                                                    }
                                                }
                                                else
                                                {
                                                    int32_t rax_49;
                                                    rax_49 = stbi__psd_decode_rle(arg1, 
var_40_1, rax_38) == 0;
                                                    if (rax_49 != 0)
                                                    {
                                                        break;
                                                    }
                                                }
                                            }
                                            if (var_80_1 <= 3)
                                            {
                                                free(var_48_1);
                                                stbi__err("corrupt");
                                                rax_2 = nullptr;
                                            }
                                        }
                                        else
                                        {
                                            for (int32_t var_80_2 = 0; var_80_2 <= 3; var_80_2 
= (var_80_2 + 1))
                                            {
                                                if (var_80_2 >= rax_7)
                                                {
                                                    if ((rax_13 != 0x10 || (rax_13 == 0x10 && 
arg7 != 0x10)))
                                                    {
                                                        void* var_30_1 = (var_48_1 + 
var_80_2);
                                                        char rax_62;
                                                        if (var_80_2 != 3)
                                                        {
                                                            rax_62 = 0;
                                                        }
                                                        else
                                                        {
                                                            rax_62 = -1;
                                                        }
                                                        int32_t var_7c_3 = 0;
                                                        while (var_7c_3 < rax_38)
                                                        {
                                                            *var_30_1 = rax_62;
                                                            var_7c_3 = (var_7c_3 + 1);
                                                            var_30_1 = (var_30_1 + 4);
                                                        }
                                                    }
                                                    if ((rax_13 == 0x10 && arg7 == 0x10))
                                                    {
                                                        int64_t rax_53 = var_80_2;
                                                        void* var_38_1 = (var_48_1 + (rax_53 + 
rax_53));
                                                        int16_t rax_56;
                                                        if (var_80_2 != 3)
                                                        {
                                                            rax_56 = 0;
                                                        }
                                                        else
                                                        {
                                                            rax_56 = -1;
                                                        }
                                                        int32_t var_7c_2 = 0;
                                                        while (var_7c_2 < rax_38)
                                                        {
                                                            *var_38_1 = rax_56;
                                                            var_7c_2 = (var_7c_2 + 1);
                                                            var_38_1 = (var_38_1 + 8);
                                                        }
                                                    }
                                                }
                                                else if (*arg6 != 0x10)
                                                {
                                                    void* var_20_1 = (var_48_1 + var_80_2);
                                                    if (rax_13 != 0x10)
                                                    {
                                                        int32_t var_7c_6 = 0;
                                                        while (var_7c_6 < rax_38)
                                                        {
                                                            *var_20_1 = stbi__get8(arg1);
                                                            var_7c_6 = (var_7c_6 + 1);
                                                            var_20_1 = (var_20_1 + 4);
                                                        }
                                                    }
                                                    else
                                                    {
                                                        int32_t var_7c_5 = 0;
                                                        while (var_7c_5 < rax_38)
                                                        {
                                                            *var_20_1 = (stbi__get16be(arg1) 
>> 8);
                                                            var_7c_5 = (var_7c_5 + 1);
                                                            var_20_1 = (var_20_1 + 4);
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    int64_t rax_68 = var_80_2;
                                                    void* var_28_1 = (var_48_1 + (rax_68 + 
rax_68));
                                                    int32_t var_7c_4 = 0;
                                                    while (var_7c_4 < rax_38)
                                                    {
                                                        *var_28_1 = stbi__get16be(arg1);
                                                        var_7c_4 = (var_7c_4 + 1);
                                                        var_28_1 = (var_28_1 + 8);
                                                    }
                                                }
                                            }
                                        }
                                        if ((rax_26 == 0 || (rax_26 != 0 && var_80_1 > 3)))
                                        {
                                            if (rax_7 > 3)
                                            {
                                                if (*arg6 != 0x10)
                                                {
                                                    for (int32_t var_7c_8 = 0; var_7c_8 < 
(rax_11 * rax_9); var_7c_8 = (var_7c_8 + 1))
                                                    {
                                                        void* rax_125 = (var_48_1 + (var_7c_8 
<< 2));
                                                        if ((*(rax_125 + 3) != 0 && *(rax_125 
+ 3) != 0xff))
                                                        {
                                                            float var_5c_1 = (1f / (*(rax_125 
+ 3) / 255f));
                                                            float var_58_1 = (255f * (1f - 
var_5c_1));
                                                            *rax_125 = (truncf(((*rax_125 * 
var_5c_1) + var_58_1), 0x38425053));
                                                            *(rax_125 + 1) = 
(truncf(((*(rax_125 + 1) * var_5c_1) + var_58_1), 0x38425053));
                                                            *(rax_125 + 2) = 
(truncf(((*(rax_125 + 2) * var_5c_1) + var_58_1), 0x38425053));
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    for (int32_t var_7c_7 = 0; var_7c_7 < 
(rax_11 * rax_9); var_7c_7 = (var_7c_7 + 1))
                                                    {
                                                        int64_t rax_90 = (var_7c_7 << 2);
                                                        void* rax_92 = (var_48_1 + (rax_90 + 
rax_90));
                                                        if ((*(rax_92 + 6) != 0 && *(rax_92 + 
6) != 0xffff))
                                                        {
                                                            float var_50_1 = (1f / (*(rax_92 + 
6) / 65535f));
                                                            float var_4c_1 = (65535f * (1f - 
var_50_1));
                                                            *rax_92 = (truncf(((*rax_92 * 
var_50_1) + var_4c_1), 0x38425053));
                                                            *(rax_92 + 2) = (truncf(((*(rax_92 
+ 2) * var_50_1) + var_4c_1), 0x38425053));
                                                            *(rax_92 + 4) = (truncf(((*(rax_92 
+ 4) * var_50_1) + var_4c_1), 0x38425053));
                                                        }
                                                    }
                                                }
                                            }
                                            if ((arg5 != 0 && arg5 != 4))
                                            {
                                                if (*arg6 != 0x10)
                                                {
                                                    var_48_1 = stbi__convert_format(var_48_1, 
4, arg5, rax_11, rax_9);
                                                }
                                                else
                                                {
                                                    var_48_1 = 
stbi__convert_format16(var_48_1, 4, arg5, rax_11, rax_9);
                                                }
                                                if (var_48_1 == 0)
                                                {
                                                    rax_2 = var_48_1;
                                                }
                                            }
                                            if (((arg5 == 0 || arg5 == 4) || ((arg5 != 0 && 
arg5 != 4) && var_48_1 != 0)))
                                            {
                                                if (arg4 != 0)
                                                {
                                                    *arg4 = 4;
                                                }
                                                *arg3 = rax_9;
                                                *arg2 = rax_11;
                                                rax_2 = var_48_1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if ((rax_13 != 8 && rax_13 != 0x10))
                    {
                        stbi__err("unsupported bit depth");
                        rax_2 = nullptr;
                    }
                }
            }
        }
    }
    return rax_2;
}

int64_t stbi__pic_is4(char* arg1, void* arg2)
{
    int32_t var_c = 0;
    int64_t rax_3;
    while (true)
    {
        if (var_c > 3)
        {
            rax_3 = 1;
            break;
        }
        if (stbi__get8(arg1) != *(arg2 + var_c) != 0)
        {
            rax_3 = 0;
            break;
        }
        var_c = (var_c + 1);
    }
    return rax_3;
}

int64_t stbi__pic_test_core(char* arg1)
{
    int32_t rax_1;
    rax_1 = stbi__pic_is4(arg1, &data_22f80) == 0;
    int64_t rax_2;
    if (rax_1 != 0)
    {
        rax_2 = 0;
    }
    else
    {
        for (int32_t var_c_1 = 0; var_c_1 <= 0x53; var_c_1 = (var_c_1 + 1))
        {
            stbi__get8(arg1);
        }
        int32_t rax_5;
        rax_5 = stbi__pic_is4(arg1, "PICT") == 0;
        if (rax_5 == 0)
        {
            rax_2 = 1;
        }
        else
        {
            rax_2 = 0;
        }
    }
    return rax_2;
}

int64_t stbi__readval(char* arg1, int32_t arg2, int64_t arg3)
{
    int32_t var_20 = 0x80;
    int32_t var_1c = 0;
    int64_t rax_5;
    while (true)
    {
        if (var_1c > 3)
        {
            rax_5 = arg3;
            break;
        }
        if ((arg2 & var_20) != 0)
        {
            int32_t rax_4;
            rax_4 = stbi__at_eof(arg1) != 0;
            if (rax_4 != 0)
            {
                stbi__err("bad file");
                rax_5 = 0;
                break;
            }
            *(var_1c + arg3) = stbi__get8(arg1);
        }
        var_1c = (var_1c + 1);
        var_20 = (var_20 >> 1);
    }
    return rax_5;
}

void stbi__copyval(int32_t arg1, void* arg2, void* arg3)
{
    int32_t var_10 = 0x80;
    int32_t var_c = 0;
    while (var_c <= 3)
    {
        if ((arg1 & var_10) != 0)
        {
            *(arg2 + var_c) = *(arg3 + var_c);
        }
        var_c = (var_c + 1);
        var_10 = (var_10 >> 1);
    }
}

struct Elf64_Header* const stbi__pic_load_core(char* arg1, int32_t arg2, 
    int32_t arg3, int32_t* arg4, struct Elf64_Header* arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t var_7c = 0;
    int32_t var_78 = 0;
    struct Elf64_Header* const rax_2;
    while (true)
    {
        if (var_78 == 0xa)
        {
            stbi__err("bad format");
            rax_2 = nullptr;
            break;
        }
        int32_t rax_3 = var_78;
        var_78 = (rax_3 + 1);
        int64_t rdx_1 = rax_3;
        void var_38;
        void* rax_7 = (((rdx_1 + rdx_1) + rdx_1) + &var_38);
        uint32_t rax_10 = stbi__get8(arg1);
        *rax_7 = stbi__get8(arg1);
        *(rax_7 + 1) = stbi__get8(arg1);
        *(rax_7 + 2) = stbi__get8(arg1);
        var_7c = (var_7c | *(rax_7 + 2));
        int32_t rax_21;
        rax_21 = stbi__at_eof(arg1) != 0;
        if (rax_21 != 0)
        {
            stbi__err("bad file");
            rax_2 = nullptr;
            break;
        }
        if (*rax_7 != 8)
        {
            stbi__err("bad format");
            rax_2 = nullptr;
            break;
        }
        if (rax_10 == 0)
        {
            int32_t rdx_5;
            if ((var_7c & 0x10) == 0)
            {
                rdx_5 = 3;
            }
            else
            {
                rdx_5 = 4;
            }
            *arg4 = rdx_5;
            int32_t var_74_1 = 0;
            int32_t var_70_1;
            do
            {
                if (var_74_1 >= arg3)
                {
                    rax_2 = arg5;
                    break;
                }
                var_70_1 = 0;
                while (true)
                {
                    if (var_70_1 >= var_78)
                    {
                        var_74_1 = (var_74_1 + 1);
                        break;
                    }
                    int64_t rdx_6 = var_70_1;
                    void* rax_31 = (((rdx_6 + rdx_6) + rdx_6) + &var_38);
                    void* var_50_1 = (arg5 + ((var_74_1 * arg2) << 2));
                    uint32_t rax_39 = *(rax_31 + 1);
                    void var_14;
                    if (rax_39 == 2)
                    {
                        int32_t var_60_1;
                        int32_t var_5c_2;
                        for (var_60_1 = arg2; var_60_1 > 0; var_60_1 = (var_60_1 - var_5c_2))
                        {
                            uint32_t rax_64 = stbi__get8(arg1);
                            int32_t rax_66;
                            rax_66 = stbi__at_eof(arg1) != 0;
                            if (rax_66 != 0)
                            {
                                stbi__err("bad file");
                                rax_2 = nullptr;
                                break;
                            }
                            if (rax_64 <= 0x7f)
                            {
                                var_5c_2 = (rax_64 + 1);
                                if (var_5c_2 > var_60_1)
                                {
                                    stbi__err("bad file");
                                    rax_2 = nullptr;
                                    break;
                                }
                                int32_t var_58_2 = 0;
                                while (var_58_2 < var_5c_2)
                                {
                                    int64_t rax_82;
                                    rax_82 = stbi__readval(arg1, *(rax_31 + 2), var_50_1) == 
0;
                                    if (rax_82 != 0)
                                    {
                                        break;
                                    }
                                    var_58_2 = (var_58_2 + 1);
                                    var_50_1 = (var_50_1 + 4);
                                }
                                if (var_58_2 < var_5c_2)
                                {
                                    rax_2 = nullptr;
                                    break;
                                }
                            }
                            else
                            {
                                if (rax_64 != 0x80)
                                {
                                    var_5c_2 = (rax_64 - 0x7f);
                                }
                                else
                                {
                                    var_5c_2 = stbi__get16be(arg1);
                                }
                                if (var_5c_2 > var_60_1)
                                {
                                    stbi__err("bad file");
                                    rax_2 = nullptr;
                                    break;
                                }
                                int64_t rax_73;
                                rax_73 = stbi__readval(arg1, *(rax_31 + 2), &var_14) == 0;
                                if (rax_73 != 0)
                                {
                                    rax_2 = nullptr;
                                    break;
                                }
                                int32_t var_58_1 = 0;
                                while (var_58_1 < var_5c_2)
                                {
                                    stbi__copyval(*(rax_31 + 2), var_50_1, &var_14);
                                    var_58_1 = (var_58_1 + 1);
                                    var_50_1 = (var_50_1 + 4);
                                }
                            }
                        }
                        if (var_60_1 > 0)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if ((rax_39 > 2 || ((rax_39 <= 2 && rax_39 != 0) && rax_39 != 1)))
                        {
                            stbi__err("bad format");
                            rax_2 = nullptr;
                            break;
                        }
                        if (rax_39 == 1)
                        {
                            char var_7d_1;
                            int32_t var_68_1;
                            for (var_68_1 = arg2; var_68_1 > 0; var_68_1 = (var_68_1 - 
var_7d_1))
                            {
                                var_7d_1 = stbi__get8(arg1);
                                int32_t rax_49;
                                rax_49 = stbi__at_eof(arg1) != 0;
                                if (rax_49 != 0)
                                {
                                    stbi__err("bad file");
                                    rax_2 = nullptr;
                                    break;
                                }
                                if (var_68_1 < var_7d_1)
                                {
                                    var_7d_1 = var_68_1;
                                }
                                int64_t rax_55;
                                rax_55 = stbi__readval(arg1, *(rax_31 + 2), &var_14) == 0;
                                if (rax_55 != 0)
                                {
                                    rax_2 = nullptr;
                                    break;
                                }
                                int32_t var_64_1 = 0;
                                while (var_64_1 < var_7d_1)
                                {
                                    stbi__copyval(*(rax_31 + 2), var_50_1, &var_14);
                                    var_64_1 = (var_64_1 + 1);
                                    var_50_1 = (var_50_1 + 4);
                                }
                            }
                            if (var_68_1 > 0)
                            {
                                break;
                            }
                        }
                        if (rax_39 == 0)
                        {
                            int32_t var_6c_1 = 0;
                            while (var_6c_1 < arg2)
                            {
                                int64_t rax_43;
                                rax_43 = stbi__readval(arg1, *(rax_31 + 2), var_50_1) == 0;
                                if (rax_43 != 0)
                                {
                                    break;
                                }
                                var_6c_1 = (var_6c_1 + 1);
                                var_50_1 = (var_50_1 + 4);
                            }
                            if (var_6c_1 < arg2)
                            {
                                rax_2 = nullptr;
                                break;
                            }
                        }
                    }
                    var_70_1 = (var_70_1 + 1);
                }
            } while (var_70_1 >= var_78);
            break;
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_2;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__pic_load(char* arg1, int32_t* arg2, int32_t* arg3, void* arg4, 
    int32_t arg5)
{
    void* var_48 = arg4;
    int32_t var_4c = arg5;
    int64_t r9;
    int64_t var_58 = r9;
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_28;
    if (var_48 == 0)
    {
        var_48 = &var_28;
    }
    for (int32_t var_24 = 0; var_24 <= 0x5b; var_24 = (var_24 + 1))
    {
        stbi__get8(arg1);
    }
    int32_t rax_4 = stbi__get16be(arg1);
    int32_t rax_6 = stbi__get16be(arg1);
    int64_t rax_7;
    if (rax_6 > 0x1000000)
    {
        stbi__err("too large");
        rax_7 = 0;
    }
    else if (rax_4 > 0x1000000)
    {
        stbi__err("too large");
        rax_7 = 0;
    }
    else
    {
        int32_t rax_9;
        rax_9 = stbi__at_eof(arg1) != 0;
        if (rax_9 != 0)
        {
            stbi__err("bad file");
            rax_7 = 0;
        }
        else
        {
            int32_t rax_11;
            rax_11 = stbi__mad3sizes_valid(rax_4, rax_6, 4, 0) == 0;
            if (rax_11 != 0)
            {
                stbi__err("too large");
                rax_7 = 0;
            }
            else
            {
                stbi__get32be(arg1);
                stbi__get16be(arg1);
                stbi__get16be(arg1);
                struct Elf64_Header* var_18_1 = stbi__malloc_mad3(rax_4, rax_6, 4, 0);
                if (var_18_1 == 0)
                {
                    stbi__err("outofmem");
                    rax_7 = 0;
                }
                else
                {
                    memset(var_18_1, 0xff, ((rax_4 * rax_6) << 2));
                    struct Elf64_Header* rax_22;
                    rax_22 = stbi__pic_load_core(arg1, rax_4, rax_6, var_48, var_18_1) == 0;
                    if (rax_22 != 0)
                    {
                        free(var_18_1);
                        var_18_1 = nullptr;
                    }
                    *arg2 = rax_4;
                    *arg3 = rax_6;
                    if (var_4c == 0)
                    {
                        var_4c = *var_48;
                    }
                    rax_7 = stbi__convert_format(var_18_1, 4, var_4c, rax_4, rax_6);
                }
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_7;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi__pic_test(char* arg1)
{
    int32_t rax_1 = stbi__pic_test_core(arg1);
    stbi__rewind(arg1);
    return rax_1;
}

int64_t stbi__gif_test_raw(char* arg1)
{
    char rax_8;
    if (stbi__get8(arg1) != 0x47)
    {
    label_19fff:
        rax_8 = 1;
    }
    else
    {
        if (stbi__get8(arg1) != 0x49)
        {
            goto label_19fff;
        }
        if (stbi__get8(arg1) != 0x46)
        {
            goto label_19fff;
        }
        if (stbi__get8(arg1) != 0x38)
        {
            goto label_19fff;
        }
        rax_8 = 0;
    }
    int64_t rax_9;
    if (rax_8 != 0)
    {
        rax_9 = 0;
    }
    else
    {
        uint32_t rax_12 = stbi__get8(arg1);
        if ((rax_12 == 0x39 || rax_12 == 0x37))
        {
            if (stbi__get8(arg1) != 0x61 == 0)
            {
                rax_9 = 1;
            }
            else
            {
                rax_9 = 0;
            }
        }
        if ((rax_12 != 0x39 && rax_12 != 0x37))
        {
            rax_9 = 0;
        }
    }
    return rax_9;
}

uint64_t stbi__gif_test(char* arg1)
{
    int32_t rax_1 = stbi__gif_test_raw(arg1);
    stbi__rewind(arg1);
    return rax_1;
}

uint64_t stbi__gif_parse_colortable(char* arg1, void* arg2, int32_t arg3, 
    int32_t arg4)
{
    int32_t var_1c = 0;
    uint64_t rax_21;
    while (true)
    {
        rax_21 = var_1c;
        if (rax_21 >= arg3)
        {
            break;
        }
        *(((var_1c << 2) + arg2) + 2) = stbi__get8(arg1);
        *(((var_1c << 2) + arg2) + 1) = stbi__get8(arg1);
        *((var_1c << 2) + arg2) = stbi__get8(arg1);
        char rcx;
        if (arg4 != var_1c)
        {
            rcx = -1;
        }
        else
        {
            rcx = 0;
        }
        *((arg2 + (var_1c << 2)) + 3) = rcx;
        var_1c = (var_1c + 1);
    }
    return rax_21;
}

int64_t stbi__gif_header(char* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4)
{
    char rax_8;
    if (stbi__get8(arg1) != 0x47)
    {
    label_1a1b2:
        rax_8 = 1;
    }
    else
    {
        if (stbi__get8(arg1) != 0x49)
        {
            goto label_1a1b2;
        }
        if (stbi__get8(arg1) != 0x46)
        {
            goto label_1a1b2;
        }
        if (stbi__get8(arg1) != 0x38)
        {
            goto label_1a1b2;
        }
        rax_8 = 0;
    }
    int64_t rax_9;
    if (rax_8 != 0)
    {
        rax_9 = stbi__err("not GIF");
    }
    else
    {
        char rax_11 = stbi__get8(arg1);
        if ((rax_11 == 0x37 || rax_11 == 0x39))
        {
            if (stbi__get8(arg1) != 0x61 != 0)
            {
                rax_9 = stbi__err("not GIF");
            }
            else
            {
                void* fsbase;
                *(fsbase - 0x20) = &data_22f9b;
                *arg2 = stbi__get16le(arg1);
                arg2[1] = stbi__get16le(arg1);
                arg2[8] = stbi__get8(arg1);
                arg2[9] = stbi__get8(arg1);
                arg2[0xa] = stbi__get8(arg1);
                arg2[0xb] = 0xffffffff;
                if (*arg2 > 0x1000000)
                {
                    rax_9 = stbi__err("too large");
                }
                else if (arg2[1] > 0x1000000)
                {
                    rax_9 = stbi__err("too large");
                }
                else
                {
                    if (arg3 != 0)
                    {
                        *arg3 = 4;
                    }
                    if (arg4 != 0)
                    {
                        rax_9 = 1;
                    }
                    else
                    {
                        if ((arg2[8] & 0x80) != 0)
                        {
                            stbi__gif_parse_colortable(arg1, &arg2[0xd], (2 << (arg2[8] & 7)), 
0xffffffff);
                        }
                        rax_9 = 1;
                    }
                }
            }
        }
        if ((rax_11 != 0x37 && rax_11 != 0x39))
        {
            rax_9 = stbi__err("not GIF");
        }
    }
    return rax_9;
}

int64_t stbi__gif_info_raw(char* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4)
{
    int32_t* rax = stbi__malloc(0x8870);
    int64_t rax_1;
    if (rax == 0)
    {
        rax_1 = stbi__err("outofmem");
    }
    else
    {
        int32_t rax_3;
        rax_3 = stbi__gif_header(arg1, rax, arg4, 1) == 0;
        if (rax_3 != 0)
        {
            free(rax);
            stbi__rewind(arg1);
            rax_1 = 0;
        }
        else
        {
            if (arg2 != 0)
            {
                *arg2 = *rax;
            }
            if (arg3 != 0)
            {
                *arg3 = rax[1];
            }
            free(rax);
            rax_1 = 1;
        }
    }
    return rax_1;
}

uint64_t stbi__out_gif_code(void* arg1, int16_t arg2)
{
    if (*((arg1 + ((arg2 + 0x20c) << 2)) + 4) >= 0)
    {
        stbi__out_gif_code(arg1, *((arg1 + ((arg2 + 0x20c) << 2)) + 4));
    }
    uint64_t rax_8 = *(arg1 + 0x8858);
    if (*(arg1 + 0x8860) < rax_8)
    {
        int32_t rax_12 = (*(arg1 + 0x8860) + *(arg1 + 0x885c));
        char* rax_16 = (rax_12 + *(arg1 + 8));
        int32_t rax_18 = rax_12;
        if (rax_18 < 0)
        {
            rax_18 = (rax_18 + 3);
        }
        *((rax_18 >> 2) + *(arg1 + 0x18)) = 1;
        char* rax_28 = ((*((arg1 + ((arg2 + 0x20c) << 2)) + 7) << 2) + *(arg1 + 0x8838));
        if (rax_28[3] > 0x80)
        {
            *rax_16 = rax_28[2];
            rax_16[1] = rax_28[1];
            rax_16[2] = *rax_28;
            rax_16[3] = rax_28[3];
        }
        *(arg1 + 0x885c) = (*(arg1 + 0x885c) + 4);
        rax_8 = *(arg1 + 0x8854);
        if (*(arg1 + 0x885c) >= rax_8)
        {
            *(arg1 + 0x885c) = *(arg1 + 0x884c);
            *(arg1 + 0x8860) = (*(arg1 + 0x8860) + *(arg1 + 0x8844));
            while (true)
            {
                rax_8 = *(arg1 + 0x8858);
                if (*(arg1 + 0x8860) < rax_8)
                {
                    break;
                }
                rax_8 = *(arg1 + 0x8840);
                if (rax_8 <= 0)
                {
                    break;
                }
                *(arg1 + 0x8844) = (*(arg1 + 0x8864) << *(arg1 + 0x8840));
                *(arg1 + 0x8860) = (*(arg1 + 0x8850) + (*(arg1 + 0x8844) >> 1));
                *(arg1 + 0x8840) = (*(arg1 + 0x8840) - 1);
            }
        }
    }
    return rax_8;
}

int64_t stbi__process_gif_raster(char* arg1, void* arg2)
{
    char rax_1 = stbi__get8(arg1);
    int64_t rax_2;
    if (rax_1 > 0xc)
    {
        rax_2 = 0;
    }
    else
    {
        int32_t rdx_1 = (1 << rax_1);
        int32_t var_34_1 = 1;
        int32_t var_30_1 = (rax_1 + 1);
        int32_t var_2c_1 = ((1 << var_30_1) - 1);
        int32_t var_20_1 = 0;
        int32_t var_1c_1 = 0;
        for (int32_t var_38_1 = 0; var_38_1 < rdx_1; var_38_1 = (var_38_1 + 1))
        {
            *((arg2 + ((var_38_1 + 0x20c) << 2)) + 4) = 0xffff;
            *((arg2 + ((var_38_1 + 0x20c) << 2)) + 6) = var_38_1;
            *((arg2 + ((var_38_1 + 0x20c) << 2)) + 7) = var_38_1;
        }
        int32_t var_28_1 = (rdx_1 + 2);
        int32_t var_24_1 = 0xffffffff;
        uint32_t var_3c_1 = 0;
        while (true)
        {
            if (var_1c_1 >= var_30_1)
            {
                int32_t rax_28 = (var_20_1 & var_2c_1);
                var_20_1 = (var_20_1 >> var_30_1);
                var_1c_1 = (var_1c_1 - var_30_1);
                if (rax_28 == rdx_1)
                {
                    var_30_1 = (rax_1 + 1);
                    var_2c_1 = ((1 << var_30_1) - 1);
                    var_28_1 = (rdx_1 + 2);
                    var_24_1 = 0xffffffff;
                    var_34_1 = 0;
                }
                else
                {
                    if (rax_28 == (rdx_1 + 1))
                    {
                        stbi__skip(arg1, var_3c_1);
                        while (true)
                        {
                            uint32_t var_3c_2 = stbi__get8(arg1);
                            uint32_t rax_45;
                            rax_45 = var_3c_2 > 0;
                            if (rax_45 == 0)
                            {
                                break;
                            }
                            stbi__skip(arg1, var_3c_2);
                        }
                        rax_2 = *(arg2 + 8);
                        break;
                    }
                    if (rax_28 > var_28_1)
                    {
                        stbi__err("illegal code in raster");
                        rax_2 = 0;
                        break;
                    }
                    if (var_34_1 != 0)
                    {
                        stbi__err("no clear code");
                        rax_2 = 0;
                        break;
                    }
                    if (var_24_1 >= 0)
                    {
                        int32_t rax_48 = var_28_1;
                        var_28_1 = (rax_48 + 1);
                        if (var_28_1 > 0x2000)
                        {
                            stbi__err("too many codes");
                            rax_2 = 0;
                            break;
                        }
                        *((arg2 + ((rax_48 + 0x20c) << 2)) + 4) = var_24_1;
                        *((arg2 + ((rax_48 + 0x20c) << 2)) + 6) = *((arg2 + ((var_24_1 + 
0x20c) << 2)) + 6);
                        char rax_60;
                        if (rax_28 != var_28_1)
                        {
                            rax_60 = *((arg2 + ((rax_28 + 0x20c) << 2)) + 6);
                        }
                        else
                        {
                            rax_60 = *((arg2 + ((rax_48 + 0x20c) << 2)) + 6);
                        }
                        *((arg2 + ((rax_48 + 0x20c) << 2)) + 7) = rax_60;
                    }
                    else if (rax_28 == var_28_1)
                    {
                        stbi__err("illegal code in raster");
                        rax_2 = 0;
                        break;
                    }
                    stbi__out_gif_code(arg2, rax_28);
                    if (((var_28_1 & var_2c_1) == 0 && var_28_1 <= 0xfff))
                    {
                        var_30_1 = (var_30_1 + 1);
                        var_2c_1 = ((1 << var_30_1) - 1);
                    }
                    var_24_1 = rax_28;
                }
            }
            else
            {
                if (var_3c_1 == 0)
                {
                    var_3c_1 = stbi__get8(arg1);
                    if (var_3c_1 == 0)
                    {
                        rax_2 = *(arg2 + 8);
                        break;
                    }
                }
                var_3c_1 = (var_3c_1 - 1);
                var_20_1 = (var_20_1 | (stbi__get8(arg1) << var_1c_1));
                var_1c_1 = (var_1c_1 + 8);
            }
        }
    }
    return rax_2;
}

char* stbi__gif_load_next(char* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t arg4, int64_t arg5)
{
    int32_t var_64 = arg4;
    int32_t var_38 = 0;
    int32_t rax_3;
    char* rax_4;
    int32_t rax_8;
    if (*(arg2 + 8) == 0)
    {
        rax_3 = stbi__gif_header(arg1, arg2, arg3, 0) == 0;
        if (rax_3 == 0)
        {
            rax_8 = stbi__mad3sizes_valid(4, *arg2, arg2[1], 0) == 0;
            if (rax_8 == 0)
            {
                int32_t rax_12 = (arg2[1] * *arg2);
                *(arg2 + 8) = stbi__malloc((rax_12 << 2));
                *(arg2 + 0x10) = stbi__malloc((rax_12 << 2));
                *(arg2 + 0x18) = stbi__malloc(rax_12);
                if ((*(arg2 + 0x10) == 0 || (*(arg2 + 0x10) != 0 && *(arg2 + 0x18) == 0)))
                {
                    stbi__err("outofmem");
                    rax_4 = nullptr;
                }
                if ((*(arg2 + 0x10) != 0 && *(arg2 + 0x18) != 0))
                {
                    memset(*(arg2 + 8), 0, (rax_12 << 2));
                    memset(*(arg2 + 0x10), 0, (rax_12 << 2));
                    memset(*(arg2 + 0x18), 0, rax_12);
                    var_38 = 1;
                }
            }
            else
            {
                stbi__err("too large");
                rax_4 = nullptr;
            }
        }
        else
        {
            rax_4 = nullptr;
        }
    }
    else
    {
        int32_t var_3c_1 = ((arg2[0xc] >> 2) & 7);
        int32_t rax_48 = (arg2[1] * *arg2);
        if ((var_3c_1 == 3 && arg5 == 0))
        {
            var_3c_1 = 2;
        }
        if (var_3c_1 == 3)
        {
            for (int32_t var_34_1 = 0; var_34_1 < rax_48; var_34_1 = (var_34_1 + 1))
            {
                if (*(var_34_1 + *(arg2 + 0x18)) != 0)
                {
                    *(*(arg2 + 8) + (var_34_1 << 2)) = *((var_34_1 << 2) + arg5);
                }
            }
        }
        else if (var_3c_1 == 2)
        {
            for (int32_t var_34_2 = 0; var_34_2 < rax_48; var_34_2 = (var_34_2 + 1))
            {
                if (*(var_34_2 + *(arg2 + 0x18)) != 0)
                {
                    *(*(arg2 + 8) + (var_34_2 << 2)) = *(*(arg2 + 0x10) + (var_34_2 << 2));
                }
            }
        }
        memcpy(*(arg2 + 0x10), *(arg2 + 8), ((arg2[1] * *arg2) << 2));
    }
    if ((((((*(arg2 + 8) == 0 && rax_3 == 0) && rax_8 == 0) && *(arg2 + 0x10) != 0) && *(arg2 
+ 0x18) != 0) || *(arg2 + 8) != 0))
    {
        memset(*(arg2 + 0x18), 0, (arg2[1] * *arg2));
        while (true)
        {
            uint32_t rax_94 = stbi__get8(arg1);
            if (rax_94 == 0x3b)
            {
                rax_4 = arg1;
                break;
            }
            if (rax_94 == 0x21)
            {
                if (stbi__get8(arg1) == 0xf9)
                {
                    uint32_t rax_192 = stbi__get8(arg1);
                    if (rax_192 != 4)
                    {
                        stbi__skip(arg1, rax_192);
                        continue;
                    }
                    else
                    {
                        arg2[0xc] = stbi__get8(arg1);
                        int32_t rax_200 = (stbi__get16le(arg1) * 5);
                        arg2[0x221a] = (rax_200 + rax_200);
                        if (arg2[0xb] >= 0)
                        {
                            *(&arg2[arg2[0xb]] + 0x37) = 0xff;
                        }
                        if ((arg2[0xc] & 1) == 0)
                        {
                            stbi__skip(arg1, 1);
                            arg2[0xb] = 0xffffffff;
                        }
                        else
                        {
                            arg2[0xb] = stbi__get8(arg1);
                            if (arg2[0xb] >= 0)
                            {
                                *(&arg2[arg2[0xb]] + 0x37) = 0;
                            }
                        }
                    }
                }
                while (true)
                {
                    uint32_t var_14_2 = stbi__get8(arg1);
                    uint32_t rax_223;
                    rax_223 = var_14_2 != 0;
                    if (rax_223 == 0)
                    {
                        break;
                    }
                    stbi__skip(arg1, var_14_2);
                }
                continue;
            }
            else if (rax_94 == 0x2c)
            {
                int32_t rax_96 = stbi__get16le(arg1);
                int32_t rax_98 = stbi__get16le(arg1);
                int32_t rax_100 = stbi__get16le(arg1);
                int32_t rax_102 = stbi__get16le(arg1);
                if (((rax_96 + rax_100) > *arg2 || ((rax_96 + rax_100) <= *arg2 && (rax_98 + 
rax_102) > arg2[1])))
                {
                    stbi__err("bad Image Descriptor");
                    rax_4 = nullptr;
                }
                if (((rax_96 + rax_100) <= *arg2 && (rax_98 + rax_102) <= arg2[1]))
                {
                    arg2[0x2219] = (*arg2 << 2);
                    arg2[0x2213] = (rax_96 << 2);
                    arg2[0x2214] = (arg2[0x2219] * rax_98);
                    arg2[0x2215] = ((rax_100 << 2) + arg2[0x2213]);
                    arg2[0x2216] = (arg2[0x2214] + (arg2[0x2219] * rax_102));
                    arg2[0x2217] = arg2[0x2213];
                    arg2[0x2218] = arg2[0x2214];
                    if (rax_100 == 0)
                    {
                        arg2[0x2218] = arg2[0x2216];
                    }
                    arg2[0x2212] = stbi__get8(arg1);
                    if ((arg2[0x2212] & 0x40) == 0)
                    {
                        arg2[0x2211] = arg2[0x2219];
                        arg2[0x2210] = 0;
                    }
                    else
                    {
                        arg2[0x2211] = (arg2[0x2219] << 3);
                        arg2[0x2210] = 3;
                    }
                    if ((arg2[0x2212] & 0x80) == 0)
                    {
                        if ((arg2[8] & 0x80) == 0)
                        {
                            stbi__err("missing color table");
                            rax_4 = nullptr;
                        }
                        else
                        {
                            *(arg2 + 0x8838) = &arg2[0xd];
                        }
                    }
                    else
                    {
                        int32_t rax_152;
                        if ((arg2[0xc] & 1) == 0)
                        {
                            rax_152 = -1;
                        }
                        else
                        {
                            rax_152 = arg2[0xb];
                        }
                        stbi__gif_parse_colortable(arg1, &arg2[0x10d], (2 << (arg2[0x2212] & 
7)), rax_152);
                        *(arg2 + 0x8838) = &arg2[0x10d];
                    }
                    if ((((arg2[0x2212] & 0x80) == 0 && (arg2[8] & 0x80) != 0) || 
(arg2[0x2212] & 0x80) != 0))
                    {
                        char* rax_161 = stbi__process_gif_raster(arg1, arg2);
                        if (rax_161 == 0)
                        {
                            rax_4 = nullptr;
                        }
                        else
                        {
                            int32_t rax_165 = (arg2[1] * *arg2);
                            if ((var_38 != 0 && arg2[9] > 0))
                            {
                                for (int32_t var_34_3 = 0; var_34_3 < rax_165; var_34_3 = 
(var_34_3 + 1))
                                {
                                    if (*(var_34_3 + *(arg2 + 0x18)) == 0)
                                    {
                                        *(&arg2[arg2[9]] + 0x37) = 0xff;
                                        *(*(arg2 + 8) + (var_34_3 << 2)) = arg2[(arg2[9] + 
0xd)];
                                    }
                                }
                            }
                            rax_4 = rax_161;
                        }
                    }
                }
                break;
            }
            stbi__err("unknown code");
            rax_4 = nullptr;
            break;
        }
    }
    return rax_4;
}

int64_t stbi__load_gif_main_outofmem(void* arg1, int64_t arg2, int64_t* arg3)
{
    free(*(arg1 + 8));
    free(*(arg1 + 0x18));
    free(*(arg1 + 0x10));
    if (arg2 != 0)
    {
        free(arg2);
    }
    if ((arg3 != 0 && *arg3 != 0))
    {
        free(*arg3);
    }
    stbi__err("outofmem");
    return 0;
}

int64_t stbi__load_gif_main(char* arg1, int64_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t* arg5, int32_t* arg6, int32_t arg7)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t rax_2;
    rax_2 = stbi__gif_test(arg1) != 0;
    int64_t rax_16;
    if (rax_2 == 0)
    {
        stbi__err("not GIF");
        rax_16 = 0;
    }
    else
    {
        int32_t var_88c0_1 = 0;
        int64_t var_88b0;
        __builtin_memset(var_88b0, 0, 0x18);
        int32_t var_88bc_1 = 0;
        int32_t var_88b8_1 = 0;
        int32_t var_8888;
        memset(&var_8888, 0, 0x8870);
        if (arg2 != 0)
        {
            *arg2 = 0;
        }
        while (true)
        {
            int64_t var_88a0_1;
            char* var_88b0_1 = stbi__gif_load_next(arg1, &var_8888, arg6, arg7, var_88a0_1);
            if (var_88b0_1 == arg1)
            {
                var_88b0_1 = nullptr;
            }
            int64_t var_88a8_1;
            int32_t var_8884;
            if (var_88b0_1 != 0)
            {
                *arg3 = var_8888;
                *arg4 = var_8884;
                var_88c0_1 = (var_88c0_1 + 1);
                int32_t rax_11 = ((var_8884 * var_8888) << 2);
                if (var_88a8_1 == 0)
                {
                    var_88a8_1 = stbi__malloc((var_88c0_1 * rax_11));
                    if (var_88a8_1 == 0)
                    {
                        rax_16 = stbi__load_gif_main_outofmem(&var_8888, var_88a8_1, arg2);
                        break;
                    }
                    int32_t var_88bc_3 = (var_88c0_1 * rax_11);
                    if (arg2 != 0)
                    {
                        *arg2 = stbi__malloc((var_88c0_1 << 2));
                        if (*arg2 == 0)
                        {
                            rax_16 = stbi__load_gif_main_outofmem(&var_8888, var_88a8_1, 
arg2);
                            break;
                        }
                        int32_t var_88b8_3 = (var_88c0_1 << 2);
                    }
                }
                else
                {
                    int64_t rax_15 = realloc(var_88a8_1, (var_88c0_1 * rax_11));
                    if (rax_15 == 0)
                    {
                        rax_16 = stbi__load_gif_main_outofmem(&var_8888, var_88a8_1, arg2);
                        break;
                    }
                    var_88a8_1 = rax_15;
                    int32_t var_88bc_2 = (var_88c0_1 * rax_11);
                    if (arg2 != 0)
                    {
                        int64_t rax_24 = realloc(*arg2, (var_88c0_1 << 2));
                        if (rax_24 == 0)
                        {
                            rax_16 = stbi__load_gif_main_outofmem(&var_8888, var_88a8_1, 
arg2);
                            break;
                        }
                        *arg2 = rax_24;
                        int32_t var_88b8_2 = (var_88c0_1 << 2);
                    }
                }
                memcpy((((var_88c0_1 - 1) * rax_11) + var_88a8_1), var_88b0_1, rax_11);
                if (var_88c0_1 > 1)
                {
                    var_88a0_1 = (var_88a8_1 + (-(rax_11 + rax_11)));
                }
                int32_t var_20;
                if (arg2 != 0)
                {
                    *(((var_88c0_1 - 1) << 2) + *arg2) = var_20;
                }
            }
            if (var_88b0_1 == 0)
            {
                int64_t var_8880;
                free(var_8880);
                int64_t var_8870;
                free(var_8870);
                int64_t var_8878;
                free(var_8878);
                if ((arg7 != 0 && arg7 != 4))
                {
                    var_88a8_1 = stbi__convert_format(var_88a8_1, 4, arg7, (var_8888 * 
var_88c0_1), var_8884);
                }
                *arg5 = var_88c0_1;
                rax_16 = var_88a8_1;
                break;
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_16;
    }
    __stack_chk_fail();
    /* no return */
}

char* stbi__gif_load(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, 
    int32_t arg5)
{
    int64_t r9;
    int64_t var_88c8 = r9;
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t var_8890 = 0;
    int32_t var_8888;
    memset(&var_8888, 0, 0x8870);
    char* var_8890_1 = stbi__gif_load_next(arg1, &var_8888, arg4, arg5, 0);
    if (var_8890_1 == arg1)
    {
        var_8890_1 = nullptr;
    }
    int64_t var_8880;
    if (var_8890_1 != 0)
    {
        *arg2 = var_8888;
        int32_t var_8884;
        *arg3 = var_8884;
        if ((arg5 != 0 && arg5 != 4))
        {
            var_8890_1 = stbi__convert_format(var_8890_1, 4, arg5, var_8888, var_8884);
        }
    }
    else if (var_8880 != 0)
    {
        free(var_8880);
    }
    int64_t var_8870;
    free(var_8870);
    int64_t var_8878;
    free(var_8878);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return var_8890_1;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__gif_info(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)
{
    return stbi__gif_info_raw(arg1, arg2, arg3, arg4);
}

int64_t stbi__hdr_test_core(char* arg1, void* arg2)
{
    int32_t var_c = 0;
    int64_t rax_8;
    while (true)
    {
        if (*(arg2 + var_c) == 0)
        {
            stbi__rewind(arg1);
            rax_8 = 1;
            break;
        }
        int32_t rax_7;
        rax_7 = stbi__get8(arg1) != *(arg2 + var_c);
        if (rax_7 != 0)
        {
            rax_8 = 0;
            break;
        }
        var_c = (var_c + 1);
    }
    return rax_8;
}

uint64_t stbi__hdr_test(char* arg1)
{
    int32_t var_c = stbi__hdr_test_core(arg1, "#?RADIANCE\n");
    stbi__rewind(arg1);
    if (var_c == 0)
    {
        var_c = stbi__hdr_test_core(arg1, "#?RGBE\n");
        stbi__rewind(arg1);
    }
    return var_c;
}

void* stbi__hdr_gettoken(char* arg1, void* arg2)
{
    int32_t var_c = 0;
    char var_d = 0;
    char var_d_1 = stbi__get8(arg1);
    while (true)
    {
        int32_t rax_13 = stbi__at_eof(arg1);
        char rax_14;
        if ((rax_13 != 0 || (rax_13 == 0 && var_d_1 == 0xa)))
        {
            rax_14 = 0;
        }
        if ((rax_13 == 0 && var_d_1 != 0xa))
        {
            rax_14 = 1;
        }
        if (rax_14 == 0)
        {
            break;
        }
        int32_t rax_2 = var_c;
        var_c = (rax_2 + 1);
        *(rax_2 + arg2) = var_d_1;
        if (var_c == 0x3ff)
        {
            char rax_9;
            do
            {
                int32_t rax_6 = stbi__at_eof(arg1);
                char rax_8;
                if (rax_6 == 0)
                {
                    rax_8 = stbi__get8(arg1);
                    if (rax_8 != 0xa)
                    {
                        rax_9 = 1;
                    }
                }
                if ((rax_6 != 0 || (rax_6 == 0 && rax_8 == 0xa)))
                {
                    rax_9 = 0;
                }
            } while (rax_9 != 0);
            break;
        }
        var_d_1 = stbi__get8(arg1);
    }
    *(arg2 + var_c) = 0;
    return arg2;
}

uint64_t stbi__hdr_convert(uint64_t arg1, char* arg2, int32_t arg3)
{
    uint64_t rax_2 = arg2[3];
    if (rax_2 != 0)
    {
        float var_c_1 = std::ldexp((arg2[3] - 0x88), arg2);
        if (arg3 > 2)
        {
            *arg1 = (*arg2 * var_c_1);
            *(arg1 + 4) = (arg2[1] * var_c_1);
            rax_2 = (arg1 + 8);
            *rax_2 = (arg2[2] * var_c_1);
        }
        else
        {
            rax_2 = arg1;
            *rax_2 = (((arg2[2] + (*arg2 + arg2[1])) * var_c_1) / 3f);
        }
        if (arg3 == 2)
        {
            rax_2 = (arg1 + 4);
            *rax_2 = 0x3f800000;
        }
        if (arg3 == 4)
        {
            rax_2 = (arg1 + 0xc);
            *rax_2 = 0x3f800000;
        }
    }
    else
    {
        if (arg3 == 4)
        {
            *(arg1 + 0xc) = 0x3f800000;
        }
        if ((arg3 == 4 || arg3 == 3))
        {
            *(arg1 + 8) = {0};
            *(arg1 + 4) = *(arg1 + 8);
            rax_2 = arg1;
            *rax_2 = *(arg1 + 4);
        }
        if ((((arg3 != 4 && arg3 <= 4) && arg3 != 3) && arg3 <= 3))
        {
            if (arg3 == 2)
            {
                *(arg1 + 4) = 0x3f800000;
            }
            if ((arg3 == 2 || arg3 == 1))
            {
                rax_2 = arg1;
                *rax_2 = 0;
            }
        }
    }
    return rax_2;
}

uint64_t stbi__hdr_load(char* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5)
{
    int32_t var_49c = arg5;
    int64_t r9;
    int64_t var_4a8 = r9;
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t var_46c = 0;
    void var_418;
    char* rax_2 = stbi__hdr_gettoken(arg1, &var_418);
    int32_t rax_4 = strcmp(rax_2, "#?RADIANCE");
    int32_t rax_6;
    uint64_t rax_7;
    if (rax_4 != 0)
    {
        rax_6 = strcmp(rax_2, "#?RGBE");
        if (rax_6 != 0)
        {
            stbi__err("not HDR");
            rax_7 = 0;
        }
    }
    if ((rax_4 == 0 || (rax_4 != 0 && rax_6 == 0)))
    {
        char* var_440;
        while (true)
        {
            var_440 = stbi__hdr_gettoken(arg1, &var_418);
            if (*var_440 == 0)
            {
                break;
            }
            if (strcmp(var_440, "FORMAT=32-bit_rle_rgbe") == 0)
            {
                var_46c = 1;
            }
        }
        if (var_46c == 0)
        {
            stbi__err("unsupported format");
            rax_7 = 0;
        }
        else
        {
            var_440 = stbi__hdr_gettoken(arg1, &var_418);
            if (strncmp(var_440, &data_2305e, 3) != 0)
            {
                stbi__err("unsupported data layout");
                rax_7 = 0;
            }
            else
            {
                var_440 = &var_440[3];
                int32_t rax_21 = strtol(var_440, &var_440, 0xa);
                while (*var_440 == 0x20)
                {
                    var_440 = &var_440[1];
                }
                if (strncmp(var_440, &data_2307a, 3) != 0)
                {
                    stbi__err("unsupported data layout");
                    rax_7 = 0;
                }
                else
                {
                    var_440 = &var_440[3];
                    int32_t rax_31 = strtol(var_440, nullptr, 0xa);
                    if (rax_21 > 0x1000000)
                    {
                        stbi__err("too large");
                        rax_7 = 0;
                    }
                    else if (rax_31 > 0x1000000)
                    {
                        stbi__err("too large");
                        rax_7 = 0;
                    }
                    else
                    {
                        *arg2 = rax_31;
                        *arg3 = rax_21;
                        if (arg4 != 0)
                        {
                            *arg4 = 3;
                        }
                        if (var_49c == 0)
                        {
                            var_49c = 3;
                        }
                        int32_t rax_36;
                        rax_36 = stbi__mad4sizes_valid(rax_31, rax_21, var_49c, 4, 0) == 0;
                        if (rax_36 != 0)
                        {
                            stbi__err("too large");
                            rax_7 = 0;
                        }
                        else
                        {
                            uint64_t rax_38 = stbi__malloc_mad4(rax_31, rax_21, var_49c, 4, 
0);
                            if (rax_38 == 0)
                            {
                                stbi__err("outofmem");
                                rax_7 = 0;
                            }
                            else
                            {
                                int32_t var_464_1;
                                if ((rax_31 <= 7 || (rax_31 > 7 && rax_31 > 0x7fff)))
                                {
                                    var_464_1 = 0;
                                }
                                int32_t var_468_1;
                                if ((rax_31 > 7 && rax_31 <= 0x7fff))
                                {
                                    int64_t var_438_1 = 0;
                                    int32_t var_464_2 = 0;
                                    while (true)
                                    {
                                        if (var_464_2 >= rax_21)
                                        {
                                            if (var_438_1 != 0)
                                            {
                                                free(var_438_1);
                                            }
                                            break;
                                        }
                                        uint32_t rax_52 = stbi__get8(arg1);
                                        uint32_t rax_55 = stbi__get8(arg1);
                                        uint32_t rax_58 = stbi__get8(arg1);
                                        if ((rax_52 == 2 && (rax_55 == 2 && (rax_58 & 0x80) == 
0)))
                                        {
                                            if (((rax_58 << 8) | stbi__get8(arg1)) != rax_31)
                                            {
                                                free(rax_38);
                                                free(var_438_1);
                                                stbi__err("invalid decoded scanline length");
                                                rax_7 = 0;
                                                goto label_1c451;
                                            }
                                            if (var_438_1 == 0)
                                            {
                                                var_438_1 = stbi__malloc_mad2(rax_31, 4, 0);
                                                if (var_438_1 == 0)
                                                {
                                                    free(rax_38);
                                                    stbi__err("outofmem");
                                                    rax_7 = 0;
                                                    goto label_1c451;
                                                }
                                            }
                                            int32_t var_460_1 = 0;
                                            while (var_460_1 <= 3)
                                            {
                                                int32_t var_468_2 = 0;
                                                int32_t rax_102;
                                                while (true)
                                                {
                                                    int32_t var_444_1 = (rax_31 - var_468_2);
                                                    rax_102 = var_444_1 > 0;
                                                    if (rax_102 == 0)
                                                    {
                                                        var_460_1 = (var_460_1 + 1);
                                                        break;
                                                    }
                                                    char rax_78 = stbi__get8(arg1);
                                                    if (rax_78 > 0x80)
                                                    {
                                                        char rax_80 = stbi__get8(arg1);
                                                        if ((rax_78 != 0x80 && var_444_1 >= 
(rax_78 - 0x80)))
                                                        {
                                                            for (int32_t var_45c_1 = 0; 
var_45c_1 < (rax_78 - 0x80); var_45c_1 = (var_45c_1 + 1))
                                                            {
                                                                uint64_t rax_84 = var_468_2;
                                                                var_468_2 = (rax_84 + 1);
                                                                *((var_460_1 + (rax_84 << 2)) 
+ var_438_1) = rax_80;
                                                            }
                                                            continue;
                                                        }
                                                        free(rax_38);
                                                        free(var_438_1);
                                                        stbi__err("corrupt");
                                                        rax_7 = 0;
                                                        break;
                                                    }
                                                    if ((rax_78 != 0 && var_444_1 >= rax_78))
                                                    {
                                                        for (int32_t var_45c_2 = 0; var_45c_2 
< rax_78; var_45c_2 = (var_45c_2 + 1))
                                                        {
                                                            uint64_t rax_95 = var_468_2;
                                                            var_468_2 = (rax_95 + 1);
                                                            *((var_460_1 + (rax_95 << 2)) + 
var_438_1) = stbi__get8(arg1);
                                                        }
                                                        continue;
                                                    }
                                                    free(rax_38);
                                                    free(var_438_1);
                                                    stbi__err("corrupt");
                                                    rax_7 = 0;
                                                    break;
                                                }
                                                if (rax_102 != 0)
                                                {
                                                    break;
                                                }
                                            }
                                            if (var_460_1 <= 3)
                                            {
                                                goto label_1c451;
                                            }
                                            for (int32_t var_468_3 = 0; var_468_3 < rax_31; 
var_468_3 = (var_468_3 + 1))
                                            {
                                                stbi__hdr_convert(((((var_468_3 + (var_464_2 * 
rax_31)) * var_49c) << 2) + rax_38), ((var_468_3 << 2) + var_438_1), var_49c);
                                            }
                                            var_464_2 = (var_464_2 + 1);
                                            continue;
                                        }
                                        char var_41c = rax_52;
                                        char var_41b_1 = rax_55;
                                        char var_41a_1 = rax_58;
                                        char var_419_1 = stbi__get8(arg1);
                                        stbi__hdr_convert(rax_38, &var_41c, var_49c);
                                        var_468_1 = 1;
                                        var_464_1 = 0;
                                        free(var_438_1);
                                        do
                                        {
                                            stbi__getn(arg1, &var_41c, 4);
                                            stbi__hdr_convert(((((var_468_1 * var_49c) + 
((var_464_1 * rax_31) * var_49c)) << 2) + rax_38), &var_41c, var_49c);
                                            var_468_1 = (var_468_1 + 1);
                                        label_1bfbf:
                                        } while (var_468_1 < rax_31);
                                        var_464_1 = (var_464_1 + 1);
                                        break;
                                    }
                                    if (var_464_2 >= rax_21)
                                    {
                                        goto label_1c446;
                                    }
                                }
                                if (var_464_1 < rax_21)
                                {
                                    var_468_1 = 0;
                                    goto label_1bfbf;
                                }
                            label_1c446:
                                rax_7 = rax_38;
                            }
                        }
                    }
                }
            }
        }
    }
label_1c451:
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_7;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__hdr_info(char* arg1, void* arg2, void* arg3, void* arg4)
{
    void* var_438 = arg2;
    void* var_440 = arg3;
    void* var_448 = arg4;
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t var_424 = 0;
    void var_428;
    if (var_438 == 0)
    {
        var_438 = &var_428;
    }
    if (var_440 == 0)
    {
        var_440 = &var_428;
    }
    if (var_448 == 0)
    {
        var_448 = &var_428;
    }
    int32_t rax_3;
    rax_3 = stbi__hdr_test(arg1) == 0;
    int64_t rax_5;
    if (rax_3 != 0)
    {
        stbi__rewind(arg1);
        rax_5 = 0;
    }
    else
    {
        char* var_420;
        void var_418;
        while (true)
        {
            var_420 = stbi__hdr_gettoken(arg1, &var_418);
            if (*var_420 == 0)
            {
                break;
            }
            if (strcmp(var_420, "FORMAT=32-bit_rle_rgbe") == 0)
            {
                var_424 = 1;
            }
        }
        if (var_424 == 0)
        {
            stbi__rewind(arg1);
            rax_5 = 0;
        }
        else
        {
            var_420 = stbi__hdr_gettoken(arg1, &var_418);
            if (strncmp(var_420, &data_2305e, 3) != 0)
            {
                stbi__rewind(arg1);
                rax_5 = 0;
            }
            else
            {
                var_420 = &var_420[3];
                *var_440 = strtol(var_420, &var_420, 0xa);
                while (*var_420 == 0x20)
                {
                    var_420 = &var_420[1];
                }
                if (strncmp(var_420, &data_2307a, 3) == 0)
                {
                    var_420 = &var_420[3];
                    *var_438 = strtol(var_420, nullptr, 0xa);
                    *var_448 = 3;
                    rax_5 = 1;
                }
                else
                {
                    stbi__rewind(arg1);
                    rax_5 = 0;
                }
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_5;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__bmp_info(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t var_1c = 0xff;
    int32_t var_38;
    int64_t rax_4;
    if (stbi__bmp_parse_header(arg1, &var_38) == 0)
    {
        stbi__rewind(arg1);
        rax_4 = 0;
    }
    else
    {
        if (arg2 != 0)
        {
            *arg2 = *arg1;
        }
        if (arg3 != 0)
        {
            *arg3 = *(arg1 + 4);
        }
        if (arg4 != 0)
        {
            int32_t var_20;
            if ((var_38 == 0x18 && var_20 == 0xff000000))
            {
                *arg4 = 3;
            }
            if ((var_38 != 0x18 || (var_38 == 0x18 && var_20 != 0xff000000)))
            {
                int32_t rdx_2;
                if (var_20 == 0)
                {
                    rdx_2 = 3;
                }
                else
                {
                    rdx_2 = 4;
                }
                *arg4 = rdx_2;
            }
        }
        rax_4 = 1;
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_4;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__psd_info(char* arg1, void* arg2, void* arg3, void* arg4)
{
    void* var_38 = arg2;
    void* var_40 = arg3;
    void* var_48 = arg4;
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_1c;
    if (var_38 == 0)
    {
        var_38 = &var_1c;
    }
    if (var_40 == 0)
    {
        var_40 = &var_1c;
    }
    if (var_48 == 0)
    {
        var_48 = &var_1c;
    }
    int32_t rax_3;
    rax_3 = stbi__get32be(arg1) != 0x38425053;
    int64_t rax_5;
    if (rax_3 != 0)
    {
        stbi__rewind(arg1);
        rax_5 = 0;
    }
    else
    {
        int32_t rax_7;
        rax_7 = stbi__get16be(arg1) != 1;
        if (rax_7 != 0)
        {
            stbi__rewind(arg1);
            rax_5 = 0;
        }
        else
        {
            stbi__skip(arg1, 6);
            int32_t rax_11 = stbi__get16be(arg1);
            if ((rax_11 < 0 || (rax_11 >= 0 && rax_11 > 0x10)))
            {
                stbi__rewind(arg1);
                rax_5 = 0;
            }
            if ((rax_11 >= 0 && rax_11 <= 0x10))
            {
                *var_40 = stbi__get32be(arg1);
                *var_38 = stbi__get32be(arg1);
                int32_t rax_20 = stbi__get16be(arg1);
                if ((rax_20 == 8 || rax_20 == 0x10))
                {
                    int32_t rax_23;
                    rax_23 = stbi__get16be(arg1) != 3;
                    if (rax_23 == 0)
                    {
                        *var_48 = 4;
                        rax_5 = 1;
                    }
                    else
                    {
                        stbi__rewind(arg1);
                        rax_5 = 0;
                    }
                }
                if ((rax_20 != 8 && rax_20 != 0x10))
                {
                    stbi__rewind(arg1);
                    rax_5 = 0;
                }
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_5;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__psd_is16(char* arg1)
{
    int32_t rax_1;
    rax_1 = stbi__get32be(arg1) != 0x38425053;
    int64_t rax_3;
    if (rax_1 != 0)
    {
        stbi__rewind(arg1);
        rax_3 = 0;
    }
    else
    {
        int32_t rax_5;
        rax_5 = stbi__get16be(arg1) != 1;
        if (rax_5 != 0)
        {
            stbi__rewind(arg1);
            rax_3 = 0;
        }
        else
        {
            stbi__skip(arg1, 6);
            int32_t rax_9 = stbi__get16be(arg1);
            if ((rax_9 < 0 || (rax_9 >= 0 && rax_9 > 0x10)))
            {
                stbi__rewind(arg1);
                rax_3 = 0;
            }
            if ((rax_9 >= 0 && rax_9 <= 0x10))
            {
                if (stbi__get16be(arg1) == 0x10)
                {
                    rax_3 = 1;
                }
                else
                {
                    stbi__rewind(arg1);
                    rax_3 = 0;
                }
            }
        }
    }
    return rax_3;
}

int64_t stbi__pic_info(char* arg1, void* arg2, void* arg3, void* arg4)
{
    void* var_68 = arg2;
    void* var_70 = arg3;
    void* var_78 = arg4;
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int32_t var_4c = 0;
    int32_t var_48 = 0;
    void var_50;
    if (var_68 == 0)
    {
        var_68 = &var_50;
    }
    if (var_70 == 0)
    {
        var_70 = &var_50;
    }
    if (var_78 == 0)
    {
        var_78 = &var_50;
    }
    int32_t rax_3;
    rax_3 = stbi__pic_is4(arg1, &data_22f80) == 0;
    int64_t rax_5;
    if (rax_3 != 0)
    {
        stbi__rewind(arg1);
        rax_5 = 0;
    }
    else
    {
        stbi__skip(arg1, 0x58);
        *var_68 = stbi__get16be(arg1);
        *var_70 = stbi__get16be(arg1);
        int32_t rax_12;
        rax_12 = stbi__at_eof(arg1) != 0;
        if (rax_12 != 0)
        {
            stbi__rewind(arg1);
            rax_5 = 0;
        }
        else
        {
            if (*var_68 != 0)
            {
                int32_t temp4_1;
                int32_t temp5_1;
                temp4_1 = HIGHD(0x10000000);
                temp5_1 = LOWD(0x10000000);
                if ((COMBINE(0, 0x10000000) / *var_68) < *var_70)
                {
                    stbi__rewind(arg1);
                    rax_5 = 0;
                }
            }
            if ((*var_68 == 0 || (*var_68 != 0 && (COMBINE(0, 0x10000000) / *var_68) >= 
*var_70)))
            {
                stbi__skip(arg1, 8);
                while (true)
                {
                    if (var_48 == 0xa)
                    {
                        rax_5 = 0;
                        break;
                    }
                    int32_t rax_22 = var_48;
                    var_48 = (rax_22 + 1);
                    int64_t rdx_4 = rax_22;
                    void var_38;
                    void* rax_26 = (((rdx_4 + rdx_4) + rdx_4) + &var_38);
                    uint32_t rax_29 = stbi__get8(arg1);
                    *rax_26 = stbi__get8(arg1);
                    *(rax_26 + 1) = stbi__get8(arg1);
                    *(rax_26 + 2) = stbi__get8(arg1);
                    var_4c = (var_4c | *(rax_26 + 2));
                    int32_t rax_40;
                    rax_40 = stbi__at_eof(arg1) != 0;
                    if (rax_40 != 0)
                    {
                        stbi__rewind(arg1);
                        rax_5 = 0;
                        break;
                    }
                    if (*rax_26 != 8)
                    {
                        stbi__rewind(arg1);
                        rax_5 = 0;
                        break;
                    }
                    if (rax_29 == 0)
                    {
                        int32_t rdx_8;
                        if ((var_4c & 0x10) == 0)
                        {
                            rdx_8 = 3;
                        }
                        else
                        {
                            rdx_8 = 4;
                        }
                        *var_78 = rdx_8;
                        rax_5 = 1;
                        break;
                    }
                }
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_5;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__pnm_test(char* arg1)
{
    char rax_1 = stbi__get8(arg1);
    char rax_3 = stbi__get8(arg1);
    int64_t rax_5;
    if ((rax_1 != 0x50 || ((rax_1 == 0x50 && rax_3 != 0x35) && rax_3 != 0x36)))
    {
        stbi__rewind(arg1);
        rax_5 = 0;
    }
    if ((rax_1 == 0x50 && (rax_3 == 0x35 || rax_3 == 0x36)))
    {
        rax_5 = 1;
    }
    return rax_5;
}

int64_t stbi__pnm_load(int32_t* arg1, int32_t* arg2, int32_t* arg3, 
    int32_t* arg4, int32_t arg5, int32_t* arg6)
{
    *arg6 = stbi__pnm_info(arg1, arg1, &arg1[1], &arg1[2]);
    int64_t rax_6;
    if (*arg6 == 0)
    {
        rax_6 = 0;
    }
    else if (arg1[1] > 0x1000000)
    {
        stbi__err("too large");
        rax_6 = 0;
    }
    else if (*arg1 > 0x1000000)
    {
        stbi__err("too large");
        rax_6 = 0;
    }
    else
    {
        *arg2 = *arg1;
        *arg3 = arg1[1];
        if (arg4 != 0)
        {
            *arg4 = arg1[2];
        }
        int32_t rax_20 = *arg6;
        if (rax_20 < 0)
        {
            rax_20 = (rax_20 + 7);
        }
        int32_t rax_28;
        rax_28 = stbi__mad4sizes_valid(arg1[2], *arg1, arg1[1], (rax_20 >> 3), 0) == 0;
        if (rax_28 != 0)
        {
            stbi__err("too large");
            rax_6 = 0;
        }
        else
        {
            int32_t rax_30 = *arg6;
            if (rax_30 < 0)
            {
                rax_30 = (rax_30 + 7);
            }
            int64_t var_10_1 = stbi__malloc_mad4(arg1[2], *arg1, arg1[1], (rax_30 >> 3), 0);
            if (var_10_1 == 0)
            {
                stbi__err("outofmem");
                rax_6 = 0;
            }
            else
            {
                int32_t rax_46 = *arg6;
                if (rax_46 < 0)
                {
                    rax_46 = (rax_46 + 7);
                }
                int32_t rax_50;
                rax_50 = stbi__getn(arg1, var_10_1, ((rax_46 >> 3) * ((arg1[2] * *arg1) * 
arg1[1]))) == 0;
                if (rax_50 != 0)
                {
                    free(var_10_1);
                    stbi__err("bad PNM");
                    rax_6 = 0;
                }
                else
                {
                    if ((arg5 != 0 && arg5 != arg1[2]))
                    {
                        if (*arg6 != 0x10)
                        {
                            var_10_1 = stbi__convert_format(var_10_1, arg1[2], arg5, *arg1, 
arg1[1]);
                        }
                        else
                        {
                            var_10_1 = stbi__convert_format16(var_10_1, arg1[2], arg5, *arg1, 
arg1[1]);
                        }
                    }
                    if (((arg5 == 0 || (arg5 != 0 && arg5 == arg1[2])) || ((arg5 != 0 && arg5 
!= arg1[2]) && var_10_1 != 0)))
                    {
                        rax_6 = var_10_1;
                    }
                    if (((arg5 != 0 && arg5 != arg1[2]) && var_10_1 == 0))
                    {
                        rax_6 = var_10_1;
                    }
                }
            }
        }
    }
    return rax_6;
}

uint64_t stbi__pnm_isspace(char arg1)
{
    char rax_1;
    if ((((((arg1 == 0x20 || arg1 == 9) || arg1 == 0xa) || arg1 == 0xb) || arg1 == 0xc) || 
arg1 == 0xd))
    {
        rax_1 = 1;
    }
    if ((((((arg1 != 0x20 && arg1 != 9) && arg1 != 0xa) && arg1 != 0xb) && arg1 != 0xc) && 
arg1 != 0xd))
    {
        rax_1 = 0;
    }
    return rax_1;
}

int64_t stbi__pnm_skip_whitespace(char* arg1, char* arg2)
{
    int64_t rax_15;
    while (true)
    {
        int32_t rax_5 = stbi__at_eof(arg1);
        int32_t rax_9;
        char rax_10;
        if (rax_5 == 0)
        {
            rax_9 = stbi__pnm_isspace(*arg2);
            if (rax_9 != 0)
            {
                rax_10 = 1;
            }
        }
        if ((rax_5 != 0 || (rax_5 == 0 && rax_9 == 0)))
        {
            rax_10 = 0;
        }
        if (rax_10 != 0)
        {
            *arg2 = stbi__get8(arg1);
        }
        else
        {
            int32_t rax_12 = stbi__at_eof(arg1);
            if ((rax_12 != 0 || (rax_12 == 0 && *arg2 != 0x23)))
            {
                rax_15 = 1;
            }
            if ((rax_12 == 0 && *arg2 == 0x23))
            {
                rax_15 = 0;
            }
            if (rax_15 != 0)
            {
                break;
            }
            while (true)
            {
                int32_t rax_20 = stbi__at_eof(arg1);
                char rax_25;
                if (((rax_20 != 0 || (rax_20 == 0 && *arg2 == 0xa)) || (rax_20 == 0 && *arg2 
== 0xd)))
                {
                    rax_25 = 0;
                }
                if (((rax_20 == 0 && *arg2 != 0xa) && *arg2 != 0xd))
                {
                    rax_25 = 1;
                }
                if (rax_25 == 0)
                {
                    break;
                }
                *arg2 = stbi__get8(arg1);
            }
        }
    }
    return rax_15;
}

uint64_t stbi__pnm_isdigit(char arg1)
{
    char rax_1;
    if ((arg1 <= 0x2f || (arg1 > 0x2f && arg1 > 0x39)))
    {
        rax_1 = 0;
    }
    if ((arg1 > 0x2f && arg1 <= 0x39))
    {
        rax_1 = 1;
    }
    return rax_1;
}

uint64_t stbi__pnm_getinteger(char* arg1, char* arg2)
{
    int32_t var_c = 0;
    uint64_t rax_15;
    while (true)
    {
        int32_t rax_17 = stbi__at_eof(arg1);
        int32_t rax_21;
        char rax_22;
        if (rax_17 == 0)
        {
            rax_21 = stbi__pnm_isdigit(*arg2);
            if (rax_21 != 0)
            {
                rax_22 = 1;
            }
        }
        if ((rax_17 != 0 || (rax_17 == 0 && rax_21 == 0)))
        {
            rax_22 = 0;
        }
        if (rax_22 == 0)
        {
            rax_15 = var_c;
            break;
        }
        int32_t rax_3 = (var_c * 5);
        var_c = ((*arg2 - 0x30) + (rax_3 + rax_3));
        *arg2 = stbi__get8(arg1);
        if (var_c <= 0xccccccc)
        {
            if (var_c != 0xccccccc)
            {
                continue;
            }
            if ((var_c == 0xccccccc && *arg2 <= 0x37))
            {
                continue;
            }
        }
        rax_15 = stbi__err("integer parse overflow");
        break;
    }
    return rax_15;
}

int64_t stbi__pnm_info(char* arg1, void* arg2, void* arg3, void* arg4)
{
    void* var_38 = arg2;
    void* var_40 = arg3;
    void* var_48 = arg4;
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_18;
    if (var_38 == 0)
    {
        var_38 = &var_18;
    }
    if (var_40 == 0)
    {
        var_40 = &var_18;
    }
    if (var_48 == 0)
    {
        var_48 = &var_18;
    }
    stbi__rewind(arg1);
    char rax_4 = stbi__get8(arg1);
    char rax_6 = stbi__get8(arg1);
    int64_t rax_8;
    if ((rax_4 != 0x50 || ((rax_4 == 0x50 && rax_6 != 0x35) && rax_6 != 0x36)))
    {
        stbi__rewind(arg1);
        rax_8 = 0;
    }
    if (rax_4 == 0x50)
    {
        int32_t rdx;
        if ((rax_6 == 0x35 || rax_6 == 0x36))
        {
            rdx = 1;
        }
        if (rax_6 == 0x36)
        {
            rdx = 3;
        }
        if (((rax_6 == 0x35 || rax_6 == 0x36) || rax_6 == 0x36))
        {
            *var_48 = rdx;
            char var_1b = stbi__get8(arg1);
            stbi__pnm_skip_whitespace(arg1, &var_1b);
            *var_38 = stbi__pnm_getinteger(arg1, &var_1b);
            if (*var_38 == 0)
            {
                rax_8 = stbi__err("invalid width");
            }
            else
            {
                stbi__pnm_skip_whitespace(arg1, &var_1b);
                *var_40 = stbi__pnm_getinteger(arg1, &var_1b);
                if (*var_40 == 0)
                {
                    rax_8 = stbi__err("invalid width");
                }
                else
                {
                    stbi__pnm_skip_whitespace(arg1, &var_1b);
                    int32_t rax_24 = stbi__pnm_getinteger(arg1, &var_1b);
                    if (rax_24 > 0xffff)
                    {
                        rax_8 = stbi__err("max value > 65535");
                    }
                    else if (rax_24 <= 0xff)
                    {
                        rax_8 = 8;
                    }
                    else
                    {
                        rax_8 = 0x10;
                    }
                }
            }
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_8;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi__pnm_is16(char* arg1)
{
    int32_t rax_1;
    rax_1 = stbi__pnm_info(arg1, nullptr, nullptr, nullptr) == 0x10;
    int64_t rax_2;
    if (rax_1 == 0)
    {
        rax_2 = 0;
    }
    else
    {
        rax_2 = 1;
    }
    return rax_2;
}

int64_t stbi__info_main(char* arg1, void* arg2, int32_t* arg3, int32_t* arg4)
{
    int32_t rax_1;
    rax_1 = stbi__jpeg_info(arg1, arg2, arg3, arg4) != 0;
    int64_t rax_2;
    if (rax_1 != 0)
    {
        rax_2 = 1;
    }
    else
    {
        int32_t rax_4;
        rax_4 = stbi__png_info(arg1, arg2, arg3, arg4) != 0;
        if (rax_4 != 0)
        {
            rax_2 = 1;
        }
        else
        {
            int32_t rax_6;
            rax_6 = stbi__gif_info(arg1, arg2, arg3, arg4) != 0;
            if (rax_6 != 0)
            {
                rax_2 = 1;
            }
            else
            {
                int32_t rax_8;
                rax_8 = stbi__bmp_info(arg1, arg2, arg3, arg4) != 0;
                if (rax_8 != 0)
                {
                    rax_2 = 1;
                }
                else
                {
                    int32_t rax_10;
                    rax_10 = stbi__psd_info(arg1, arg2, arg3, arg4) != 0;
                    if (rax_10 != 0)
                    {
                        rax_2 = 1;
                    }
                    else
                    {
                        int32_t rax_12;
                        rax_12 = stbi__pic_info(arg1, arg2, arg3, arg4) != 0;
                        if (rax_12 != 0)
                        {
                            rax_2 = 1;
                        }
                        else
                        {
                            int32_t rax_14;
                            rax_14 = stbi__pnm_info(arg1, arg2, arg3, arg4) != 0;
                            if (rax_14 != 0)
                            {
                                rax_2 = 1;
                            }
                            else
                            {
                                int32_t rax_16;
                                rax_16 = stbi__hdr_info(arg1, arg2, arg3, arg4) != 0;
                                if (rax_16 != 0)
                                {
                                    rax_2 = 1;
                                }
                                else
                                {
                                    int32_t rax_18;
                                    rax_18 = stbi__tga_info(arg1, arg2, arg3, arg4) != 0;
                                    if (rax_18 == 0)
                                    {
                                        rax_2 = stbi__err("unknown image type");
                                    }
                                    else
                                    {
                                        rax_2 = 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return rax_2;
}

int64_t stbi__is_16_main(char* arg1)
{
    int32_t rax_1;
    rax_1 = stbi__png_is16(arg1) != 0;
    int64_t rax_2;
    if (rax_1 != 0)
    {
        rax_2 = 1;
    }
    else
    {
        int32_t rax_4;
        rax_4 = stbi__psd_is16(arg1) != 0;
        if (rax_4 != 0)
        {
            rax_2 = 1;
        }
        else
        {
            int32_t rax_6;
            rax_6 = stbi__pnm_is16(arg1) != 0;
            if (rax_6 == 0)
            {
                rax_2 = 0;
            }
            else
            {
                rax_2 = 1;
            }
        }
    }
    return rax_2;
}

uint64_t stbi_info(char* arg1, void* arg2, int32_t* arg3, int32_t* arg4)
{
    FILE* rax_1 = stbi__fopen(arg1, &data_22136);
    uint64_t rax_2;
    if (rax_1 != 0)
    {
        int32_t rax_4 = stbi_info_from_file(rax_1, arg2, arg3, arg4);
        fclose(rax_1);
        rax_2 = rax_4;
    }
    else
    {
        rax_2 = stbi__err("can't fopen");
    }
    return rax_2;
}

uint64_t stbi_info_from_file(FILE* arg1, void* arg2, int32_t* arg3, 
    int32_t* arg4)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t rax_2 = ftell(arg1);
    void var_f8;
    stbi__start_file(&var_f8, arg1);
    int32_t rax_3 = stbi__info_main(&var_f8, arg2, arg3, arg4);
    fseek(arg1, rax_2, 0);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_3;
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t stbi_is_16_bit(char* arg1)
{
    FILE* rax_1 = stbi__fopen(arg1, &data_22136);
    uint64_t rax_2;
    if (rax_1 != 0)
    {
        int32_t rax_4 = stbi_is_16_bit_from_file(rax_1);
        fclose(rax_1);
        rax_2 = rax_4;
    }
    else
    {
        rax_2 = stbi__err("can't fopen");
    }
    return rax_2;
}

uint64_t stbi_is_16_bit_from_file(FILE* arg1)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    int64_t rax_2 = ftell(arg1);
    void var_f8;
    stbi__start_file(&var_f8, arg1);
    int32_t rax_3 = stbi__is_16_main(&var_f8);
    fseek(arg1, rax_2, 0);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_3;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi_info_from_memory(int64_t arg1, int32_t arg2, void* arg3, 
    int32_t* arg4, int32_t* arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_mem(&var_f8, arg1, arg2);
    int64_t rax_1 = stbi__info_main(&var_f8, arg3, arg4, arg5);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi_info_from_callbacks(int64_t* arg1, int64_t arg2, void* arg3, 
    int32_t* arg4, int32_t* arg5)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_callbacks(&var_f8, arg1, arg2);
    int64_t rax_1 = stbi__info_main(&var_f8, arg3, arg4, arg5);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi_is_16_bit_from_memory(int64_t arg1, int32_t arg2)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_mem(&var_f8, arg1, arg2);
    int64_t rax_1 = stbi__is_16_main(&var_f8);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t stbi_is_16_bit_from_callbacks(int64_t* arg1, int64_t arg2)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    void var_f8;
    stbi__start_callbacks(&var_f8, arg1, arg2);
    int64_t rax_1 = stbi__is_16_main(&var_f8);
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_1;
    }
    __stack_chk_fail();
    /* no return */
}

int32_t main(int32_t argc, char** argv, char** envp)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    glfwInit();
    glfwWindowHint(0x22002, 3);
    glfwWindowHint(0x22003, 3);
    glfwWindowHint(0x22008, "ain()\n{\n   float ratio = resol…");
    int64_t rax_2 = glfwCreateWindow(0x258, 0x258, "Aidez moi, svp !", 0, 0);
    int32_t rax_4;
    if (rax_2 == 0)
    {
        std::ostream::operator<<(std::operator<<<std::char_traits<char> >(&std::cout, "Failed 
to create GLFW window"), std::endl<char>);
        glfwTerminate();
        rax_4 = -1;
    }
    else
    {
        glfwMakeContextCurrent(rax_2);
        glfwSetFramebufferSizeCallback(rax_2, framebuffer_size_callback, 
framebuffer_size_callback);
        int32_t rax_7;
        rax_7 = gladLoadGLLoader(glfwGetProcAddress) == 0;
        if (rax_7 != 0)
        {
            std::ostream::operator<<(std::operator<<<std::char_traits<char> >(&std::cout, 
"Failed to initialize GLAD"), std::endl<char>);
            rax_4 = -1;
        }
        else
        {
            int32_t rax_10 = glad_glCreateShader(0x8b31);
            glad_glShaderSource(rax_10, 1, &vertexShaderSource, 0);
            glad_glCompileShader(rax_10);
            int32_t var_2e4;
            glad_glGetShaderiv(rax_10, 0x8b81, &var_2e4);
            void var_218;
            if (var_2e4 == 0)
            {
                glad_glGetShaderInfoLog(rax_10, 0x200, 0, &var_218);
                std::ostream::operator<<(std::operator<<<std::char_traits<char> 
>(std::operator<<<std::char_traits<char> >(&std::cout, "ERROR::SHADER::VERTEX::COMPILATI…"), 
&var_218), std::endl<char>);
            }
            int32_t rax_19 = glad_glCreateShader(0x8b30);
            glad_glShaderSource(rax_19, 1, &fragmentShaderSource, 0);
            glad_glCompileShader(rax_19);
            glad_glGetShaderiv(rax_19, 0x8b81, &var_2e4);
            if (var_2e4 == 0)
            {
                glad_glGetShaderInfoLog(rax_19, 0x200, 0, &var_218);
                std::ostream::operator<<(std::operator<<<std::char_traits<char> 
>(std::operator<<<std::char_traits<char> >(&std::cout, "ERROR::SHADER::FRAGMENT::COMPILA…"), 
&var_218), std::endl<char>);
            }
            int32_t rax_28 = glad_glCreateProgram();
            glad_glAttachShader(rax_28, rax_10);
            glad_glAttachShader(rax_28, rax_19);
            glad_glLinkProgram(rax_28);
            glad_glGetProgramiv(rax_28, 0x8b82, &var_2e4);
            if (var_2e4 == 0)
            {
                glad_glGetProgramInfoLog(rax_28, 0x200, 0, &var_218);
                std::ostream::operator<<(std::operator<<<std::char_traits<char> 
>(std::operator<<<std::char_traits<char> >(&std::cout, "ERROR::SHADER::PROGRAM::LINKING_…"), 
&var_218), std::endl<char>);
            }
            glad_glDeleteShader(rax_10);
            glad_glDeleteShader(rax_19);
            int512_t zmm0;
            zmm0 = 0xbf800000;
            int32_t var_268 = 0xbf800000;
            zmm0 = 0xbf800000;
            int32_t var_264_1 = 0xbf800000;
            zmm0 = {0};
            int32_t var_260_1 = 0;
            zmm0 = {0};
            int32_t var_25c_1 = 0;
            zmm0 = {0};
            int32_t var_258_1 = 0;
            zmm0 = 0x3f800000;
            int32_t var_254_1 = 0x3f800000;
            zmm0 = 0xbf800000;
            int32_t var_250_1 = 0xbf800000;
            zmm0 = {0};
            int32_t var_24c_1 = 0;
            zmm0 = 0x3f800000;
            int32_t var_248_1 = 0x3f800000;
            zmm0 = {0};
            int32_t var_244_1 = 0;
            zmm0 = 0x3f800000;
            int32_t var_240_1 = 0x3f800000;
            zmm0 = 0x3f800000;
            int32_t var_23c_1 = 0x3f800000;
            zmm0 = {0};
            int32_t var_238_1 = 0;
            zmm0 = {0};
            int32_t var_234_1 = 0;
            zmm0 = 0x3f800000;
            int32_t var_230_1 = 0x3f800000;
            zmm0 = 0xbf800000;
            int32_t var_22c_1 = 0xbf800000;
            zmm0 = 0x3f800000;
            int32_t var_228_1 = 0x3f800000;
            zmm0 = {0};
            int32_t var_224_1 = 0;
            zmm0 = 0x3f800000;
            int32_t var_220_1 = 0x3f800000;
            int32_t var_21c_1 = 0x3f800000;
            int32_t var_288 = 0;
            int32_t var_284;
            __builtin_memcpy(var_284, 
"\x01\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00", 0x14);
            int32_t var_2dc;
            glad_glGenVertexArrays(1, &var_2dc);
            int32_t var_2e0;
            glad_glGenBuffers(1, &var_2e0);
            glad_glBindVertexArray(var_2dc);
            glad_glBindBuffer(&data_8892, var_2e0);
            glad_glBufferData(&data_8892, 0x50, &var_268, 0x88e4);
            int32_t var_2d8;
            glad_glGenBuffers(1, &var_2d8);
            glad_glBindBuffer(0x8893, var_2d8);
            glad_glBufferData(0x8893, 0x18, &var_288, 0x88e4);
            glad_glVertexAttribPointer(0, 3, 0x1406, 0, 0x14, 0);
            glad_glEnableVertexAttribArray(0);
            glad_glBindBuffer(&data_8892, 0);
            glad_glBindVertexArray(0);
            int32_t var_2d4;
            glad_glGenTextures(1, &var_2d4);
            glad_glBindTexture(0xde1, var_2d4);
            glad_glTexParameteri(0xde1, 0x2802, 0x2901);
            glad_glTexParameteri(0xde1, 0x2803, 0x2901);
            glad_glTexParameteri(0xde1, 0x2801, 0x2601);
            glad_glTexParameteri(0xde1, 0x2800, 0x2601);
            int32_t var_2d0;
            int32_t var_2cc;
            void var_2c8;
            char* rax_51;
            int512_t zmm2_1;
            rax_51 = stbi_load_from_memory(&bg_data, 0xedb9, &var_2d0, &var_2cc, &var_2c8, 0);
            if (rax_51 == 0)
            {
                std::ostream::operator<<(std::operator<<<std::char_traits<char> >(&std::cout, 
"Failed to load texture"), std::endl<char>);
            }
            else
            {
                glad_glTexImage2D(0xde1, 0, 0x1907, var_2d0, var_2cc, 0, 0x1907, 0x1401, 
rax_51);
            }
            stbi_image_free(rax_51);
            glad_glVertexAttribPointer(1, 2, 0x1406, 0, 0x14, 0xc);
            glad_glEnableVertexAttribArray(1);
            while (true)
            {
                int32_t rax_76;
                rax_76 = glfwWindowShouldClose(rax_2) == 0;
                if (rax_76 == 0)
                {
                    break;
                }
                processInput(rax_2);
                int512_t zmm3;
                zmm3 = 0x3f800000;
                zmm2_1 = 0x3e99999a;
                glad_glClearColor();
                glad_glClear(0x4000);
                glad_glUseProgram(rax_28);
                int32_t rax_61 = glad_glGetUniformLocation(rax_28, "resolution");
                int32_t var_2c4;
                int32_t var_2c0;
                glfwGetFramebufferSize(rax_2, &var_2c4, &var_2c0, &var_2c4);
                int64_t zmm0_1;
                zmm0_1 = var_2c0;
                glad_glUniform2f(rax_61);
                int32_t rax_67 = glad_glGetUniformLocation(rax_28, "mouse");
                int64_t var_2a8;
                int64_t var_2a0;
                glfwGetCursorPos(rax_2, &var_2a8, &var_2a0, &var_2a8);
                zmm0_1 = var_2a0;
                glad_glUniform2f(rax_67);
                glad_glBindTexture(0xde1, var_2d4);
                glad_glBindVertexArray(var_2dc);
                glad_glDrawElements(4, 6, 0x1405, 0);
                glad_glBindVertexArray(0);
                glfwSwapBuffers(rax_2);
                glfwPollEvents();
            }
            glad_glDeleteVertexArrays(1, &var_2dc);
            glad_glDeleteBuffers(1, &var_2e0);
            glad_glDeleteProgram(rax_28);
            glfwTerminate();
            rax_4 = 0;
        }
    }
    *(fsbase + 0x28);
    if (rax == *(fsbase + 0x28))
    {
        return rax_4;
    }
    __stack_chk_fail();
    /* no return */
}

int64_t processInput(int64_t arg1)
{
    int64_t rax_1;
    rax_1 = glfwGetKey(arg1, 0x100) == 1;
    if (rax_1 != 0)
    {
        rax_1 = glfwSetWindowShouldClose(arg1, 1);
    }
    return rax_1;
}

int64_t framebuffer_size_callback(int64_t arg1, int32_t arg2, int32_t arg3)
{
    int64_t var_10 = arg1;
    return glad_glViewport(0, 0, arg2, arg3);
}

int64_t std::ldexp(int32_t arg1, float arg2)
{
    return ldexpf(arg1, arg2);
}

int64_t std::pow(float arg1, float arg2)
{
    int32_t zmm0;
    int32_t var_c = zmm0;
    return powf(arg1, arg2);
}

uint64_t open_gl()
{
    int32_t var_c = 0;
    int32_t var_c_1 = 0;
    uint64_t rax_8;
    while (true)
    {
        if (var_c_1 > 1)
        {
            rax_8 = 0;
            break;
        }
        libGL = dlopen(&open_gl()::NAMES[var_c_1], 0x102);
        if (libGL != 0)
        {
            gladGetProcAddressPtr = dlsym(libGL, "glXGetProcAddressARB", 
"glXGetProcAddressARB");
            uint64_t rax_7;
            rax_7 = gladGetProcAddressPtr != 0;
            rax_8 = rax_7;
            break;
        }
        var_c_1 = (var_c_1 + 1);
    }
    return rax_8;
}

uint64_t close_gl()
{
    uint64_t rax = libGL;
    if (rax != 0)
    {
        rax = dlclose(libGL);
        libGL = 0;
    }
    return rax;
}

int64_t get_proc(int64_t arg1)
{
    int64_t var_10 = 0;
    int64_t rax_1;
    if (libGL == 0)
    {
        rax_1 = 0;
    }
    else
    {
        if (gladGetProcAddressPtr != 0)
        {
            var_10 = gladGetProcAddressPtr(arg1);
        }
        if (var_10 == 0)
        {
            var_10 = dlsym(libGL, arg1);
        }
        rax_1 = var_10;
    }
    return rax_1;
}

uint64_t gladLoadGL()
{
    int32_t var_c = 0;
    int32_t rax;
    rax = open_gl() != 0;
    if (rax != 0)
    {
        var_c = gladLoadGLLoader(get_proc);
        close_gl();
    }
    return var_c;
}

int64_t get_exts()
{
    int64_t rax_10;
    if (max_loaded_major > 2)
    {
        num_exts_i = 0;
        glad_glGetIntegerv(0x821d, &num_exts_i, &num_exts_i);
        if (num_exts_i > 0)
        {
            exts_i = malloc((num_exts_i << 3));
        }
        if (exts_i == 0)
        {
            rax_10 = 0;
        }
        else
        {
            for (int32_t var_24_1 = 0; var_24_1 < num_exts_i; var_24_1 = (var_24_1 + 1))
            {
                char* rax_12 = glad_glGetStringi(0x1f03, var_24_1);
                uint64_t rax_14 = strlen(rax_12);
                int64_t rax_17 = malloc((rax_14 + 1));
                if (rax_17 != 0)
                {
                    memcpy(rax_17, rax_12, (rax_14 + 1));
                }
                *((var_24_1 << 3) + exts_i) = rax_17;
            }
        }
    }
    else
    {
        exts = glad_glGetString(0x1f03);
    }
    if ((max_loaded_major <= 2 || (max_loaded_major > 2 && exts_i != 0)))
    {
        rax_10 = 1;
    }
    return rax_10;
}

uint64_t free_exts()
{
    uint64_t rax = exts_i;
    if (rax != 0)
    {
        for (int32_t var_c_1 = 0; var_c_1 < num_exts_i; var_c_1 = (var_c_1 + 1))
        {
            free(*(exts_i + (var_c_1 << 3)));
        }
        rax = free(exts_i);
        exts_i = 0;
    }
    return rax;
}

int64_t has_ext(char* arg1)
{
    int64_t rax_2;
    if (max_loaded_major <= 2)
    {
        uint64_t var_28_1 = exts;
        if ((var_28_1 == 0 || (var_28_1 != 0 && arg1 == 0)))
        {
            rax_2 = 0;
        }
        if ((var_28_1 != 0 && arg1 != 0))
        {
            while (true)
            {
                char* rax_4 = strstr(var_28_1, arg1);
                if (rax_4 == 0)
                {
                    rax_2 = 0;
                    break;
                }
                void* rax_7 = &rax_4[strlen(arg1)];
                if ((rax_4 != var_28_1 && *(rax_4 - 1) != 0x20))
                {
                label_1e828:
                    var_28_1 = rax_7;
                    continue;
                }
                if ((*rax_7 != 0x20 && *rax_7 != 0))
                {
                    goto label_1e828;
                }
                rax_2 = 1;
                break;
            }
        }
    }
    else if (exts_i == 0)
    {
        rax_2 = 0;
    }
    else
    {
        int32_t var_2c_1 = 0;
        while (true)
        {
            if (var_2c_1 >= num_exts_i)
            {
                rax_2 = 0;
                break;
            }
            if ((*(exts_i + (var_2c_1 << 3)) != 0 && strcmp(*(exts_i + (var_2c_1 << 3)), arg1) 
== 0))
            {
                rax_2 = 1;
                break;
            }
            var_2c_1 = (var_2c_1 + 1);
        }
    }
    return rax_2;
}

uint64_t load_GL_VERSION_1_0(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_1_0;
    if (rax != 0)
    {
        glad_glCullFace = arg1("glCullFace", arg2, "glCullFace");
        glad_glFrontFace = arg1("glFrontFace");
        glad_glHint = arg1("glHint");
        glad_glLineWidth = arg1("glLineWidth");
        glad_glPointSize = arg1("glPointSize");
        glad_glPolygonMode = arg1("glPolygonMode");
        glad_glScissor = arg1("glScissor");
        glad_glTexParameterf = arg1("glTexParameterf");
        glad_glTexParameterfv = arg1("glTexParameterfv");
        glad_glTexParameteri = arg1("glTexParameteri");
        glad_glTexParameteriv = arg1("glTexParameteriv");
        glad_glTexImage1D = arg1("glTexImage1D");
        glad_glTexImage2D = arg1("glTexImage2D");
        glad_glDrawBuffer = arg1("glDrawBuffer");
        glad_glClear = arg1("glClear");
        glad_glClearColor = arg1("glClearColor");
        glad_glClearStencil = arg1("glClearStencil");
        glad_glClearDepth = arg1("glClearDepth");
        glad_glStencilMask = arg1("glStencilMask");
        glad_glColorMask = arg1("glColorMask");
        glad_glDepthMask = arg1("glDepthMask");
        glad_glDisable = arg1("glDisable");
        glad_glEnable = arg1("glEnable");
        glad_glFinish = arg1("glFinish");
        glad_glFlush = arg1("glFlush");
        glad_glBlendFunc = arg1("glBlendFunc");
        glad_glLogicOp = arg1("glLogicOp");
        glad_glStencilFunc = arg1("glStencilFunc");
        glad_glStencilOp = arg1("glStencilOp");
        glad_glDepthFunc = arg1("glDepthFunc");
        glad_glPixelStoref = arg1("glPixelStoref");
        glad_glPixelStorei = arg1("glPixelStorei");
        glad_glReadBuffer = arg1("glReadBuffer");
        glad_glReadPixels = arg1("glReadPixels");
        glad_glGetBooleanv = arg1("glGetBooleanv");
        glad_glGetDoublev = arg1("glGetDoublev");
        glad_glGetError = arg1("glGetError");
        glad_glGetFloatv = arg1("glGetFloatv");
        glad_glGetIntegerv = arg1("glGetIntegerv");
        glad_glGetString = arg1("glGetString");
        glad_glGetTexImage = arg1("glGetTexImage");
        glad_glGetTexParameterfv = arg1("glGetTexParameterfv");
        glad_glGetTexParameteriv = arg1("glGetTexParameteriv");
        glad_glGetTexLevelParameterfv = arg1("glGetTexLevelParameterfv");
        glad_glGetTexLevelParameteriv = arg1("glGetTexLevelParameteriv");
        glad_glIsEnabled = arg1("glIsEnabled");
        glad_glDepthRange = arg1("glDepthRange");
        rax = arg1("glViewport");
        glad_glViewport = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_1_1(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_1_1;
    if (rax != 0)
    {
        glad_glDrawArrays = arg1("glDrawArrays", arg2, "glDrawArrays");
        glad_glDrawElements = arg1("glDrawElements");
        glad_glPolygonOffset = arg1("glPolygonOffset");
        glad_glCopyTexImage1D = arg1("glCopyTexImage1D");
        glad_glCopyTexImage2D = arg1("glCopyTexImage2D");
        glad_glCopyTexSubImage1D = arg1("glCopyTexSubImage1D");
        glad_glCopyTexSubImage2D = arg1("glCopyTexSubImage2D");
        glad_glTexSubImage1D = arg1("glTexSubImage1D");
        glad_glTexSubImage2D = arg1("glTexSubImage2D");
        glad_glBindTexture = arg1("glBindTexture");
        glad_glDeleteTextures = arg1("glDeleteTextures");
        glad_glGenTextures = arg1("glGenTextures");
        rax = arg1("glIsTexture");
        glad_glIsTexture = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_1_2(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_1_2;
    if (rax != 0)
    {
        glad_glDrawRangeElements = arg1("glDrawRangeElements", arg2, "glDrawRangeElements");
        glad_glTexImage3D = arg1("glTexImage3D");
        glad_glTexSubImage3D = arg1("glTexSubImage3D");
        rax = arg1("glCopyTexSubImage3D");
        glad_glCopyTexSubImage3D = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_1_3(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_1_3;
    if (rax != 0)
    {
        glad_glActiveTexture = arg1("glActiveTexture", arg2, "glActiveTexture");
        glad_glSampleCoverage = arg1("glSampleCoverage");
        glad_glCompressedTexImage3D = arg1("glCompressedTexImage3D");
        glad_glCompressedTexImage2D = arg1("glCompressedTexImage2D");
        glad_glCompressedTexImage1D = arg1("glCompressedTexImage1D");
        glad_glCompressedTexSubImage3D = arg1("glCompressedTexSubImage3D");
        glad_glCompressedTexSubImage2D = arg1("glCompressedTexSubImage2D");
        glad_glCompressedTexSubImage1D = arg1("glCompressedTexSubImage1D");
        rax = arg1("glGetCompressedTexImage");
        glad_glGetCompressedTexImage = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_1_4(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_1_4;
    if (rax != 0)
    {
        glad_glBlendFuncSeparate = arg1("glBlendFuncSeparate", arg2, "glBlendFuncSeparate");
        glad_glMultiDrawArrays = arg1("glMultiDrawArrays");
        glad_glMultiDrawElements = arg1("glMultiDrawElements");
        glad_glPointParameterf = arg1("glPointParameterf");
        glad_glPointParameterfv = arg1("glPointParameterfv");
        glad_glPointParameteri = arg1("glPointParameteri");
        glad_glPointParameteriv = arg1("glPointParameteriv");
        glad_glBlendColor = arg1("glBlendColor");
        rax = arg1("glBlendEquation");
        glad_glBlendEquation = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_1_5(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_1_5;
    if (rax != 0)
    {
        glad_glGenQueries = arg1("glGenQueries", arg2, "glGenQueries");
        glad_glDeleteQueries = arg1("glDeleteQueries");
        glad_glIsQuery = arg1("glIsQuery");
        glad_glBeginQuery = arg1("glBeginQuery");
        glad_glEndQuery = arg1("glEndQuery");
        glad_glGetQueryiv = arg1("glGetQueryiv");
        glad_glGetQueryObjectiv = arg1("glGetQueryObjectiv");
        glad_glGetQueryObjectuiv = arg1("glGetQueryObjectuiv");
        glad_glBindBuffer = arg1("glBindBuffer");
        glad_glDeleteBuffers = arg1("glDeleteBuffers");
        glad_glGenBuffers = arg1("glGenBuffers");
        glad_glIsBuffer = arg1("glIsBuffer");
        glad_glBufferData = arg1("glBufferData");
        glad_glBufferSubData = arg1("glBufferSubData");
        glad_glGetBufferSubData = arg1("glGetBufferSubData");
        glad_glMapBuffer = arg1("glMapBuffer");
        glad_glUnmapBuffer = arg1("glUnmapBuffer");
        glad_glGetBufferParameteriv = arg1("glGetBufferParameteriv");
        rax = arg1("glGetBufferPointerv");
        glad_glGetBufferPointerv = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_2_0(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_2_0;
    if (rax != 0)
    {
        glad_glBlendEquationSeparate = arg1("glBlendEquationSeparate", arg2, 
"glBlendEquationSeparate");
        glad_glDrawBuffers = arg1("glDrawBuffers");
        glad_glStencilOpSeparate = arg1("glStencilOpSeparate");
        glad_glStencilFuncSeparate = arg1("glStencilFuncSeparate");
        glad_glStencilMaskSeparate = arg1("glStencilMaskSeparate");
        glad_glAttachShader = arg1("glAttachShader");
        glad_glBindAttribLocation = arg1("glBindAttribLocation");
        glad_glCompileShader = arg1("glCompileShader");
        glad_glCreateProgram = arg1("glCreateProgram");
        glad_glCreateShader = arg1("glCreateShader");
        glad_glDeleteProgram = arg1("glDeleteProgram");
        glad_glDeleteShader = arg1("glDeleteShader");
        glad_glDetachShader = arg1("glDetachShader");
        glad_glDisableVertexAttribArray = arg1("glDisableVertexAttribArray");
        glad_glEnableVertexAttribArray = arg1("glEnableVertexAttribArray");
        glad_glGetActiveAttrib = arg1("glGetActiveAttrib");
        glad_glGetActiveUniform = arg1("glGetActiveUniform");
        glad_glGetAttachedShaders = arg1("glGetAttachedShaders");
        glad_glGetAttribLocation = arg1("glGetAttribLocation");
        glad_glGetProgramiv = arg1("glGetProgramiv");
        glad_glGetProgramInfoLog = arg1("glGetProgramInfoLog");
        glad_glGetShaderiv = arg1("glGetShaderiv");
        glad_glGetShaderInfoLog = arg1("glGetShaderInfoLog");
        glad_glGetShaderSource = arg1("glGetShaderSource");
        glad_glGetUniformLocation = arg1("glGetUniformLocation");
        glad_glGetUniformfv = arg1("glGetUniformfv");
        glad_glGetUniformiv = arg1("glGetUniformiv");
        glad_glGetVertexAttribdv = arg1("glGetVertexAttribdv");
        glad_glGetVertexAttribfv = arg1("glGetVertexAttribfv");
        glad_glGetVertexAttribiv = arg1("glGetVertexAttribiv");
        glad_glGetVertexAttribPointerv = arg1("glGetVertexAttribPointerv");
        glad_glIsProgram = arg1("glIsProgram");
        glad_glIsShader = arg1("glIsShader");
        glad_glLinkProgram = arg1("glLinkProgram");
        glad_glShaderSource = arg1("glShaderSource");
        glad_glUseProgram = arg1("glUseProgram");
        glad_glUniform1f = arg1("glUniform1f");
        glad_glUniform2f = arg1("glUniform2f");
        glad_glUniform3f = arg1("glUniform3f");
        glad_glUniform4f = arg1("glUniform4f");
        glad_glUniform1i = arg1("glUniform1i");
        glad_glUniform2i = arg1("glUniform2i");
        glad_glUniform3i = arg1("glUniform3i");
        glad_glUniform4i = arg1("glUniform4i");
        glad_glUniform1fv = arg1("glUniform1fv");
        glad_glUniform2fv = arg1("glUniform2fv");
        glad_glUniform3fv = arg1("glUniform3fv");
        glad_glUniform4fv = arg1("glUniform4fv");
        glad_glUniform1iv = arg1("glUniform1iv");
        glad_glUniform2iv = arg1("glUniform2iv");
        glad_glUniform3iv = arg1("glUniform3iv");
        glad_glUniform4iv = arg1("glUniform4iv");
        glad_glUniformMatrix2fv = arg1("glUniformMatrix2fv");
        glad_glUniformMatrix3fv = arg1("glUniformMatrix3fv");
        glad_glUniformMatrix4fv = arg1("glUniformMatrix4fv");
        glad_glValidateProgram = arg1("glValidateProgram");
        glad_glVertexAttrib1d = arg1("glVertexAttrib1d");
        glad_glVertexAttrib1dv = arg1("glVertexAttrib1dv");
        glad_glVertexAttrib1f = arg1("glVertexAttrib1f");
        glad_glVertexAttrib1fv = arg1("glVertexAttrib1fv");
        glad_glVertexAttrib1s = arg1("glVertexAttrib1s");
        glad_glVertexAttrib1sv = arg1("glVertexAttrib1sv");
        glad_glVertexAttrib2d = arg1("glVertexAttrib2d");
        glad_glVertexAttrib2dv = arg1("glVertexAttrib2dv");
        glad_glVertexAttrib2f = arg1("glVertexAttrib2f");
        glad_glVertexAttrib2fv = arg1("glVertexAttrib2fv");
        glad_glVertexAttrib2s = arg1("glVertexAttrib2s");
        glad_glVertexAttrib2sv = arg1("glVertexAttrib2sv");
        glad_glVertexAttrib3d = arg1("glVertexAttrib3d");
        glad_glVertexAttrib3dv = arg1("glVertexAttrib3dv");
        glad_glVertexAttrib3f = arg1("glVertexAttrib3f");
        glad_glVertexAttrib3fv = arg1("glVertexAttrib3fv");
        glad_glVertexAttrib3s = arg1("glVertexAttrib3s");
        glad_glVertexAttrib3sv = arg1("glVertexAttrib3sv");
        glad_glVertexAttrib4Nbv = arg1("glVertexAttrib4Nbv");
        glad_glVertexAttrib4Niv = arg1("glVertexAttrib4Niv");
        glad_glVertexAttrib4Nsv = arg1("glVertexAttrib4Nsv");
        glad_glVertexAttrib4Nub = arg1("glVertexAttrib4Nub");
        glad_glVertexAttrib4Nubv = arg1("glVertexAttrib4Nubv");
        glad_glVertexAttrib4Nuiv = arg1("glVertexAttrib4Nuiv");
        glad_glVertexAttrib4Nusv = arg1("glVertexAttrib4Nusv");
        glad_glVertexAttrib4bv = arg1("glVertexAttrib4bv");
        glad_glVertexAttrib4d = arg1("glVertexAttrib4d");
        glad_glVertexAttrib4dv = arg1("glVertexAttrib4dv");
        glad_glVertexAttrib4f = arg1("glVertexAttrib4f");
        glad_glVertexAttrib4fv = arg1("glVertexAttrib4fv");
        glad_glVertexAttrib4iv = arg1("glVertexAttrib4iv");
        glad_glVertexAttrib4s = arg1("glVertexAttrib4s");
        glad_glVertexAttrib4sv = arg1("glVertexAttrib4sv");
        glad_glVertexAttrib4ubv = arg1("glVertexAttrib4ubv");
        glad_glVertexAttrib4uiv = arg1("glVertexAttrib4uiv");
        glad_glVertexAttrib4usv = arg1("glVertexAttrib4usv");
        rax = arg1("glVertexAttribPointer");
        glad_glVertexAttribPointer = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_2_1(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_2_1;
    if (rax != 0)
    {
        glad_glUniformMatrix2x3fv = arg1("glUniformMatrix2x3fv", arg2, 
"glUniformMatrix2x3fv");
        glad_glUniformMatrix3x2fv = arg1("glUniformMatrix3x2fv");
        glad_glUniformMatrix2x4fv = arg1("glUniformMatrix2x4fv");
        glad_glUniformMatrix4x2fv = arg1("glUniformMatrix4x2fv");
        glad_glUniformMatrix3x4fv = arg1("glUniformMatrix3x4fv");
        rax = arg1("glUniformMatrix4x3fv");
        glad_glUniformMatrix4x3fv = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_3_0(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_3_0;
    if (rax != 0)
    {
        glad_glColorMaski = arg1("glColorMaski", arg2, "glColorMaski");
        glad_glGetBooleani_v = arg1("glGetBooleani_v");
        glad_glGetIntegeri_v = arg1("glGetIntegeri_v");
        glad_glEnablei = arg1("glEnablei");
        glad_glDisablei = arg1("glDisablei");
        glad_glIsEnabledi = arg1("glIsEnabledi");
        glad_glBeginTransformFeedback = arg1("glBeginTransformFeedback");
        glad_glEndTransformFeedback = arg1("glEndTransformFeedback");
        glad_glBindBufferRange = arg1("glBindBufferRange");
        glad_glBindBufferBase = arg1("glBindBufferBase");
        glad_glTransformFeedbackVaryings = arg1("glTransformFeedbackVaryings");
        glad_glGetTransformFeedbackVarying = arg1("glGetTransformFeedbackVarying");
        glad_glClampColor = arg1("glClampColor");
        glad_glBeginConditionalRender = arg1("glBeginConditionalRender");
        glad_glEndConditionalRender = arg1("glEndConditionalRender");
        glad_glVertexAttribIPointer = arg1("glVertexAttribIPointer");
        glad_glGetVertexAttribIiv = arg1("glGetVertexAttribIiv");
        glad_glGetVertexAttribIuiv = arg1("glGetVertexAttribIuiv");
        glad_glVertexAttribI1i = arg1("glVertexAttribI1i");
        glad_glVertexAttribI2i = arg1("glVertexAttribI2i");
        glad_glVertexAttribI3i = arg1("glVertexAttribI3i");
        glad_glVertexAttribI4i = arg1("glVertexAttribI4i");
        glad_glVertexAttribI1ui = arg1("glVertexAttribI1ui");
        glad_glVertexAttribI2ui = arg1("glVertexAttribI2ui");
        glad_glVertexAttribI3ui = arg1("glVertexAttribI3ui");
        glad_glVertexAttribI4ui = arg1("glVertexAttribI4ui");
        glad_glVertexAttribI1iv = arg1("glVertexAttribI1iv");
        glad_glVertexAttribI2iv = arg1("glVertexAttribI2iv");
        glad_glVertexAttribI3iv = arg1("glVertexAttribI3iv");
        glad_glVertexAttribI4iv = arg1("glVertexAttribI4iv");
        glad_glVertexAttribI1uiv = arg1("glVertexAttribI1uiv");
        glad_glVertexAttribI2uiv = arg1("glVertexAttribI2uiv");
        glad_glVertexAttribI3uiv = arg1("glVertexAttribI3uiv");
        glad_glVertexAttribI4uiv = arg1("glVertexAttribI4uiv");
        glad_glVertexAttribI4bv = arg1("glVertexAttribI4bv");
        glad_glVertexAttribI4sv = arg1("glVertexAttribI4sv");
        glad_glVertexAttribI4ubv = arg1("glVertexAttribI4ubv");
        glad_glVertexAttribI4usv = arg1("glVertexAttribI4usv");
        glad_glGetUniformuiv = arg1("glGetUniformuiv");
        glad_glBindFragDataLocation = arg1("glBindFragDataLocation");
        glad_glGetFragDataLocation = arg1("glGetFragDataLocation");
        glad_glUniform1ui = arg1("glUniform1ui");
        glad_glUniform2ui = arg1("glUniform2ui");
        glad_glUniform3ui = arg1("glUniform3ui");
        glad_glUniform4ui = arg1("glUniform4ui");
        glad_glUniform1uiv = arg1("glUniform1uiv");
        glad_glUniform2uiv = arg1("glUniform2uiv");
        glad_glUniform3uiv = arg1("glUniform3uiv");
        glad_glUniform4uiv = arg1("glUniform4uiv");
        glad_glTexParameterIiv = arg1("glTexParameterIiv");
        glad_glTexParameterIuiv = arg1("glTexParameterIuiv");
        glad_glGetTexParameterIiv = arg1("glGetTexParameterIiv");
        glad_glGetTexParameterIuiv = arg1("glGetTexParameterIuiv");
        glad_glClearBufferiv = arg1("glClearBufferiv");
        glad_glClearBufferuiv = arg1("glClearBufferuiv");
        glad_glClearBufferfv = arg1("glClearBufferfv");
        glad_glClearBufferfi = arg1("glClearBufferfi");
        glad_glGetStringi = arg1("glGetStringi");
        glad_glIsRenderbuffer = arg1("glIsRenderbuffer");
        glad_glBindRenderbuffer = arg1("glBindRenderbuffer");
        glad_glDeleteRenderbuffers = arg1("glDeleteRenderbuffers");
        glad_glGenRenderbuffers = arg1("glGenRenderbuffers");
        glad_glRenderbufferStorage = arg1("glRenderbufferStorage");
        glad_glGetRenderbufferParameteriv = arg1("glGetRenderbufferParameteriv");
        glad_glIsFramebuffer = arg1("glIsFramebuffer");
        glad_glBindFramebuffer = arg1("glBindFramebuffer");
        glad_glDeleteFramebuffers = arg1("glDeleteFramebuffers");
        glad_glGenFramebuffers = arg1("glGenFramebuffers");
        glad_glCheckFramebufferStatus = arg1("glCheckFramebufferStatus");
        glad_glFramebufferTexture1D = arg1("glFramebufferTexture1D");
        glad_glFramebufferTexture2D = arg1("glFramebufferTexture2D");
        glad_glFramebufferTexture3D = arg1("glFramebufferTexture3D");
        glad_glFramebufferRenderbuffer = arg1("glFramebufferRenderbuffer");
        glad_glGetFramebufferAttachmentParameteriv = 
arg1("glGetFramebufferAttachmentParame…");
        glad_glGenerateMipmap = arg1("glGenerateMipmap");
        glad_glBlitFramebuffer = arg1("glBlitFramebuffer");
        glad_glRenderbufferStorageMultisample = arg1("glRenderbufferStorageMultisample");
        glad_glFramebufferTextureLayer = arg1("glFramebufferTextureLayer");
        glad_glMapBufferRange = arg1("glMapBufferRange");
        glad_glFlushMappedBufferRange = arg1("glFlushMappedBufferRange");
        glad_glBindVertexArray = arg1("glBindVertexArray");
        glad_glDeleteVertexArrays = arg1("glDeleteVertexArrays");
        glad_glGenVertexArrays = arg1("glGenVertexArrays");
        rax = arg1("glIsVertexArray");
        glad_glIsVertexArray = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_3_1(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_3_1;
    if (rax != 0)
    {
        glad_glDrawArraysInstanced = arg1("glDrawArraysInstanced", arg2, 
"glDrawArraysInstanced");
        glad_glDrawElementsInstanced = arg1("glDrawElementsInstanced");
        glad_glTexBuffer = arg1("glTexBuffer");
        glad_glPrimitiveRestartIndex = arg1("glPrimitiveRestartIndex");
        glad_glCopyBufferSubData = arg1("glCopyBufferSubData");
        glad_glGetUniformIndices = arg1("glGetUniformIndices");
        glad_glGetActiveUniformsiv = arg1("glGetActiveUniformsiv");
        glad_glGetActiveUniformName = arg1("glGetActiveUniformName");
        glad_glGetUniformBlockIndex = arg1("glGetUniformBlockIndex");
        glad_glGetActiveUniformBlockiv = arg1("glGetActiveUniformBlockiv");
        glad_glGetActiveUniformBlockName = arg1("glGetActiveUniformBlockName");
        glad_glUniformBlockBinding = arg1("glUniformBlockBinding");
        glad_glBindBufferRange = arg1("glBindBufferRange");
        glad_glBindBufferBase = arg1("glBindBufferBase");
        rax = arg1("glGetIntegeri_v");
        glad_glGetIntegeri_v = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_3_2(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_3_2;
    if (rax != 0)
    {
        glad_glDrawElementsBaseVertex = arg1("glDrawElementsBaseVertex", arg2, 
"glDrawElementsBaseVertex");
        glad_glDrawRangeElementsBaseVertex = arg1("glDrawRangeElementsBaseVertex");
        glad_glDrawElementsInstancedBaseVertex = arg1("glDrawElementsInstancedBaseVerte…");
        glad_glMultiDrawElementsBaseVertex = arg1("glMultiDrawElementsBaseVertex");
        glad_glProvokingVertex = arg1("glProvokingVertex");
        glad_glFenceSync = arg1("glFenceSync");
        glad_glIsSync = arg1("glIsSync");
        glad_glDeleteSync = arg1("glDeleteSync");
        glad_glClientWaitSync = arg1("glClientWaitSync");
        glad_glWaitSync = arg1("glWaitSync");
        glad_glGetInteger64v = arg1("glGetInteger64v");
        glad_glGetSynciv = arg1("glGetSynciv");
        glad_glGetInteger64i_v = arg1("glGetInteger64i_v");
        glad_glGetBufferParameteri64v = arg1("glGetBufferParameteri64v");
        glad_glFramebufferTexture = arg1("glFramebufferTexture");
        glad_glTexImage2DMultisample = arg1("glTexImage2DMultisample");
        glad_glTexImage3DMultisample = arg1("glTexImage3DMultisample");
        glad_glGetMultisamplefv = arg1("glGetMultisamplefv");
        rax = arg1("glSampleMaski");
        glad_glSampleMaski = rax;
    }
    return rax;
}

uint64_t load_GL_VERSION_3_3(int64_t arg1, int64_t arg2)
{
    uint64_t rax = GLAD_GL_VERSION_3_3;
    if (rax != 0)
    {
        glad_glBindFragDataLocationIndexed = arg1("glBindFragDataLocationIndexed", arg2, 
"glBindFragDataLocationIndexed");
        glad_glGetFragDataIndex = arg1("glGetFragDataIndex");
        glad_glGenSamplers = arg1("glGenSamplers");
        glad_glDeleteSamplers = arg1("glDeleteSamplers");
        glad_glIsSampler = arg1("glIsSampler");
        glad_glBindSampler = arg1("glBindSampler");
        glad_glSamplerParameteri = arg1("glSamplerParameteri");
        glad_glSamplerParameteriv = arg1("glSamplerParameteriv");
        glad_glSamplerParameterf = arg1("glSamplerParameterf");
        glad_glSamplerParameterfv = arg1("glSamplerParameterfv");
        glad_glSamplerParameterIiv = arg1("glSamplerParameterIiv");
        glad_glSamplerParameterIuiv = arg1("glSamplerParameterIuiv");
        glad_glGetSamplerParameteriv = arg1("glGetSamplerParameteriv");
        glad_glGetSamplerParameterIiv = arg1("glGetSamplerParameterIiv");
        glad_glGetSamplerParameterfv = arg1("glGetSamplerParameterfv");
        glad_glGetSamplerParameterIuiv = arg1("glGetSamplerParameterIuiv");
        glad_glQueryCounter = arg1("glQueryCounter");
        glad_glGetQueryObjecti64v = arg1("glGetQueryObjecti64v");
        glad_glGetQueryObjectui64v = arg1("glGetQueryObjectui64v");
        glad_glVertexAttribDivisor = arg1("glVertexAttribDivisor");
        glad_glVertexAttribP1ui = arg1("glVertexAttribP1ui");
        glad_glVertexAttribP1uiv = arg1("glVertexAttribP1uiv");
        glad_glVertexAttribP2ui = arg1("glVertexAttribP2ui");
        glad_glVertexAttribP2uiv = arg1("glVertexAttribP2uiv");
        glad_glVertexAttribP3ui = arg1("glVertexAttribP3ui");
        glad_glVertexAttribP3uiv = arg1("glVertexAttribP3uiv");
        glad_glVertexAttribP4ui = arg1("glVertexAttribP4ui");
        glad_glVertexAttribP4uiv = arg1("glVertexAttribP4uiv");
        glad_glVertexP2ui = arg1("glVertexP2ui");
        glad_glVertexP2uiv = arg1("glVertexP2uiv");
        glad_glVertexP3ui = arg1("glVertexP3ui");
        glad_glVertexP3uiv = arg1("glVertexP3uiv");
        glad_glVertexP4ui = arg1("glVertexP4ui");
        glad_glVertexP4uiv = arg1("glVertexP4uiv");
        glad_glTexCoordP1ui = arg1("glTexCoordP1ui");
        glad_glTexCoordP1uiv = arg1("glTexCoordP1uiv");
        glad_glTexCoordP2ui = arg1("glTexCoordP2ui");
        glad_glTexCoordP2uiv = arg1("glTexCoordP2uiv");
        glad_glTexCoordP3ui = arg1("glTexCoordP3ui");
        glad_glTexCoordP3uiv = arg1("glTexCoordP3uiv");
        glad_glTexCoordP4ui = arg1("glTexCoordP4ui");
        glad_glTexCoordP4uiv = arg1("glTexCoordP4uiv");
        glad_glMultiTexCoordP1ui = arg1("glMultiTexCoordP1ui");
        glad_glMultiTexCoordP1uiv = arg1("glMultiTexCoordP1uiv");
        glad_glMultiTexCoordP2ui = arg1("glMultiTexCoordP2ui");
        glad_glMultiTexCoordP2uiv = arg1("glMultiTexCoordP2uiv");
        glad_glMultiTexCoordP3ui = arg1("glMultiTexCoordP3ui");
        glad_glMultiTexCoordP3uiv = arg1("glMultiTexCoordP3uiv");
        glad_glMultiTexCoordP4ui = arg1("glMultiTexCoordP4ui");
        glad_glMultiTexCoordP4uiv = arg1("glMultiTexCoordP4uiv");
        glad_glNormalP3ui = arg1("glNormalP3ui");
        glad_glNormalP3uiv = arg1("glNormalP3uiv");
        glad_glColorP3ui = arg1("glColorP3ui");
        glad_glColorP3uiv = arg1("glColorP3uiv");
        glad_glColorP4ui = arg1("glColorP4ui");
        glad_glColorP4uiv = arg1("glColorP4uiv");
        glad_glSecondaryColorP3ui = arg1("glSecondaryColorP3ui");
        rax = arg1("glSecondaryColorP3uiv");
        glad_glSecondaryColorP3uiv = rax;
    }
    return rax;
}

int64_t find_extensionsGL()
{
    int32_t rax;
    rax = get_exts() == 0;
    int64_t rax_1;
    if (rax == 0)
    {
        free_exts();
        rax_1 = 1;
    }
    else
    {
        rax_1 = 0;
    }
    return rax_1;
}

int64_t find_coreGL()
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    char const* const var_38 = "OpenGL ES-CM ";
    char const* const var_30 = "OpenGL ES-CL ";
    char const* const var_28 = "OpenGL ES ";
    int64_t var_20 = 0;
    char* var_48 = glad_glGetString(0x1f02);
    if (var_48 != 0)
    {
        int32_t var_4c_1 = 0;
        while (&var_38[var_4c_1] != 0)
        {
            uint64_t rax_6 = strlen(&var_38[var_4c_1]);
            if (strncmp(var_48, &var_38[var_4c_1], rax_6) == 0)
            {
                var_48 = &var_48[rax_6];
                break;
            }
            var_4c_1 = (var_4c_1 + 1);
        }
        uint32_t var_54;
        uint32_t var_50;
        __isoc99_sscanf(var_48, "%d.%d", &var_54, &var_50);
        *GLVersion = var_54;
        *(GLVersion + 4) = var_50;
        max_loaded_major = var_54;
        max_loaded_minor = var_50;
        char rax_24;
        if (((var_54 != 1 || (var_54 == 1 && var_50 < 0)) && var_54 <= 1))
        {
            rax_24 = 0;
        }
        if (((var_54 == 1 && var_50 >= 0) || ((var_54 != 1 || (var_54 == 1 && var_50 < 0)) && 
var_54 > 1)))
        {
            rax_24 = 1;
        }
        GLAD_GL_VERSION_1_0 = rax_24;
        char rax_29;
        if (((var_54 != 1 || (var_54 == 1 && var_50 <= 0)) && var_54 <= 1))
        {
            rax_29 = 0;
        }
        if (((var_54 == 1 && var_50 > 0) || ((var_54 != 1 || (var_54 == 1 && var_50 <= 0)) && 
var_54 > 1)))
        {
            rax_29 = 1;
        }
        GLAD_GL_VERSION_1_1 = rax_29;
        char rax_34;
        if (((var_54 != 1 || (var_54 == 1 && var_50 <= 1)) && var_54 <= 1))
        {
            rax_34 = 0;
        }
        if (((var_54 == 1 && var_50 > 1) || ((var_54 != 1 || (var_54 == 1 && var_50 <= 1)) && 
var_54 > 1)))
        {
            rax_34 = 1;
        }
        GLAD_GL_VERSION_1_2 = rax_34;
        char rax_39;
        if (((var_54 != 1 || (var_54 == 1 && var_50 <= 2)) && var_54 <= 1))
        {
            rax_39 = 0;
        }
        if (((var_54 == 1 && var_50 > 2) || ((var_54 != 1 || (var_54 == 1 && var_50 <= 2)) && 
var_54 > 1)))
        {
            rax_39 = 1;
        }
        GLAD_GL_VERSION_1_3 = rax_39;
        char rax_44;
        if (((var_54 != 1 || (var_54 == 1 && var_50 <= 3)) && var_54 <= 1))
        {
            rax_44 = 0;
        }
        if (((var_54 == 1 && var_50 > 3) || ((var_54 != 1 || (var_54 == 1 && var_50 <= 3)) && 
var_54 > 1)))
        {
            rax_44 = 1;
        }
        GLAD_GL_VERSION_1_4 = rax_44;
        char rax_49;
        if (((var_54 != 1 || (var_54 == 1 && var_50 <= 4)) && var_54 <= 1))
        {
            rax_49 = 0;
        }
        if (((var_54 == 1 && var_50 > 4) || ((var_54 != 1 || (var_54 == 1 && var_50 <= 4)) && 
var_54 > 1)))
        {
            rax_49 = 1;
        }
        GLAD_GL_VERSION_1_5 = rax_49;
        char rax_54;
        if (((var_54 != 2 || (var_54 == 2 && var_50 < 0)) && var_54 <= 2))
        {
            rax_54 = 0;
        }
        if (((var_54 == 2 && var_50 >= 0) || ((var_54 != 2 || (var_54 == 2 && var_50 < 0)) && 
var_54 > 2)))
        {
            rax_54 = 1;
        }
        GLAD_GL_VERSION_2_0 = rax_54;
        char rax_59;
        if (((var_54 != 2 || (var_54 == 2 && var_50 <= 0)) && var_54 <= 2))
        {
            rax_59 = 0;
        }
        if (((var_54 == 2 && var_50 > 0) || ((var_54 != 2 || (var_54 == 2 && var_50 <= 0)) && 
var_54 > 2)))
        {
            rax_59 = 1;
        }
        GLAD_GL_VERSION_2_1 = rax_59;
        char rax_64;
        if (((var_54 != 3 || (var_54 == 3 && var_50 < 0)) && var_54 <= 3))
        {
            rax_64 = 0;
        }
        if (((var_54 == 3 && var_50 >= 0) || ((var_54 != 3 || (var_54 == 3 && var_50 < 0)) && 
var_54 > 3)))
        {
            rax_64 = 1;
        }
        GLAD_GL_VERSION_3_0 = rax_64;
        char rax_69;
        if (((var_54 != 3 || (var_54 == 3 && var_50 <= 0)) && var_54 <= 3))
        {
            rax_69 = 0;
        }
        if (((var_54 == 3 && var_50 > 0) || ((var_54 != 3 || (var_54 == 3 && var_50 <= 0)) && 
var_54 > 3)))
        {
            rax_69 = 1;
        }
        GLAD_GL_VERSION_3_1 = rax_69;
        char rax_74;
        if (((var_54 != 3 || (var_54 == 3 && var_50 <= 1)) && var_54 <= 3))
        {
            rax_74 = 0;
        }
        if (((var_54 == 3 && var_50 > 1) || ((var_54 != 3 || (var_54 == 3 && var_50 <= 1)) && 
var_54 > 3)))
        {
            rax_74 = 1;
        }
        GLAD_GL_VERSION_3_2 = rax_74;
        char rax_79;
        if (((var_54 != 3 || (var_54 == 3 && var_50 <= 2)) && var_54 <= 3))
        {
            rax_79 = 0;
        }
        if (((var_54 == 3 && var_50 > 2) || ((var_54 != 3 || (var_54 == 3 && var_50 <= 2)) && 
var_54 > 3)))
        {
            rax_79 = 1;
        }
        GLAD_GL_VERSION_3_3 = rax_79;
        if ((*GLVersion > 3 || ((*GLVersion <= 3 && *GLVersion > 2) && *(GLVersion + 4) > 2)))
        {
            max_loaded_major = 3;
            max_loaded_minor = 3;
        }
    }
    if (rax == *(fsbase + 0x28))
    {
        return (rax - *(fsbase + 0x28));
    }
    __stack_chk_fail();
    /* no return */
}

uint64_t gladLoadGLLoader(int64_t arg1)
{
    *GLVersion = 0;
    *(GLVersion + 4) = 0;
    int64_t rsi;
    glad_glGetString = arg1("glGetString", rsi, "glGetString");
    uint64_t rax_3;
    if (glad_glGetString == 0)
    {
        rax_3 = 0;
    }
    else
    {
        int64_t rax_5;
        rax_5 = glad_glGetString(0x1f02) == 0;
        if (rax_5 != 0)
        {
            rax_3 = 0;
        }
        else
        {
            int64_t rsi_12 = load_GL_VERSION_3_2(arg1, load_GL_VERSION_3_1(arg1, 
load_GL_VERSION_3_0(arg1, load_GL_VERSION_2_1(arg1, load_GL_VERSION_2_0(arg1, 
load_GL_VERSION_1_5(arg1, load_GL_VERSION_1_4(arg1, load_GL_VERSION_1_3(arg1, 
load_GL_VERSION_1_2(arg1, load_GL_VERSION_1_1(arg1, load_GL_VERSION_1_0(arg1, 
find_coreGL())))))))))));
            load_GL_VERSION_3_3(arg1, rsi_12);
            int32_t rax_18;
            rax_18 = find_extensionsGL() == 0;
            if (rax_18 != 0)
            {
                rax_3 = 0;
            }
            else
            {
                char rax_21;
                if ((*GLVersion != 0 || (*GLVersion == 0 && *(GLVersion + 4) != 0)))
                {
                    rax_21 = 1;
                }
                if ((*GLVersion == 0 && *(GLVersion + 4) == 0))
                {
                    rax_21 = 0;
                }
                rax_3 = rax_21;
            }
        }
    }
    return rax_3;
}

int64_t _fini()
{
    return;
}


